---
title: "Preparing the data for estimating volumes"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
bibliography: /home/ALe-Squin/work/library/bib_file/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    keep-tex: true
    pdf-engine: lualatex
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

\newcommand{\ie}{*i.e.,*}
\newcommand{\F}{\mathscr{F}}
\newcommand{\N}{\mathbfscr{N}}

## Introduction

The data were provided by Christine Deleuze by e-mail the 17 September 2024. The format is a single `.RData` file, which is stored remotely on the server 'Abies' (`smb://del1509n015/`) in the protected folder (only reading rights) `2024_faircarbon/data_orig/`. The person to contact to add data to this folder is Thierry Leclaire.

For Linux, and maybe MacOS, it is necessary to mount locally the remote folder in order to access the data from R. According to Henri Cunny, it is not necessary for Windows (at least for remote folders on Abies, maybe because smb is a Windows protocol). All of this is explained in the @sec-mount_folder.

In order to understand the data, I first define what is a tree in @sec-what_a_tree. There are also some test to reconstruct the data from raw data to show explicitly how volumes where calculated (see @sec-nfi_query, @sec-trunkVol, and @sec-branchVol)

### Define what is a tree {#sec-what_a_tree}

Trees are partitioned into hierarchical elements in Forest Inventories (\eg @fig-partition). Definitions of elements can vary between inventories, and they do not necessarily contains the same data. In our case, the tree data come from different institutes and different periods of time:

1.  'Protocole Oudin', dataset preserved by INRA, between 1930 and 1980 (<span class="egypt_red"></span> on the @fig-map)

2.  The French NFI (<span class="egypt_blue"></span> on the @fig-map). I do not trust the dataset provided by C. Deleuze: I do not know where it comes from, nor who provided it, but there are about 50% of the plot id (labelled `CPP` in the table) that cannot be found when I or Cedric Duprez do our own request. They are also subtleties with diameters and circumferences... Therefore, I decided to do my own request of the data, which is also better for reproducibility. Details are explained in @sec-nfi_query. Data range from 1988 to 2007.

3.  The 'Office National des Forêts (ONF)', with protocols from 1972 and from 1983. I do not use these data as there is no coordinates

4.  Institut Technologique Forêt, Cellulose, Bois-construction, Ameublement (FCBA), which I do not use so far

5.  L'Institut pour le développement forestier (IDF) which is the R&D of the Centre National de la Propriété Forestière and the Institut national de recherche en sciences et technologies pour l'environnement et l'agriculture (IRSTEA, currently INRAE)

```{mermaid}
%%| label: fig-partition
%%| fig-cap: Partition of a tree (inspired by @Gschwantner2009)

flowchart LR
subgraph SUB0 [Level 0]
	W(Whole tree)
end

subgraph SUB1 [Level 1]
	W --> A(Above-ground)
	W --> B(Below-ground)
end

subgraph SUB2 [Level 2]
	A --> M(Main stem)
	A --> L(Lateral)
	A --> F(Foliage)

	B --> E(...)
end

subgraph SUB3 [Level 3]
	M --> S(Stem top)
	M --> MB(Bole)
	M --> MS(Stump)
	L --> LB(Large branches)
	L --> SB(Small branches)
end
```

We decided to use the definitions from @Gschwantner2009 (see @fig-partition and @fig-treeDef):

- Main stem: The stem of a tree is the above-ground part of the main (off) shoot with apical dominance
	- Stem top: topmost part of the stem from an over-bark base-diameter of \qty{7}{\centi\metre} (French NFI) to the stem tip
	- Bole: above-ground part of the stem between stump and the stem top
	- Stump: above-ground base part of the stem which would remain after a tree was cut under normal felling practices
- Lateral parts:
	- Large branches: portion of the above-ground lateral parts with a diameter of more than or equal to \qty{7}{\centi\metre} (French NFI)
	- Large branches: portion of the above-ground lateral parts with a diameter of less than \qty{7}{\centi\metre} (French NFI)

![Tree partition, with Bole (<span class="egypt_green"></span>), stem top (<span class="egypt_yellow"></span>), large branches (<span class="egypt_blue"></span>), and small branches (<span class="egypt_red"></span>)](img/tree_ign.png){#fig-treeDef}

### Mount the remote folder {#sec-mount_folder}

1.  Switch to super user where you replace `JohnField-Admin` (really nice [Irish composer](https://www.youtube.com/watch?v=Uktj2MYSsaU)) by your admin name (typically, your IGN id followed by `-Admin`):

```{sh}
#| eval: false
#| code-fold: false
su JohnField-Admin
```

Your **admin** password will be asked

2.  Create a directory where you will mount the remote folder. By default I like to put it in `/mnt/local_share`. You need to be super user to write in `/mnt/`:

```{sh}
#| eval: false
#| code-fold: false
sudo mkdir /mnt/local_share
```

This step should be done only once.

3.  Mount the remote folder `smb://del1509n015/2024_faircarbon/`, where you replace `your_name` by your **usual** IGN id (NOT the admin one):

```{sh}
#| eval: false
#| code-fold: false
sudo mount -t cifs -o username=your_name,domain=ign,uid=your_name //del1509n015/2024_faircarbon /mnt/local_share/
```

Maybe two passwords will be asked, first your **admin** password to execute the `sudo`, and then your **usual** password. If you just did step 2, then the prompt will not ask again for your **admin** password again.

4.  Check that it worked, especially the reading and writting rigths:

```{sh}
#| eval: false
#| code-fold: false
ls -l /mnt/local_share/
```

The content of the remote folder should appear. You can close your admin session by using `ctrl + d` or `Cmd + d`

Now that the raw data are accessible to {{< fa brands r-project >}}, it is time to prepare them!

## Prepare the data

### Loading the data

The following packages are required to load and handle the data and print summary tables:
```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(inventR)
library(stringi)
library(terra)
library(gt)
```

And one helper function to convert degree coordinates to decimals (for the INRA data):
```{r}
angle2dec = function(angle)
{
	x = stri_match(angle, regex = "([+-]?\\d+)°(\\d+)'(\\d+)") # To split the degree from minute and second
	x = apply(x[, 2:4], 1L, function(y) {
		y = as.numeric(y)
		y[1] + y[2]/60 + y[3]/3600
	})
	return(x)
}
```

Read the data from (mounted) remote folder:
```{r}
#### Prepare data
## Loading
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
	path_data = paste0(mnt_point, "data_orig/")
	if (!dir.exists(path_data))
		stop(paste0("Folder <", path_data, "> does not exist! Check mounting point and mounted folder"))
} else if (os == "Windows") {
	path_data = "//Del1509n015/2024_FairCarbon/data_orig/"
	if (!dir.exists(path_data))
		stop(paste0("Folder <", path_data, "> does not exist!"))
} else {
	stop(paste("Unknown Operating System:", os))
}

# Emerge data
filename_emerge = paste0(path_data, "EMERGE.RData")
if (!file.exists(filename_emerge))
	stop(paste0("The file <", filename_emerge, "> does not exist"))

load(filename_emerge)

# Swiss data
filename_switzerland = paste0(path_data, "switzerland/stembranchchwood_2024-04-25.txt")
if (!file.exists(filename_switzerland))
	stop(paste0("The file <", filename_switzerland, "> does not exist"))

swiss_dt = fread(filename_switzerland)
swiss_sp = fread(paste0(path_data, "switzerland/Species_correspondance_table.csv"))
```

### Variable names

The variable names are not necessarily unified (but the species names are, I checked! So I can safely use the data.table `codesessences`). I gather in @tbl-notations the data-specific variable names and the common english name I use hereafter.

| INRA            | NFI  | Common             | Description                        |
|----------------:|-----:|:-------------------|:-----------------------------------|
| id              | npp  | plot_id            | Plot id                            |
| nom_fichier     | \-   | unique_id          | Unique id                          |
| essence         | ess  | speciesName_sci    | Species name                       |
| c130            | c13  | circumference_m    | Circumference at 1.3 m             |
| h_tot           | htot | height             | Height in m                        |
| total_volume_m3 | \-   | total_volume_m3    | Total above-ground volume          |
| v_tronc         | v    | bole_volume_m3     | Volume bole up to 7 cm             |
| v_courrone      | \-   | crown_volume_m3    | Total volume minus bole volume     |
| genre           | \-   | genus              | Genus                              |
| longitude       | xl   | \-                 | Coordinates in different proj      |
| latitude        | yl   | \-                 | Coordinates in different proj      |

: Variable names {#tbl-notations .borderless .hover}

### Species
For convenience, I format the species data frame with strings rather than factor, change it to data.table, and add some variables:
```{r}
setDT(codesessences)

codesessences[, nfi := as.character(essence_ifn)]
codesessences[, genre := as.character(genre)]
codesessences[, espece := as.character(espece)]
codesessences[, nomessence := as.character(nomessence)]

codesessences[essence_ifn < 10, nfi := paste0("0", nfi)]
```

I noticed one error in the `codesessences` data.table for the species `essence_ifn = 65`. It is written *Cedrus atlantica ou libani* but it should be *Cedrus atlantica* according to the French NFI.

```{r}
codesessences[essence_ifn == 65, c("nomessence", "espece") := .("cèdre de l Atlas", "atlantica")]
```

Then, I also decided to merge *Pinus nigra ssp pallasiana* with *Pinus nigra* because there are only 7 individuals *v.s.* 240. Note that after all, *Pinus nigra ssp pallasiana* [is a synonym](https://inpn.mnhn.fr/espece/listeEspeces/pinus+nigra/) of *Pinus nigra ssp nigra*, which is quite close to *Pinus nigra*. There is also a mistake for `Thuja plicata`, it is written `Thuya`. The unknown genus are transformed when possible to `Broadleaves` or `Conifers`.

```{r}
codesessences[espece == "nigra ssp pallasiana", espece := "nigra"]
codesessences[genre == "Thuya", genre := "Thuja"]
codesessences[genre == "inconnu (feuillus)", genre := "Broadleaves"]
codesessences[genre == "inconnu (résineux)", genre := "Conifers"]
codesessences[, c("speciesName_sci", "fct_type") := .(paste(genre, espece), ifelse(feuillu, "broadleaf", "conifer"))]
```

Finally, the `essence_ifn = 99913` is for grouping *Quercus robur* and *Quercus petraea*, while `essence_ifn = 1` groups *Quercus robur*, *Quercus petraea*, and *Quercus pubescens*. I decided to merge these two codes, using the largest group (\ie `essence_ifn = 1`).
```{r}
ref_nomessence = codesessences[essence == 19, nomessence]
ref_espece = codesessences[essence == 19, espece]
ref_speciesName_sci = codesessences[essence == 19, speciesName_sci]
codesessences[essence == 22,
	c("nomessence", "espece", "speciesName_sci") := .(ref_nomessence, ref_espece, ref_speciesName_sci)]
```

### Clean the datasets and compute new variables

Keep only the columns of interest, change column names, transform everything to `data.table` for INRA data and for helper data tables (`codesforets`, which contains coordinates, and `codesessences`, which contains species codes):
```{r}
setDT(inra_arbres)
setDT(codesforets)

## Compute (total) volume in m³, and format data
inra_arbres[, total_volume_m3 := (v_tronc_verif + v_fourche_verif + v_fourche2_verif + v_br_verif + v_menu_verif)/1e3]
inra_arbres[, v_tronc_verif := v_tronc_verif/1e3] # Conversion to m3
inra_arbres[, v_courrone := total_volume_m3 - v_tronc_verif] # Volume of the crown, i.e., everything that is NOT trunk > 7 cm
inra_arbres[, circumference_m := c130/100]

inra_arbres[, year := format(as.Date(date, "%Y-%m-%d"), "%Y")]

## Keep only column of interest and rename them
inra_arbres = unique(inra_arbres[, .(nom_fichier, id_codesessences, circumference_m, h_tot,
	total_volume_m3, v_tronc_verif, v_courrone, genre, id_codesforets, year)])
inra_arbres = merge.data.table(inra_arbres, codesforets[, .(id, longitude, latitude)],
	by.x = "id_codesforets", by.y = "id")
inra_arbres = merge.data.table(inra_arbres, codesessences[, .(essence, speciesName_sci, fct_type)],
	by.x = "id_codesessences", by.y = "essence")

inra_arbres = na.omit(inra_arbres)

setnames(inra_arbres, new = c("species_code_inra", "plot_id", "unique_id", "circumference_m", "height",
	"total_volume_m3", "bole_volume_m3", "crown_volume_m3", "genus", "year", "lon", "lat",
	"speciesName_sci", "fct_type"))

## Change type of cols
inra_arbres[, unique_id := as.character(unique_id)]
inra_arbres[, genus := as.character(genus)]
```

### Request of the French NFI data (using inventR package) {#sec-nfi_query}

As said above, I do not trust the data.frame `ifn_arbres`. I do my own request here, to get tree volumes and the plot coordinates. Note that I filtered trees measured before 1988 because diameters were collected instead of circumferences. This is known to be less precise (as the trunk is more likely to be an ovoid) and so it is better to start from 1988, where the circumferences are measured (Florence Gohon, *pers. comm.*).

```{r}
## French NFI data query
db = connect_db()

nfi_data = exec_req(conn = db, req = "
	SELECT
		tree.NPP, tree.A, tree.ESS, tree.C13, tree.HTOT, tree.R, tree.V, tree.VTOT,
		tree.d26, tree.ddec, tree.dmed, tree.cmed, tree.hdec,
		log.surlon, log.surdia, log.ns,
		coords1.XL, coords1.YL,
		EXTRACT(YEAR FROM coords2.DATEPOINT) AS year

	FROM
		inv_exp_am.g3arbre AS tree
		
		LEFT JOIN inv_exp_am.g3bille AS log
		ON log.npp = tree.npp AND log.A = tree.A

		LEFT JOIN inv_exp_am.e1point AS coords1
		ON coords1.npp = tree.npp
		
		LEFT JOIN inv_exp_am.e2point AS coords2
		ON coords2.npp = tree.npp

	WHERE
		tree.CUBE = 'M' AND -- Tree volume measured rather than evaluated by a model
		tree.MC IN ('4', '5') AND -- Circumference measured, and not diameter
		(tree.DOM BETWEEN '0' AND '5') -- No pollarded nor heavily pruned tree

	ORDER BY
		npp, a;", DT = TRUE)

disconnect_db(db)
```

I believe that it is important to know how the data are built! Here, `vtot` is the sum of three volumes coming from:

1. A first log, from the base level to either \qty{2.60}{\metre} or $h_{\text{dec}}$, measured using the cylinder formula:
$$
v_1 = \begin{cases}
	\frac{h_{\text{dec}} c_{\text{med}}^2}{4 \pi} & \text{if } h_{\text{dec}} < 2.6
	\frac{2.60 c^2}{4 \pi} & \text{if } h_{\text{dec}} \geqslant 2.6 \\
\end{cases}
$$
where $c_{\text{med}}$ is the median circumference measured at $h_{\text{dec}}/2$. Note that when $h_{\text{dec}} = 2.6$, the median circumference is not necessarily equal to $c$! The difference, remains however quite small (see @fig-dens_cmed).
```{r}
#| echo: false
#| fig-cap: Density of $c_{\text{med}} - c$
#| label: fig-dens_cmed
plot(density(nfi_data[hdec == 2.6, cmed - c13]), main = "", xlab = "Median minus breast height circumferences",
	lwd = 3, axes = FALSE)
axis(1)
axis(2, las =  1)
```
2. A second log, from \qty{2.60}{\metre} to the taper cut-off height (height at which there is at least a 10% decrease in diameter within a meter), measured using the three-level Newton-Simpson formula:
$$
v_2 = \frac{\pi}{24} \cdot (d_{26}^2 + 4 d_{\text{m}}^2 + d_{\text{dec}}^2) \cdot (h_{\text{dec}} - 2.60)
$$
3. $n \geqslant 0$ log sections of the trunk, from the taper cut-off height (in the case of a taper cut) to the merchantable timber cut-off (\qty{7}{\centi\metre} diameter for the French NFI), calculated using the cylinder formula:
$$
v_3 = \frac{\pi}{4}\sum_{n \geqslant 0} d^2 l
$$

In the data, I downloaded both $v$ and $v_{\text{tot}}$ which should be equal only when there is no cull. Otherwise, $v > v_{\text{tot}}$ since $v = (1 - r) v_{\text{tot}}$, $r$ being the cull. However, I found that these two variables are always equal and that the cull volume is always removed! My reconstruction of the volume does not remove the cull, and should be used later on to relate volume and circumference.

```{r}
#| results: hold
nfi_data[hdec < 2.6, v1 := cmed^2/(4*pi)*hdec] # Volume first part: from 0 to hdec. Note that hdec == 2.6 still uses cmed
nfi_data[hdec >= 2.6, v1 := c13^2/(4*pi)*2.6] # Volume first part: from 0 to 2.6m high
nfi_data[, v2 := pi/24*(d26^2 + 4*dmed^2 + ddec^2)*(hdec - 2.6)] # Volume 2nd part: from 2.6m to hdec
nfi_data[, v3 := pi/4*sum(surdia^2*surlon), by = .(npp, a)] # Volume 3rd part: from hdec to diameter = 7cm

nfi_data[, c("surlon", "surdia", "ns") := NULL]

nfi_data[is.na(v2), v2 := 0]
nfi_data[is.na(v3), v3 := 0]
nfi_data[, bole_volume_reconstruct_m3 := v1 + v2 + v3]
nfi_data[, verif := (1 - r)*bole_volume_reconstruct_m3 - vtot] # This shows that the cull is removed from both v and vtot

## Distribution of the volume diff and of hdec (taper height) for 'high' differences (> 1e-2)
hist(nfi_data$verif)
plot(nfi_data[abs(verif) > 1e-2, density(hdec)], xlab = "hdec", main = "", axes = FALSE, lwd = 3)
abline(v = 2.6, lwd = 2, col = "#CD212A")
axis(1)
axis(2, las = 1)

## Remove columns of little interest
nfi_data[, c("v1", "v2", "v3", "d26", "dmed", "cmed", "verif") := NULL]

nfi_data = na.omit(nfi_data)

## Add scientific species names
nfi_data = merge.data.table(nfi_data, codesessences[, .(nfi, genre, speciesName_sci, fct_type)],
	by.x = "ess", by.y = "nfi")

## Strangely, v and vtot are the same... I keep v then
if (isTRUE(nfi_data[, all.equal(v, vtot, tol = 1e-5)]))
{
	print("The cols v and vtot are the same, which is strange as I was expecting vtot = (1 - r)*v. I remove vtot and r")
	nfi_data[, vtot := NULL]
	nfi_data[, r := NULL]
} else {
	stop("When I downloaded the data, v and vtot were the same. It seems it is not anymore! Check what could have happened")
}

## Change column names
setnames(nfi_data, new = c("species_code_nfi", "plot_id", "tree_id", "circumference_m", "height", "bole_volume_m3",
	"taper_diameter", "taper_height", "x_lambert", "y_lambert", "year", "bole_volume_reconstruct_m3", "genus",
	"speciesName_sci", "fct_type"))

## Densities of circumference and height for taper_height < 2.6
plot(nfi_data[taper_height <= 2.6, density(height)], xlab = "Height", main = "", axes = FALSE, lwd = 3)
axis(1)
axis(2, las = 1)

plot(nfi_data[taper_height <= 2.6, density(circumference_m)], xlab = "Circumference", main = "", axes = FALSE, lwd = 3)
axis(1)
axis(2, las = 1)

plot(nfi_data[taper_height <= 2.6, density(height/circumference_m)], xlab = "Slenderness", main = "", axes = FALSE, lwd = 3)
axis(1)
axis(2, las = 1)
```

For most of the trees I find back the volume. I do not really know why some differences still persist, and I do not have much time to investigate. Florence was also unable to reproduce exactly the numbers of IGN, and she told me that it is either a mistake from them, or a lost knowledge of something done but not written.

### Coordinates

Unfortunately, not all the coordinates are available... And when they are, different work must be performed depending on the source:

1.  'protocole Oudin' INRA data: the coordinates are directly available, in the table `codesforets` that I already joined to `inra_arbres`.

2.  French NFI: I included the coordinates in my query.

3.  ONF: I asked directly Christine Deleuze (answer from the 09 January 2025). There is unfortunately no coordinates (at least, none that can be provided to me...).

#### Coordinates 'protocole Oudin' INRA data

```{r}
## Coordinates
coords_inra = inra_arbres[, .(plot_id, lon, lat)]

coords_inra[, lon := as.character(lon)]
coords_inra[, lat := as.character(lat)]

coords_inra[, lon_dec := angle2dec(lon)]
coords_inra[, lat_dec := angle2dec(lat)]

coords_inra = vect(x = coords_inra[, .(plot_id, lon_dec, lat_dec)],
	geom = c("lon_dec", "lat_dec"), crs = "EPSG:4326")
```

#### Coordinates French NFI

```{r}
## Coordinates
coords_nfi = unique(nfi_data[, .(plot_id, x_lambert, y_lambert)])

coords_nfi = vect(x = coords_nfi[, .(plot_id, x_lambert, y_lambert)],
	geom = c("x_lambert", "y_lambert"), crs = "EPSG:27572") # Lambert zone II, I checked it is the used projection
```

### Gather all the datasets into a single one
We now joined all the datasets into a single one. First I harmonise some columns, such as the coordinates that are not in the same projection system. Then only, I do a row bind, with some columns to fill by NAs (such as the branch volume that is not measured by the French NFI).

```{r}
## Add column unique_id to NFI data
nfi_data[, unique_id := paste(plot_id, tree_id, sep = "_")]

## Add Lambert coordinates (EPSG:27572) to INRA data
coords_inra = project(coords_inra, coords_nfi)
inra_arbres[, c("x_lambert", "y_lambert") := crds(x = coords_inra, list = TRUE)]
inra_arbres[, c("lon", "lat") := NULL]
coords_inra = unique(coords_inra) # Now that I put the coords in inra_arbres, I can do a unique

## Merge both INRA and NFI datasets
forest_dt = rbindlist(l = list(inra = inra_arbres, nfi = nfi_data), fill = TRUE, idcol = "origin_data")

## Remove the unknown broadleaves and conifers
forest_dt = forest_dt[speciesName_sci != "Broadleaves sp."]
forest_dt = forest_dt[speciesName_sci != "Conifers sp."]

## Remove null volumes (all from inra actually)
if (forest_dt[, any(bole_volume_m3 <= 0)])
{
	warning(paste(forest_dt[bole_volume_m3 == 0, .N], "null volumes. Removed as juge impossible"))
	if (forest_dt[, any(bole_volume_m3 < 0)])
		warning(paste("There were even", forest_dt[bole_volume_m3 < 0, .N], "negative volumes!"))
	forest_dt = forest_dt[bole_volume_m3 > 0]
}

## Set bole_volume_reconstruct_m3 of inra data to bole_volume_m3. TO DO: RECONSTRUCT THE VOLUMES
forest_dt[origin_data == "inra", bole_volume_reconstruct_m3 := bole_volume_m3] # TO DO: RECONSTRUCT THE VOLUMES

## Compute number of individuals per species
forest_dt[, nb_indiv := .N, by = speciesName_sci]

## Subsample forest_dt for testing
set.seed(1969 - 08 - 18)
n = round(forest_dt[, .N]/10)
selected = sort(sample(x = forest_dt[, .N], size = n, replace = FALSE))

forest_dt_sub = forest_dt[selected]
forest_dt_sub[, nb_indiv := .N, by = speciesName_sci]
forest_dt_sub = forest_dt_sub[nb_indiv > 30]
setkey(forest_dt_sub, fct_type, speciesName_sci, origin_data, unique_id)

## Subsample forest_dt for testing, INRA alone
forest_dt_inra = forest_dt[origin_data == "inra"]
forest_dt_inra[, nb_indiv := .N, by = speciesName_sci]
forest_dt_inra = forest_dt_inra[nb_indiv > 30]
setkey(forest_dt_inra, fct_type, speciesName_sci, origin_data, unique_id)

## Subsample forest_dt for testing, 50-50 Inra/NFI
set.seed(1969 - 08 - 18)
n = forest_dt[origin_data == "inra", .N]
selected = forest_dt[origin_data == "nfi"][sort(sample(x = .N, size = n, replace = FALSE))]

forest_dt_50 = rbind(forest_dt[origin_data == "inra"], selected)
forest_dt_50[, nb_indiv := .N, by = speciesName_sci]
forest_dt_50 = forest_dt_50[nb_indiv > 30]
setkey(forest_dt_50, fct_type, speciesName_sci, origin_data, unique_id)

setkey(forest_dt, fct_type, speciesName_sci, origin_data, unique_id)
```

### Compute the indices for Stan

Stan language uses vectors and arrays (think matrices), but does not know data.frames or data.tables. Therefore, it is necessary to provide an ordered dataset accordingly to the structure of the model. Here, we need to order by functional type and by species within function type. Then, the index table just indicates when each functional type and each species starts and ends in the data. This is not only necessary for Stan, but can also accelerate the computation by vectorising certain calculus. Of course, it is important that the data order is not changed **after** the index table is generated.

```{r}
## Indices
# Find start and end indices for each species
ind_fct = function(dt)
{
	if (!all.equal(key(dt), c("fct_type", "speciesName_sci", "origin_data", "unique_id")))
		stop("DT must have the following keys in the same order: fct_type, speciesName_sci, origin_data, unique_id")

	ind_species_1 = dt[, .(start = .I[1], end = .I[.N], fct_type = unique(fct_type)), by = .(speciesName_sci)]
	ind_species_2 = dt[, .(start_sp_orig = .I[1], end_sp_orig = .I[.N], genus = unique(genus)),
		by = .(speciesName_sci, origin_data)]
	ind_species = merge.data.table(x = ind_species_1, y = ind_species_2, by = "speciesName_sci")
	ind_species[, n_indiv := end - start + 1, by = speciesName_sci]

	if (unique(ind_species[, .(speciesName_sci, n_indiv)])[, sum(n_indiv)] != dt[, .N])
		stop("The number of individuals in ind_species does not correspond to the number of individuals in dt!")

	ind_species[, colour := if(fct_type == "broadleaf") "#FFAF37" else "#007BA5", by = .(speciesName_sci, origin_data)]
	setorder(ind_species, start)

	n_sp = ind_species[, .N, by = .(fct_type, origin_data)]
	setkey(n_sp, fct_type, origin_data)
	return(list(ind_species = ind_species, n_sp = n_sp))
}

ind_species = ind_fct(forest_dt)
ind_species_sub = ind_fct(forest_dt_sub)
ind_species_inra = ind_fct(forest_dt_inra)
ind_species_50 = ind_fct(forest_dt_50)
```

### Format the data for stan

```{r}
## Stan data
makeData = function(dt, ind_ls)
{
	if (!is.list(ind_ls))
		stop("ind_ls should be a list")

	if (!all(names(ind_ls) %in% c("n_sp", "ind_species")))
		stop("ind_ls must contain n_sp and ind_species. Run ind_fct first")

	n_sp = ind_ls[["n_sp"]]
	ind_species = ind_ls[["ind_species"]]

	stanData = list(
		N = dt[, .N],
		N_inra = dt[!is.na(crown_volume_m3), .N],
		S = ind_species[, .N],
		n_sp_broad_tot = n_sp["broadleaf", sum(N)],
		n_sp_conif_tot = n_sp["conifer", sum(N)],
		n_sp_broad_inra = n_sp[CJ("broadleaf", "inra"), N],
		n_sp_conif_inra = n_sp[CJ("conifer", "inra"), N],

		ind_start_broad = ind_species[fct_type == "broadleaf", start],
		ind_start_conif = ind_species[fct_type == "conifer", start],
		ind_end_broad = ind_species[fct_type == "broadleaf", end],
		ind_end_conif = ind_species[fct_type == "conifer", end],

		ind_start_broad_inra = ind_species[(fct_type == "broadleaf") & (origin_data == "inra"), start_sp_orig],
		ind_start_conif_inra = ind_species[(fct_type == "conifer") & (origin_data == "inra"), start_sp_orig],
		ind_end_broad_inra = ind_species[(fct_type == "broadleaf") & (origin_data == "inra"), end_sp_orig],
		ind_end_conif_inra = ind_species[(fct_type == "conifer") & (origin_data == "inra"), end_sp_orig],

		height = dt[, height],
		circumference_m = dt[, circumference_m],

		total_volume_m3 = dt[, total_volume_m3],
		bole_volume_m3 = dt[, bole_volume_reconstruct_m3],
		crown_volume_m3 = dt[, crown_volume_m3]
	)

	return(stanData)
}

stanData = makeData(forest_dt, ind_species)
stanData_sub = makeData(forest_dt_sub, ind_species)
stanData_inra = makeData(forest_dt_inra, ind_species)
stanData_50 = makeData(forest_dt_50, ind_species)
```

### Save the data

The data are now ready and can be saved:
```{r}
## Complete dataset
add_name = "_full"
saveRDS(stanData, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))
if (!dir.exists(paste0(mnt_point, "data/coords_inra", add_name)))
	writeVector(x = coords_inra, filename = paste0(mnt_point, "data/coords_inra", add_name), filetype = "ESRI Shapefile",
		overwrite = TRUE)

if (!dir.exists(paste0(mnt_point, "data/coords_nfi", add_name)))
	writeVector(x = coords_nfi, filename = paste0(mnt_point, "data/coords_nfi", add_name), filetype = "ESRI Shapefile",
		overwrite = TRUE)

## Random sub dataset
add_name = ""
saveRDS(stanData_sub, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt_sub, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species_sub, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))

## Inra dataset
add_name = "_inra"
saveRDS(stanData_inra, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt_inra, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species_inra, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))

## 50-50 dataset
add_name = "_50"
saveRDS(stanData_50, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt_50, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species_50, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))
```

## Data for posterior checks

After running a Bayesian model, it is important to do a 'predict' on new data to check that the model can generate sensible volumes. For this, I use the volume-measured trees dataset from 2009 and 2010, which I format in this section. There are three datasets for each year (here detailed for 2010):

1. `emerge_2010_profils`: tree profiles, containing bole dimensions (circumference every 2 meters)
2. `emerge_2010_branches`: tree branches, containing small and large branches dimensions
3. `emerge_2010_arbres`: tree information, such as dbh, plot, etc... It also contains the total above-ground volume, the total branch volume, and the bole volume. Note that I was able to reconstruct the total branch volume, but that I never succeeded to reconstruct the bole volume.

### Reconstruct bole volumes from profiles and comparison with provided data {#sec-trunkVol}
```{r}
reshape_profiles = function(profile_dt)
{
	if (!is.data.table(profile_dt))
	{
		warning("Changed argument to data table")
		setDT(profile_dt)
	}

	ls_names = c("id", "tree", "longueur_billon_pese_m", "poids_hum_billon_kg",
	"poids_hum_rondelle_partiebef_kg", "poids_hum_rondelle_partieqb_kg", "poids_hum_rondelle_kg",
	"circ_bas_cm", "circ_haut_cm", "niveau_bas_m", "niveau_haut_m", "commentaires",
	"circ_bottom_m", "circ_top_m")

	if (!all(colnames(profile_dt) %in% ls_names))
		stop("Names mismatch between what is provided and what is expected (see the function itself)")

	## Clean the tree dataset and keep only columns of interest (tree is already unique id, no need for site, nor parcelle)
	profile_dt[, c("circ_bottom_m", "circ_top_m") := .(circ_bas_cm/100, circ_haut_cm/100)]
	profile_dt[, c("id", "poids_hum_billon_kg", "poids_hum_rondelle_partiebef_kg", "circ_haut_cm",
		"poids_hum_rondelle_partieqb_kg", "poids_hum_rondelle_kg", "commentaires", "circ_bas_cm")  := NULL]
	setnames(profile_dt, old = c("tree", "longueur_billon_pese_m", "niveau_bas_m", "niveau_haut_m"),
		new = c("tree_id", "length", "h_bottom", "h_top")) 

	setkey(profile_dt, tree_id)
	profile_dt = profile_dt[, setorder(.SD, h_bottom), by = tree_id]

	## Compute length when missing, and volumes using the frustum and cylinder formulae
	profile_dt[is.na(length), length := h_top - h_bottom]

	profile_dt[, vol_log_conic := length/(12*pi)*(circ_bottom_m^2 + circ_top_m^2 + circ_bottom_m*circ_top_m)]
	profile_dt[, cumulated_vol_conic := cumsum(vol_log_conic), by = tree_id]
	profile_dt[, bole_volume_conic_m3 := sum(vol_log_conic), by = tree_id]

	profile_dt[, vol_log_cyl := length/(16*pi)*(circ_bottom_m + circ_top_m)^2]
	profile_dt[, cumulated_vol_cyl := cumsum(vol_log_cyl), by = tree_id]
	profile_dt[, bole_volume_cyl_m3 := sum(vol_log_cyl), by = tree_id]

	## Height
	profile_dt[, height := max(h_top), by = tree_id]

	return (profile_dt)
}

## Change to data table
setDT(emerge_2010_arbres)
setDT(emerge_bure09_arbres)
setDT(emerge_2010_profils)
setDT(emerge_bure09_profils)

emerge_2010_profils = reshape_profiles(emerge_2010_profils)
emerge_bure09_profils = reshape_profiles(emerge_bure09_profils)

## Compare with the volume provided in emerge_2010_arbres
compare = unique(emerge_2010_profils[, .(tree_id, height, bole_volume_cyl_m3, bole_volume_conic_m3)])
compare = merge.data.table(compare, emerge_2010_arbres[, .(tree, circumference_m = c130/100,
	v_tronc_cone_verif, volume_tronc_humide)],
	by.x = "tree_id", by.y = "tree")

compare[, rel_diff := 100*(bole_volume_conic_m3 - v_tronc_cone_verif)/v_tronc_cone_verif]

# plot(density(compare[rel_diff < 50, rel_diff]))

# compare[rel_diff > 50]

# compare[, my_c := 2*sqrt(pi*bole_volume_conic_m3/height)]
# compare[, de_c := 2*sqrt(pi*v_tronc_cone_verif/height)]

# plot(compare[rel_diff > 50, circumference_m], compare[rel_diff > 50, v_tronc_cone_verif],
# 	pch = 20, col = "#FAB255", axes = FALSE, xlab = "Circumference", ylab = "Bole volume",
# 	ylim = c(0, max(compare[rel_diff > 50, .(v_tronc_cone_verif, bole_volume_conic_m3)])))
# points(compare[rel_diff > 50, circumference_m], compare[rel_diff > 50, bole_volume_conic_m3], pch = 20, col = "#CD212A")
# axis(1)
# axis(2, las = 1)

# plot(compare[rel_diff > 50, circumference_m], compare[rel_diff > 50, de_c],
# 	pch = 20, col = "#FAB255", axes = FALSE, xlab = "Circumference", ylab = "Circumference cyl",
# 	ylim = c(0, max(compare[rel_diff > 50, .(de_c, my_c)])))
# points(compare[rel_diff > 50, circumference_m], compare[rel_diff > 50, my_c], pch = 20, col = "#CD212A")
# axis(1)
# axis(2, las = 1)
# abline(a = 0, b = 1)
```

I did several test to check the trunk volumes that I rebuild and those provided in the database. I concluded that they provides sometimes weird values, and that mine are more plausible, especially because they match the column `volume_tronc_humide` when this data is available. Therefore I keep my reconstruction `bole_volume_conic_m3` and do not use their values `v_tronc_cone_verif`.

### Reconstruct branch volume and comparison with provided data {#sec-branchVol}

I now try to reconstruct the volume of large branches. For this, I associate each branch to a cylinder.

```{r}
## Change class to data table, adjust colnames
setDT(emerge_bure09_branches)
setDT(emerge_2010_branches)

setnames(emerge_bure09_branches, old = c("tree", "c", "l", "m_wet"), new = c("tree_id", "c_cm", "l_cm", "m_wet_kg"))
setnames(emerge_2010_branches, old = "tree", new = "tree_id")

reshape_branches = function(branches_dt)
{
	# Remove lines for which I cannot deduce a volume because there is only l_cm or c_cm provided but no m_wet_kg
	branches_dt = branches_dt[!((is.na(l_cm) & is.na(m_wet_kg)) | (is.na(c_cm) & is.na(m_wet_kg)))]

	# Compute branch volumes for branches with both a length and circumference, using a cylinder formula
	branches_dt[!is.na(c_cm) & !is.na(l_cm), vol_branches_m3 := c_cm^2*l_cm/(4*pi*1e6)]

	# Use a density of 1000 kg/m^3 to convert the wet weight into volume when both c_cm, and l_cm are missing
	branches_dt[is.na(l_cm) & is.na(c_cm), vol_branches_m3 := m_wet_kg/1e3]

	# Remove NAs
	branches_dt = branches_dt[!is.na(vol_branches_m3)] # It removes one branch which was broken

	## Compute total branch volume
	branches_dt[, branch_volume := sum(vol_branches_m3), by = tree_id]

	return (branches_dt)
}

## Clean the branch dataset and compute total branch volume per tree
# Remove lines for which I cannot deduce a volume because all information are missing
emerge_bure09_branches = reshape_branches(emerge_bure09_branches)
emerge_2010_branches = reshape_branches(emerge_2010_branches)

compare = unique(emerge_bure09_branches[, .(tree_id, branch_volume)])
compare = merge.data.table(compare, emerge_bure09_arbres[, .(tree, v_br_verif)],
	by.x = "tree_id", by.y = "tree")

compare = unique(emerge_2010_branches[, .(tree_id, branch_volume)])
compare = merge.data.table(compare, emerge_2010_arbres[, .(tree, v_br_verif)],
	by.x = "tree_id", by.y = "tree")
```

My reconstruction matches the provided branch volumes except for `{r} compare[abs(branch_volume - v_br_verif) > 1e-5, .N]` trees. Note that I did like Christine Deleuze and her team: for the incomplete trees I use a density of \qty{1000}{\kilogram\per\cubic\metre} to convert the wet weight into a volume when branch's length or circumference are missing.

### Reconstruct twigs/small branches

Don't bother with that, and read @Santenoise2012. Note that the method described in his document is not up to date (see the following conversation):

> On 25/06/2025 18:40, Philippe Santenoise wrote:
> J'ai travaillé sur la BDD Emerge jusqu'en 2015. Une partie de mon travail consistait à importer de nouvelles données et à mettre à jour les données de la BDD.
> 
> Le travail sur le calcul des volumes par compartiment et la mise à jour de ces données dans la BDD datent de 2011-2012 (rapport en pj). 
> 
> Les données que j'ai envoyé sont utilisées dans le script et sont donc essentielles pour refaire les calculs.

> Après 2015, de nouvelles mises à jour ont peut-être été apportées à la BDD, ce qui pourraient expliquer ces différences dans les calculs de volume.

> Bonne soirée,
> Philippe 
> 
> > On 25/06/2025 17:15, Amaël Le Squin wrote:
> > Parfait, merci!
> > 
> > Si j’ai bien compris, les données envoyées sont proches des données brutes. Je vais y jeter un coup d’oeil ces prochains jours. En appliquant la formule trouvée ligne 533 du script `Calcul_volume_Emerge.r`, je ne retombe pas sûr les valeurs fournies par Christine (même si assez proches). Il y a aussi pas mal de NA dans la table de Christine pour les taux d’humidité ou infra densité. Je pense que vos données ‘brutes’ vont grandement m’aider!
> > 
> > Merci et bonne soirée,
> > Amaël.
> > 
> > > On 25/06/2025 16:44, Philippe Santenoise wrote:
> > >
> > > Bonjour Amael,
> > >
> > > J'ai pu retrouver un ancien script R détaillant le calcul des volumes par compartiment pour les campagnes Emerge 2009 et 2010 + les données utilisées aux différentes étapes de calcul (en pj). 
> > >
> > > Selon l'encodage choisi pour lire le script, il peut y avoir des caractères (en général lettres avec accent) qui sont remplacés par "?". 
> > >
> > > Bonne journée,
> > > Philippe

### Join my reconstructions together

Here, I join both profile and branches tables. As said in the previous section, I do no check the volume for the twigs and I those provided by Emerge.

```{r}
## Join both profile and branches table
build_check_data = function(branches, profiles, trees, species, plots)
{
	if (!all(c("tree_id", "branch_volume") %in% colnames(branches)))
		stop("The branches data table must have tree_id and branch_volume columns")
	
	if (!all(c("tree_id", "bole_volume_conic_m3", "height") %in% colnames(profiles)))
		stop("The profiles data table must have tree_id, bole_volume_conic_m3, and height columns")

	ls_names = c("tree", "id_codesforets", "id_codesessences", "c130", "v_menu_verif", "hauteurdecoupe7_m")
	if (!all(ls_names %in% colnames(trees)))
		stop(paste("The trees data table must have", paste0(ls_names, collapse = " "), "columns"))
	
	if (!all(c("id", "longitude", "latitude") %in% colnames(plots)))
		stop("The plots data table must have id, longitude, and latitude columns")
	
	emerge = merge.data.table(x = unique(branches[, .(tree_id, branch_volume)]),
		y = unique(profiles[, .(tree_id, height, bole_volume_conic_m3)]), all.y = TRUE)

	emerge = merge.data.table(emerge, trees[, .(tree, id_codesforets, id_codesessences,
		taper_height = hauteurdecoupe7_m, circumference_m = c130/100, twig_volume = v_menu_verif)],
		by.x = "tree_id", by.y = "tree")

	emerge = merge.data.table(emerge, species[, .(essence, speciesName_sci, fct_type)],
		by.x = "id_codesessences", by.y = "essence", all.x = TRUE)

	emerge = merge.data.table(emerge, plots[, .(id, longitude, latitude)],
		by.x = "id_codesforets", by.y = "id", all.x = TRUE)

	emerge[, longitude := angle2dec(longitude)]
	emerge[, latitude := angle2dec(latitude)]

	emerge[, c("id_codesessences", "id_codesforets") := NULL]

	# Compute total aerial volume:
	emerge[, total_volume_m3 := bole_volume_conic_m3 + ifelse(is.na(branch_volume), 0, branch_volume) +
		ifelse(is.na(twig_volume), 0, twig_volume)]

	setcolorder(emerge, c("tree_id", "speciesName_sci", "fct_type", "longitude", "latitude",
		"circumference_m", "height", "taper_height"))

	return (emerge)
}

emerge_2009 = build_check_data(emerge_bure09_branches, emerge_bure09_profils, emerge_bure09_arbres,
	codesessences, codesforets)

setnames(emerge_2010_arbres, old = "longueur_d7_m", new = "hauteurdecoupe7_m")
emerge_2010 = build_check_data(emerge_2010_branches, emerge_2010_profils, emerge_2010_arbres,
	codesessences, codesforets)

emerge = rbindlist(list(emerge_2009 = emerge_2009, emerge_2010 = emerge_2010), idcol = "dataset")
setkey(emerge, speciesName_sci)

saveRDS(emerge, paste0(mnt_point, "data/emerge_2009-2010.rds"))
```

### Verification of the check data

This is only to check on a simple plot if the total volume is odd compared to the other Emerge data.

```{r}
emerge[, .N, by = speciesName_sci]

# Plot of bole volume in function of circumference
plot(forest_dt_inra[, circumference_m],
	forest_dt_inra[, bole_volume_reconstruct_m3], pch = 19, cex = 0.5,
	xlab = "Circumference", ylab = "Bole volume",
	ylim = c(0, max(forest_dt_inra[, bole_volume_reconstruct_m3], emerge[, bole_volume_conic_m3])))
points(emerge[, circumference_m], emerge[, bole_volume_conic_m3], pch = 19,
	col = "#CD212A")

# Plot of total volume in function of circumference
plot(forest_dt_inra[, circumference_m],
	forest_dt_inra[, total_volume_m3], pch = 19, cex = 0.5,
	xlab = "Circumference", ylab = "Bole volume",
	ylim = c(0, max(forest_dt_inra[, total_volume_m3], emerge[, total_volume_m3])))
points(emerge[, circumference_m], emerge[, total_volume_m3], pch = 19,
	col = "#CD212A")
```

## Felled trees across Switzwerland 
Data similar to EMERGE has also been collected in Switzerland, spanning from 1888 and 1974 [@Didion2024]. It represents more than \num{40000} felled trees, with diameter measurements every two meters (when possible) up to the taper height of \qty{7}{\centi\metre}. All the trees have a diameter measured at \qty{1}{\metre}, \qty{3}{\metre}, \qty{5}{\metre}, and so on. The original data provided volumes, however the authors of @Didion2024 never succeded to reconstruct them fully (*personal comm.*). Therefore, they decided to let the reconstruction of the volume open. I reconstruct the bole volume using cylinders 

```{r}
#### Reshape data
## Melt
swiss_dt = melt(swiss_dt, measure = patterns("^DM[[:digit:]]"), variable.name = "diameter_height", value.name = "diameter",
	variable.factor = FALSE)

## Define new variables, convert some to m, and rename some columns
swiss_dt[, c("diameter", "dbh_m", "height", "L_coarsestemfinal", "L_top", "D_coarsestemfinal", "D_top") :=
	.(diameter/1e3, DBH/1e3, H_total/10, L_coarsestemfinal/10, L_top/10, D_coarsestemfinal/1e3, D_top/1e3)]

swiss_dt[, c("Elevation", "NFI_PR", "StandAge", "StandComp", "TreeAge", "NFI_mainspecies", "DBH", "H_total") := NULL]

setnames(swiss_dt, old = c("SiteID", "Lat", "Long", "InvYear", "TreeID", "TreeSpecies"),
	new = c("plot_id", "lat", "lon", "year", "tree_id", "sp_code"))

swiss_dt[diameter_height == "DM065", diameter_height_m := 0.65]
swiss_dt[diameter_height != "DM065",
	diameter_height_m := as.numeric(stri_replace(str = diameter_height, regex = "DM", replacement = ""))]

## Get coordinates
coords_swiss = vect(x = unique(swiss_dt[!is.na(lon) | !is.na(lat), .(plot_id, lon, lat)]), crs = "EPSG:4326")
swiss_dt[, c("lon", "lat") := NULL]

## Sort by tree id, and then diameter height (tree_id is already a unique identifier, no need for plot_id)
setkey(swiss_dt, tree_id, diameter_height_m)

## Set D_coarsestemfinal, L_coarsestemfinal, D_top, and L_top to 0 when NA
swiss_dt[is.na(D_coarsestemfinal), D_coarsestemfinal := 0]
swiss_dt[is.na(L_coarsestemfinal), L_coarsestemfinal := 0]
swiss_dt[is.na(D_top), D_top := 0]
swiss_dt[is.na(L_top), L_top := 0]

swiss_dt[is.na(V_coarsebranch), V_coarsebranch := 0]
swiss_dt[is.na(V_finebranch), V_finebranch := 0]
swiss_dt[is.na(V_finewoodytotal), V_finewoodytotal := 0] # Includes the top of the tree, but is NA if V_finebranch = NA!

## Remove useless lines
swiss_dt = swiss_dt[!is.na(diameter)] # Diameters that do not exist or where not given
swiss_dt = swiss_dt[!is.na(sp_code)] # Missing species information

## Compute volumes
# Volume trunk using cylindre formula with median diameter: log 0 to 2 --> DM1, log 2 to 4 --> DM3, etc...
swiss_dt[, vol_log_cyl := pi*diameter^2/4*2] # The *2 comes from the fact that each log is 2m long
swiss_dt[, bole_volume_cyl_m3 := sum(vol_log_cyl) + pi*D_coarsestemfinal^2/4*L_coarsestemfinal, by = tree_id]
swiss_dt[, top_volume_m3 := pi*D_top^2/4*L_top, by = tree_id]

# Volume crown (already provided)
swiss_dt[, V_coarsebranch := V_coarsebranch/1e3] # Conversion to m³
swiss_dt[, V_finebranch := V_finebranch/1e3] # Conversion to m³
swiss_dt[, V_finewoodytotal := V_finewoodytotal/1e3] # Conversion to m³

swiss_dt[, crown_volume_m3 := V_coarsebranch + V_finebranch + top_volume_m3]

# Total volume
swiss_dt[, total_volume_m3 := bole_volume_cyl_m3 + crown_volume_m3]

## Keep only cols and rows of interest
swiss_dt = unique(swiss_dt[, .(plot_id, year, tree_id, sp_code, dbh_m, height, bole_volume_cyl_m3,
	crown_volume_m3, total_volume_m3)])

## Add circumference for ease
swiss_dt[, circumference_m := pi*dbh_m]
```

Add species to the swiss data. Few species names are modified to match the French NFI names. For instance, *Pinus mugo Turra subsp. mugo* becomes *Pinus mugo*, while *Acer campestre, platanoides*, and *pseudoplatanus*, become *Acer sp.*. Note that for the second case, it creates two corresponding match: 'petit érable' (for *A. campestre*) and 'grand érable' (for the two others). There is unfortunately no way to distinguish them. Same for the three *Quercus petraea*, *robur*, and *rubra* that are grouped in the swiss EFM, while in France the group is *Quercus petraea*, *pubescens*, and *robur*.

```{r}
## Add species
# Change colnames and keep columns of interest
swiss_sp[, c("NFI main species", "N") := NULL]
setnames(swiss_sp, old = c("Species ID", "Species name"),
	new = c("sp_code_swiss", "speciesName_sci"))

# Correct/modify few species to match codesessences
swiss_sp[speciesName_sci == "Pinus mugo Turra subsp. mugo", speciesName_sci := "Pinus mugo"]
swiss_sp[speciesName_sci == "Chamaecyparis", speciesName_sci := "Chamaecyparis sp."]
swiss_sp[speciesName_sci == "Picea omorika", speciesName_sci := "Picea sp."] # There are only 14 individuals...
swiss_sp[speciesName_sci == "Larix kaempferi (Lamb.) Carrière", speciesName_sci := "Larix kaempferi"]
swiss_sp[speciesName_sci == "Quercus petraea, Q. robur, Q. rubra", speciesName_sci := "Quercus sp."] # 1821 individuals
swiss_sp[speciesName_sci == "Fraxinus americana, F. excelsior", speciesName_sci := "Fraxinus sp."] # 141 individuals
swiss_sp[speciesName_sci == "Acer campestre, A. platanoides, A. pseudoplatanus", speciesName_sci := "Acer sp."] # 90 indiv
swiss_sp[speciesName_sci == "Juglans regia", speciesName_sci := "Juglans sp."] # 207 individuals
swiss_sp[speciesName_sci == "Other broadleaves, incl. Sorbus spp and Tilia spp",
	speciesName_sci := "Broadleaves sp."] # 9 individuals

codesessences = merge.data.table(x = codesessences, y = swiss_sp, all.x = TRUE, by = "speciesName_sci")

non_unique = codesessences[!is.na(sp_code_swiss)][, .N, by = sp_code_swiss][N > 1][, sort(sp_code_swiss)]

# Drop the nfi codes from codesessences that are not present in forest_dt
nfi_to_check = codesessences[sp_code_swiss %in% non_unique, nfi]
nfi_to_dump = nfi_to_check[!(nfi_to_check %in% forest_dt$species_code_nfi)]
codesessences = codesessences[!(nfi %in% nfi_to_dump)]

# Drop the inra codes from codesessences that are not present in forest_dt
inra_to_check = codesessences[sp_code_swiss %in% non_unique, essence]
inra_to_dump = inra_to_check[!(inra_to_check %in% forest_dt$species_code_inra)]
codesessences = codesessences[!(essence %in% inra_to_dump)]

# Check there is no duplicates left
non_unique = codesessences[!is.na(sp_code_swiss)][, .N, by = sp_code_swiss][N > 1][, sort(sp_code_swiss)]

if (length(non_unique) != 0)
	warning("There are still duplicates, which might create problems")

swiss_dt = merge.data.table(x = swiss_dt,
	y = codesessences[!is.na(sp_code_swiss), .(sp_code_swiss, speciesName_sci, genus = genre, fct_type)],
	by.x = "sp_code", by.y = "sp_code_swiss")
```

```{r}
saveRDS(swiss_dt, paste0(mnt_point, "data/switzerland.rds"))
if (!dir.exists(paste0(mnt_point, "data/coords_switzerland")))
	writeVector(x = coords_swiss, filename = paste0(mnt_point, "data/coords_switzerland"),
		filetype = "ESRI Shapefile", overwrite = TRUE)
```

## Presentation of the data

### Distribution of the data in terms of circumference, height, slenderness, and coordinates

The data are composed by the following species:
```{r}
#| echo: false
#| label: fig-data
#| fig-cap: Number of individuals per genus (French data), with conifers in blue and broadleaves in orange. Watch out, it is a $\\log_{10}$ scale
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
species_nb = unique(ind_species[["ind_species"]][, .(n_indiv = sum(n_indiv), colour), by = genus])[order(n_indiv)]

par(mar = c(5, 12, 2, 2))
# Use barplot f or horizontal bars
barplot(
	species_nb[, n_indiv],
	names.arg = species_nb[, genus],
	horiz = TRUE, # Horizontal bars
	xlab = "Number of individuals",
	ylab = "",
	main = "",
	las = 1,
	log = "x",
	col = species_nb[, colour]
)
```

::: {.callout-note collapse=true}

```{r}
unique(forest_dt[, .N, by = speciesName_sci])[order(speciesName_sci)] |>
	gt() |>
	cols_label(
		speciesName_sci = "Species",
		N = "N. individuals"
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = speciesName_sci)
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(align = "left")),
		locations = cells_body(columns = N)
	)
```

:::

and the plots are located:

```{r}
#| echo: false
#| label: fig-map
#| fig-cap: "Location of the plots, with NFI for the Naional Forest Invetory of France, and EFM the Experimental Forest Monitoring of Switzerland [@Didion2024]"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

#### Coordinates
## Read shapefiles
switzerland = project(vect(paste0(mnt_point, "data/shapefiles/switzerland/CHE_adm0.shp")), coords_inra)
france = project(vect(paste0(mnt_point, "data/shapefiles/france/FRA_adm0.shp")), coords_inra)
belgium = project(vect(paste0(mnt_point, "data/shapefiles/belgium/gadm41_BEL_0.shp")), coords_inra)
italy = project(vect(paste0(mnt_point, "data/shapefiles/italy/gadm41_ITA_0.shp")), coords_inra)
luxembourg = project(vect(paste0(mnt_point, "data/shapefiles/luxembourg/gadm41_LUX_0.shp")), coords_inra)
germany = project(vect(paste0(mnt_point, "data/shapefiles/germany/gadm41_DEU_0.shp")), coords_inra)

fr_ch = project(rbind(france, switzerland), coords_inra)

## Projections
colours = met.brewer(name = "Lakota", n = 3)
names(colours) = c("nfi", "swiss", "inra")

## Plot
plot(fr_ch, lwd = 2, axes = FALSE)
points(coords_nfi, col = colours["nfi"], pch = 20, cex = 0.35)
points(coords_inra, col = colours["inra"], pch = 20, cex = 1.15)
points(project(coords_swiss, coords_inra), col = colours["swiss"], pch = 20, cex = 0.55)
plot(fr_ch, lwd = 2, add = TRUE, bg = "transparent")
plot(luxembourg, lwd = 2, add = TRUE)
plot(germany, lwd = 2, add = TRUE)
plot(belgium, lwd = 2, add = TRUE)
plot(italy, lwd = 2, add = TRUE)

legend(x = "bottomleft", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n", inset = c(0, 0.1))
```

It is now time to explore how the data are distributed, if they cover the same range of tree diameters, heights, and volumes.

```{r}
#| echo: false
#| label: fig-distrib
#| fig-cap: Distribution of the data
#| fig-subcap: 
#|   - "Densities of circumferences"
#|   - "Densities of heights"
#|   - "Densities of slenderness (height/circumference)"
#| layout-nrow: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

# --- Circumferences
dd_fr = density(forest_dt[origin_data == "nfi", circumference_m]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", circumference_m]) # Inra/Emerge data
dd_ch = density(swiss_dt[, circumference_m]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Circumference (m)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")

# --- Heights
dd_fr = density(forest_dt[origin_data == "nfi", height]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", height]) # Inra/Emerge data
dd_ch = density(swiss_dt[, height]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Height (m)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")

# --- Slenderness
dd_fr = density(forest_dt[origin_data == "nfi", height/circumference_m]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", height/circumference_m]) # Inra/Emerge data
dd_ch = density(swiss_dt[, height/circumference_m]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Slenderness (height/circumference)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")
```

### Response plots, bole
```{r}
#| echo: false

#### Binding both forest_dt and swiss_dt
## Temporary data
temp = rbind(forest_dt[, .(plot_id, tree_id, genus, circumference_m,
		bole_volume_m3 = bole_volume_reconstruct_m3, crown_volume_m3, origin_data)],
	swiss_dt[, .(plot_id, tree_id, genus, circumference_m,
		bole_volume_m3 = bole_volume_cyl_m3, crown_volume_m3)], fill = TRUE)

## Origin data and colours
temp[is.na(origin_data), origin_data := "swiss"]
temp[, colour := colours[origin_data], by = origin_data]

# ## Check composition data (complete)
# n = temp[, .N]
# # temp[, round(.N/n*100, 2), by = origin_data]

# ## Subset data
# set.seed(1969 - 08 - 18) # Woodstock seed
# n_sample = 1e5
# temp = temp[sort(sample(x = 1:.N, size = n_sample, replace = FALSE))]

# ## Check composition data (sampled)
# n = temp[, .N]
# # temp[, round(.N/n*100, 2), by = origin_data]

# ## Remove 'lonely' genus, i.e., less than 1e3 individuals
# temp[, n_indiv := .N, by = genus]
# temp = temp[n_indiv > 1000]

## Remove genus that 
select_genus = temp[, .N, by = .(genus, origin_data)][, .N, by = genus][N > 1, genus]

## List genus and set keys
temp = temp[genus %in% select_genus]

setkey(temp, genus, origin_data)
ls_genus = unique(temp[, genus]) # Insured that it is sorter by alphabetical order
```

::: {.callout-note collapse=true}

```{r}
temp[, .N, by = .(genus, origin_data)] |>
	gt() |>
	tab_options(
		quarto.disable_processing = TRUE,
		ihtml.use_highlight = TRUE
	) |>
	cols_label(
		genus = "Genus",
		origin_data = "Dataset",
		N = "N. individual"
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = genus)
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(align = "left")),
		locations = cells_body(columns = c(N, origin_data))
	)
```

:::

```{r}
#| echo: false
#| label: fig-responses
#| fig-cap: Response of volume to circumference for the 17 genus that are present in at least two datasets
#| fig-subcap:
#|   - "Abies"
#|   - "Acer"
#|   - "Betula"     
#|   - "Carpinus"
#|   - "Castanea"
#|   - "Cedrus"     
#|   - "Fagus"
#|   - "Fraxinus"
#|   - "Juglans"    
#|   - "Larix"
#|   - "Picea"
#|   - "Pinus"      
#|   - "Populus"
#|   - "Prunus"
#|   - "Pseudotsuga"
#|   - "Quercus"
#|   - "Ulmus" 
#| layout-nrow: 6
#| layout-col: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

for (current_gen in ls_genus)
{
	pres_inra = FALSE
	pres_swiss = FALSE

	plot(temp[.(current_gen, "nfi"), circumference_m], temp[.(current_gen, "nfi"), bole_volume_m3], cex = 0.45,
		xlab = "Circumference (m)", ylab = "Bole volume (m³)", main = "", axes = FALSE, pch = 19, lwd = 0,
		col = colours["nfi"], xlim = c(0, max(temp[.(current_gen), circumference_m])))
	
	if (temp[.(current_gen, "inra"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "inra"), circumference_m], temp[.(current_gen, "inra"), bole_volume_m3],
			cex = 0.55, col = colours["inra"], pch = 19, lwd = 0)
		pres_inra = TRUE
	}
		
	if (temp[.(current_gen, "swiss"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "swiss"), circumference_m], temp[.(current_gen, "swiss"), bole_volume_m3],
			cex = 0.55, col = paste0(colours["swiss"], ifelse(pres_inra, "66", "FF")), pch = 19, lwd = 0)
		pres_swiss = TRUE
	}

	axis(1)
	axis(2, las = 1)

	if (pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")
	if (pres_inra && !pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI"), fill = colours[c("inra", "nfi")], bty = "n")
	if (!pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("NFI", "EFM"), fill = colours[c("nfi", "swiss")], bty = "n")
}
```

### Response plots, crown
```{r}
# --- Circumferences
dd_in = density(forest_dt[origin_data == "inra", crown_volume_m3], n = 512, from = 0, to = 0.3) # Inra/Emerge data
dd_ch = density(swiss_dt[, crown_volume_m3], n = 512, from = 0, to = 0.3) # swiss data

range(dd_in$x)
range(dd_ch$x)

range(dd_in$y)
range(dd_ch$y)

plot(dd_in, col = colours["inra"], axes = FALSE, lwd = 3, xlab = "Crown volume (m)", main = "")
polygon(c(dd_in$x, rev(dd_in$x)), c(rep(0, length(dd_in$x)), rev(dd_in$y)), col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(c(dd_ch$x, rev(dd_ch$x)), c(rep(0, length(dd_ch$x)), rev(dd_ch$y)), col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "EFM"), fill = colours[c("inra", "swiss")], bty = "n")
```

### Relation between crown and (merchantable) bole volume
```{r}

ch_inra = temp[CJ(unique(genus), c("inra", "swiss")), nomatch = 0]

plot(ch_inra[, bole_volume_m3], ch_inra[, crown_volume_m3], col = ch_inra[, colour], pch = 19, lwd = 0, axes = FALSE,
	xlab = "Bole volume", ylab = "Crown volume")
axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "EFM"), fill = colours[c("inra", "swiss")], bty = "n")

cor(ch_inra[.(unique(genus), "inra"), bole_volume_m3, nomatch = 0],
	ch_inra[.(unique(genus), "inra"), crown_volume_m3, nomatch = 0])

cor(ch_inra[.(unique(genus), "swiss"), bole_volume_m3, nomatch = 0],
	ch_inra[.(unique(genus), "swiss"), crown_volume_m3, nomatch = 0])
```
