---
title: "Preparing the data for estimating volumes"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
bibliography: references.bib
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    keep-tex: true
    pdf-engine: lualatex
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

\newcommand{\ie}{*i.e.,*}
\newcommand{\F}{\mathscr{F}}
\newcommand{\N}{\mathbfscr{N}}

## Introduction

The data were provided by Christine Deleuze by e-mail the 17 September 2024. The format is a single `.RData` file, which is stored remotely on the server 'Abies' (`smb://del1509n015/`) in the protected folder (only reading rights) `2024_faircarbon/data_orig/`. The person to contact to add data to this folder is Thierry Leclaire.

For Linux, and maybe MacOS, it is necessary to mount locally the remote folder in order to access the data from R. According to Henri Cunny, it is not necessary for Windows (at least for remote folders on Abies, maybe because smb is a Windows protocol).

### Mount the remote folder

1.  Switch to super user where you replace `JohnField-Admin` (really nice [Irish composer](https://www.youtube.com/watch?v=Uktj2MYSsaU)) by your admin name (typically, your IGN id followed by `-Admin`):

```{sh}
#| eval: false
#| code-fold: false
su JohnField-Admin
```

Your **admin** password will be asked

2.  Create a directory where you will mount the remote folder. By default I like to put it in `/mnt/local_share`. You need to be super user to write in `/mnt/`:

```{sh}
#| eval: false
#| code-fold: false
sudo mkdir /mnt/local_share
```

This step should be done only once.

3.  Mount the remote folder `smb://del1509n015/2024_faircarbon/`, where you replace `your_name` by your **usual** IGN id (NOT the admin one):

```{sh}
#| eval: false
#| code-fold: false
sudo mount -t cifs -o username=your_name,domain=ign,uid=your_name //del1509n015/2024_faircarbon /mnt/local_share/
```

Maybe two passwords will be asked, first your **admin** password to execute the `sudo`, and then your **usual** password. If you just did step 2, then the prompt will not ask again for your **admin** password again.

4.  Check that it worked, especially the reading and writting rigths:

```{sh}
#| eval: false
#| code-fold: false
ls -l /mnt/local_share/
```

The content of the remote folder should appear. You can close your admin session by using `ctrl + d` or `Cmd + d`

Now that the raw data are accessible to {{< fa brands r-project >}}, it is time to prepare them!

## Prepare the data

### Loading the data

The following packages are required to load and handle the data and print summary tables:
```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(inventR)
library(stringi)
library(terra)
library(gt)
```

And one helper function to convert degree coordinates to decimals (for the INRA data):
```{r}
angle2dec = function(angle)
{
	x = stri_match(angle, regex = "([+-]?\\d+)°(\\d+)'(\\d+)") # To split the degree from minute and second
	x = apply(x[, 2:4], 1L, function(y) {
		y = as.numeric(y)
		y[1] + y[2]/60 + y[3]/3600
	})
	return(x)
}
```

Read the data from (mounted) remote folder:
```{r}
#### Prepare data
## Loading
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data_orig/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Are you sure you mounted the good remote folder?"))

if (list.files(path = path_data) != "EMERGE.RData")
	stop("There should be only the file <EMERGE.RData> in the data_orig folder")

load(paste0(path_data, "EMERGE.RData"))
```

There are data from different institutes and different periods of time:

1.  'Protocole Oudin', dataset preserved by INRA ( on the @fig-map)

2.  The French NFI ( on the @fig-map). I do not trust this dataset: I do not know where it comes from, nor who provided it, but there are about 50% of the plot id (labelled `CPP` in the table) that cannot be found when I or Cedric Duprez do our own request. Therefore, I decided to do my own request of the data, which is also better for reproducibility. Details are explained in @sec-nfi_query

3.  The 'Office National des Forêts (ONF)', with protocols from 1972 and from 1983. I do not use these data as there is no coordinates

4.  Institut Technologique Forêt, Cellulose, Bois-construction, Ameublement (FCBA), which I do not use so far

5.  L'Institut pour le développement forestier (IDF) which is the R&D of the Centre National de la Propriété Forestière and the Institut national de recherche en sciences et technologies pour l'environnement et l'agriculture (IRSTEA, currently INRAE)

### Variable names

The variable names are not necessarily unified (but the species names are, I checked! So I can safely use the data.table `codesessences`). I gather in @tbl-notations the data-specific variable names and the common english name I use hereafter.

| INRA            | NFI  | Common                       | Description                                      |
|----------------:|-----:|:-----------------------------|:-------------------------------------------------|
| id              | npp  | plot_id                      | Plot id                                          |
| nom_fichier     | \-   | unique_id                    | Unique id                                        |
| essence         | ess  | speciesName_sci              | Species name                                     |
| c130            | c13  | circumference_m              | Circumference at 1.3 m                           |
| h_tot           | htot | height                       | Height in m                                      |
| total_volume_m3 | \-   | total_volume_m3              | Total above-ground volume                        |
| v_tronc         | v    | merchantable_trunk_volume_m3 | Volume main trunk up to 7 cm (merchantable vol.) |
| v_courrone      | \-   | crown_volume_m3              | Total volume minus merchantable trunk            |
| genre           | \-   | genus                        | Genus                                            |
| longitude       | xl   | \-                           | Coordinates in different proj                    |
| latitude        | yl   | \-                           | Coordinates in different proj                    |

: Variable names {#tbl-notations .borderless .hover}

### Clean the datasets and compute new variables

Keep only the columns of interest, change column names, transform everything to `data.table` for INRA data and for helper data tables (`codesforets`, which contains coordinates, and `codesessences`, which contains species codes):
```{r}
setDT(inra_arbres)
setDT(codesforets)
setDT(codesessences)

## Compute (total) volume in m³, and format data
inra_arbres[, total_volume_m3 := (v_tronc_verif + v_fourche_verif + v_fourche2_verif + v_br_verif + v_menu_verif)/1e3]
inra_arbres[, v_tronc_verif := v_tronc_verif/1e3] # Conversion to m3
inra_arbres[, v_courrone := total_volume_m3 - v_tronc_verif] # Volume of the crown, i.e., everything that is NOT trunk > 7 cm
inra_arbres[, circumference_m := c130/100]

inra_arbres[, year := format(as.Date(date, "%Y-%m-%d"), "%Y")]

## Keep only column of interest and rename them
inra_arbres = unique(inra_arbres[, .(nom_fichier, essence, circumference_m, h_tot, total_volume_m3, v_tronc_verif,
	v_courrone, genre, id_codesforets, year)])
inra_arbres = merge.data.table(inra_arbres, codesforets[, .(id, longitude, latitude)],
	by.x = "id_codesforets", by.y = "id")

inra_arbres = na.omit(inra_arbres)

setnames(inra_arbres, new = c("plot_id", "unique_id", "speciesName_sci", "circumference_m", "height", "total_volume_m3",
	"merchantable_trunk_volume_m3", "crown_volume_m3", "genus", "year", "lon", "lat"))

## Change type of cols
inra_arbres[, unique_id := as.character(unique_id)]
inra_arbres[, speciesName_sci := as.character(speciesName_sci)]
inra_arbres[, genus := as.character(genus)]

## Set functional type, either broadleaf or conifer
inra_arbres[, fct_type := "broadleaf"]
inra_arbres[genus %in% c("Abies", "Cedrus", "Larix", "Picea", "Pinus", "Pseudotsuga", "Thuya", "Tsuga"),
	fct_type := "conifer"]

## Number of individuals per species
inra_arbres[, nb_indiv := .N, by = speciesName_sci]
# inra_arbres = inra_arbres[nb_indiv > 20]
```

### Request of the French NFI data (using inventR package) {#sec-nfi_query}

As said above, I do not trust the data.frame `ifn_arbres`. I do my own request here, to get tree volumes and the plot coordinates. Note that I filtered trees measured before 1988 because diameters were collected instead of circumferences. This is known to be less precise (as the trunk is more likely to be an ovoid) and so it is better to start from 1988, where the circumferences are measured (Florence Gohon, *pers. comm.*).

```{r}
## French NFI data query
db = connect_db()

nfi_data = exec_req(conn = db, req = "
	SELECT
		tree.NPP, tree.A, tree.ESS, tree.C13, tree.HTOT, tree.R, tree.V, tree.VTOT,
		coords1.XL, coords1.YL,
		EXTRACT(YEAR FROM coords2.DATEPOINT) AS year
	FROM
		inv_exp_am.g3arbre AS tree
		
		LEFT JOIN inv_exp_am.e1point AS coords1
		ON coords1.npp = tree.npp
		
		LEFT JOIN inv_exp_am.e2point AS coords2
		ON coords2.npp = tree.npp
	WHERE
		tree.cube = 'M' AND coords2.DATEPOINT >= '1988-01-01'::date
	ORDER BY
		npp, a;", DT = TRUE)

disconnect_db(db)

nfi_data = na.omit(nfi_data)

## Add scientific species names
codesessences = codesessences[essence_ifn < 100]
codesessences[, nfi := as.character(essence_ifn)]
codesessences[, genre := as.character(genre)]
codesessences[, espece := as.character(espece)]
codesessences[essence_ifn < 10, nfi := paste0("0", nfi)]
codesessences[, speciesName_sci := paste(genre, espece)]

nfi_data = merge.data.table(nfi_data, codesessences[, .(nfi, genre, speciesName_sci)], by.x = "ess", by.y = "nfi")

nfi_data[, ess := NULL]

## Strangely, v and vtot are the same... I keep v then
if (isTRUE(nfi_data[, all.equal(v, vtot, tol = 1e-5)]))
{
	print("It seems that v and vtot are the same, which is strange as I was expecting vtot = (1 - r)*v")
	nfi_data[, vtot := NULL]
	nfi_data[, r := NULL]
} else {
	stop("When I downloaded the data, v and vtot were the same. It seems it is not anymore! Check what could have happened")
}

## Change column names
setnames(nfi_data, new = c("plot_id", "tree_id", "circumference_m", "height", "merchantable_trunk_volume_m3",
	"x_lambert", "y_lambert", "year", "genus", "speciesName_sci"))

nfi_data[, nb_indiv := .N, by = speciesName_sci]

## Set functional type, either broadleaf or conifer
nfi_data[, fct_type := "broadleaf"]
nfi_data[genus %in% c("Abies", "Cedrus", "Cupressus", "inconnu (résineux)", "Juniperus", "Larix", "Picea",
	"Pinus", "Pseudotsuga", "Taxus", "Thuya", "Tsuga"), fct_type := "conifer"]
```

### Coordinates

Unfortunately, not all the coordinates are available... And when they are, different work must be performed depending on the source:

1.  'protocole Oudin' INRA data: the coordinates are directly available, in the table `codesforets` that I already joined to `inra_arbres`.

2.  French NFI: I included the coordinates in my query.

3.  ONF: I asked directly Christine Deleuze (answer from the 09 January 2025). There is unfortunately no coordinates (at least, none that can be provided to me...).

#### Coordinates 'protocole Oudin' INRA data

```{r}
## Coordinates
coords_inra = inra_arbres[, .(plot_id, lon, lat)]

coords_inra[, lon := as.character(lon)]
coords_inra[, lat := as.character(lat)]

coords_inra[, lon_dec := angle2dec(lon)]
coords_inra[, lat_dec := angle2dec(lat)]

coords_inra = vect(x = coords_inra[, .(plot_id, lon_dec, lat_dec)],
	geom = c("lon_dec", "lat_dec"), crs = "EPSG:4326")
```

#### Coordinates French NFI

```{r}
## Coordinates
coords_nfi = unique(nfi_data[, .(plot_id, x_lambert, y_lambert)])

coords_nfi = vect(x = coords_nfi[, .(plot_id, x_lambert, y_lambert)],
	geom = c("x_lambert", "y_lambert"), crs = "EPSG:27572") # Lambert zone II, I checked it is the used projection
```

### Gather all the datasets into a single one
We now joined all the datasets into a single one. First I harmonise some columns, such as the coordinates that are not in the same projection system. Then only, I do a row bind, with some columns to fill by NAs (such as the branch volume that is not measured by the French NFI).

```{r}
## Add column unique_id to NFI data
nfi_data[, unique_id := paste(plot_id, tree_id, sep = "_")]

## Add Lambert coordinates (EPSG:27572) to INRA data
coords_inra = project(coords_inra, coords_nfi)
inra_arbres[, c("x_lambert", "y_lambert") := crds(x = coords_inra, list = TRUE)]
inra_arbres[, c("lon", "lat") := NULL]
coords_inra = unique(coords_inra) # Now that I put the coords in inra_arbres, I can do a unique

## Merge both INRA and NFI datasets
forest_dt = rbindlist(l = list(inra = inra_arbres, nfi = nfi_data), fill = TRUE, idcol = "origin_data")

## Remove the unknown broadleaf and conifer
forest_dt = forest_dt[!stri_detect(speciesName_sci, regex = "inconnu")]
```

### Compute the indices for Stan

Stan language uses vectors and arrays (think matrices), but does not know data.frames or data.tables. Therefore, it is necessary to provide an ordered dataset accordingly to the structure of the model. Here, we need to order by functional type and by species within function type. Then, the index table just indicates when each functional type and each species starts and ends in the data. This is not only necessary for Stan, but can also accelerate the computation by vectorising certain calculus. Of course, it is important that the data order is not changed **after** the index table is generated.

```{r}
## Indices
# Find start and end indices for each species
setkey(forest_dt, fct_type, speciesName_sci, origin_data, unique_id)
ind_species_1 = forest_dt[, .(start = .I[1], end = .I[.N]), by = .(speciesName_sci, fct_type)]
ind_species_2 = forest_dt[, .(start_sp_orig = .I[1], end_sp_orig = .I[.N]), by = .(speciesName_sci, origin_data)]
ind_species = merge.data.table(x = ind_species_1, y = ind_species_2, by = "speciesName_sci")
ind_species[, n_indiv := end - start + 1, by = speciesName_sci]

if (unique(ind_species[, .(speciesName_sci, n_indiv)])[, sum(n_indiv)] != forest_dt[, .N])
	stop("The number of individuals in ind_species does not correspond to the number of individuals in forest_dt!")

ind_species[, colour := if(fct_type == "broadleaf") "#FFAF37" else "#007BA5", by = .(speciesName_sci, origin_data)]
setorder(ind_species, start)

n_sp = ind_species[, .N, by = fct_type]
setkey(n_sp, fct_type)
```

### Format the data for stan

```{r}
## Stan data
stanData = list(
	N = forest_dt[, .N],
	S = ind_species[, .N],
	n_sp_conif = n_sp["conifer", N],
	n_sp_broad = n_sp["broadleaf", N],
	ind_start_broad = ind_species[fct_type == "broadleaf", start],
	ind_start_conif = ind_species[fct_type == "conifer", start],
	ind_end_broad = ind_species[fct_type == "broadleaf", end],
	ind_end_conif = ind_species[fct_type == "conifer", end],
	ind_start_broad_inra = ind_species[(fct_type == "broadleaf") & (origin_data == "inra"), start_sp_orig],
	ind_start_conif_inra = ind_species[(fct_type == "conifer") & (origin_data == "inra"), start_sp_orig],
	ind_end_broad_inra = ind_species[(fct_type == "broadleaf") & (origin_data == "inra"), end_sp_orig],
	ind_end_conif_inra = ind_species[(fct_type == "conifer") & (origin_data == "inra"), end_sp_orig],
	height = forest_dt[, height],
	circumference_m = forest_dt[, circumference_m],
	total_volume_m3 = forest_dt[, total_volume_m3],
	merchantable_trunk_volume_m3 = forest_dt[, merchantable_trunk_volume_m3],
	crown_volume_m3 = forest_dt[, crown_volume_m3]
)
```

### Save the data

The data are now ready and can be saved:
```{r}
saveRDS(stanData, paste0(mnt_point, "data/stanData_nfi-inra.rds"))
saveRDS(ind_species, paste0(mnt_point, "data/ind_species_nfi-inra.rds"))
writeVector(x = coords_inra, filename = paste0(mnt_point, "data/coords_inra"), filetype = "ESRI Shapefile")
writeVector(x = coords_nfi, filename = paste0(mnt_point, "data/coords_nfi"), filetype = "ESRI Shapefile")
```

## Presentation of the data

The data are composed by the following species:

```{r}
#| echo: false
#| label: fig-data
#| fig-cap: "Number of individuals per species, with conifers in blue and broadleaves in orange. Watch out, it is a $\\log_{10}$ scale"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
species_nb = ind_species[, .(speciesName_sci, n_indiv, colour)]
setorder(species_nb, n_indiv)

par(mar = c(5, 12, 2, 2))
# Use barplot f or horizontal bars
barplot(
	species_nb[, n_indiv],
	names.arg = species_nb[, speciesName_sci],
	horiz = TRUE, # Horizontal bars
	xlab = "Number of individuals",
	ylab = "",
	main = "",
	las = 1,
	log = "x",
	col = species_nb[, colour]
)
abline(v = 30, lwd = 2, lty = "dashed", col = "#CD212A")
```

and the plots are located:

```{r}
#| echo: false
#| label: fig-map
#| fig-cap: "Location of the plots"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

#### Coordinates
## Projections
coords_inra = project(coords_inra, coords_nfi)
colours_vec = met.brewer(name = "Egypt", n = 2)

## Plot
plot(project(vect(inventR::france), coords_inra), lwd = 2, axes = FALSE)
points(coords_nfi, col = colours_vec[2], pch = 20, cex = 0.55)
points(coords_inra, col = colours_vec[1], pch = 20, cex = 1.15)
```

## Data for posterior checks

After running a Bayesian model, it is important to do a 'predict' on new data to check that the model can generate sensible volume. For this, I use the volume-measured trees dataset from 2010, which I format in the following code snippet.

```{r}
## Add species to the profiles

load(paste0(path_data, "EMERGE.RData"))

setDT(emerge_2010_profils)
setDT(emerge_2010_arbres)
setDT(emerge_2010_branches)

# emerge_2010_arbres = unique(emerge_2010_arbres[, .(tree, species, c130)])
# emerge_2010_profils = emerge_2010_arbres[emerge_2010_profils, on = "tree"]

# ## Compute dbh top/bottom of each log
# emerge_2010_profils[, dbh_bottom_m := circ_bas_cm/(100*pi)]
# emerge_2010_profils[, dbh_top_m := circ_haut_cm/(100*pi)]

# ## Reorganising
# emerge_2010_profils[, species := as.character(species)]
# setorder(emerge_2010_profils, tree, niveau_bas_m)
# emerge_2010_profils[, id := NULL]
# emerge_2010_profils[, c130 := c130/100]
# setnames(x = emerge_2010_profils, old = c("niveau_bas_m", "niveau_haut_m", "c130"), c("h_bottom", "h_top", "circumference_m"))
# emerge_2010_profils = emerge_2010_profils[, .(tree, species, dbh_bottom_m, dbh_top_m, h_bottom, h_top, circumference_m)]

# ## Compute log and cumulated volumes
# emerge_2010_profils[, height := max(h_top), by = tree]
# emerge_2010_profils[, merchantable_trunk_volume_m3 := pi/12*max(dbh_bottom_m)^2*height, by = tree]
# emerge_2010_profils[, vol_log := pi/12*dbh_bottom_m^2*(height - h_bottom) - pi/12*dbh_top_m^2*(height - h_top)]

# emerge_2010_profils[, cumulated_vol := cumsum(vol_log), by = tree]
# emerge_2010_profils[, cumulated_percent_vol := cumulated_vol/merchantable_trunk_volume_m3, by = tree]

# ## Keep only variables of interest
# data_check = unique(emerge_2010_profils[, .(tree, species, merchantable_trunk_volume_m3, height, circumference_m)])

# ## Change vernacular species names to scientific
# species_dt = data.table(species = c("Frêne", "Chêne vert", "Tilia cordata", "Chêne sessile", "Eucalyptus",
# 		"Robinier", "Pin Alep", "Chêne pubescent", "Aulne", "Bouleau"),
# 	speciesName_sci = c("Fraxinus excelsior", "Quercus ilex", "Tilia cordata", "Quercus petraea", "Eucalyptus spp.",
# 		"Robinia pseudoacacia", "Pinus halepensis", "Quercus pubescens", "Alnus glutinosa", "Betula pendula"),
# 	fct_type = c(rep("broadleaf", 6), "conifer", rep("broadleaf", 3)))

# data_check = merge.data.table(data_check, species_dt, by = "species")
# data_check[, species := NULL]
# data_check[speciesName_sci == "Quercus petraea", speciesName_sci := "Quercus robur_petraea"] # Because of inra_arbres
# setkey(data_check, speciesName_sci)

# data_check = data_check[speciesName_sci %in% species_nb[, speciesName_sci]]

# data_check[, hdn := sqrt(circumference_m)/height]
# data_check[, slenderness := height/circumference_m]
# data_check[, corrected_cyl_vol := height*circumference_m^2/(4*pi*(1 - 1.3/height)^2)]

# data_check[, feuil.res := as.factor(fct_type)]
```
