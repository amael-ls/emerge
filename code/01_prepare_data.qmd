---
title: "Preparing the data for estimating volumes"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
bibliography: references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    keep-tex: true
    pdf-engine: lualatex
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

\newcommand{\ie}{*i.e.,*}
\newcommand{\F}{\mathscr{F}}
\newcommand{\N}{\mathbfscr{N}}

## Introduction

The data were provided by Christine Deleuze by e-mail the 17 September 2024. The format is a single `.RData` file, which is stored remotely on the server 'Abies' (`smb://del1509n015/`) in the protected folder (only reading rights) `2024_faircarbon/data_orig/`. The person to contact to add data to this folder is Thierry Leclaire.

For Linux, and maybe MacOS, it is necessary to mount locally the remote folder in order to access the data from R. According to Henri Cunny, it is not necessary for Windows (at least for remote folders on Abies, maybe because smb is a Windows protocol). All of this is explained in the @sec-mount_folder.

In order to understand the data, I first define what is a tree in @sec-what_a_tree. There are also some test to reconstruct the data from raw data to show explicitly how volumes where calculated (see @sec-nfi_query, @sec-trunkVol, and @sec-branchVol)

### Define what is a tree {#sec-what_a_tree}

Trees are partitioned into hierarchical elements in Forest Inventories (\eg @fig-partition). Definitions of elements can vary between inventories, and they do not necessarily contains the same data. In our case, the tree data come from different institutes and different periods of time:

1.  'Protocole Oudin', dataset preserved by INRA, between 1930 and 1980 (<span class="egypt_red"></span> on the @fig-map)

2.  The French NFI (<span class="egypt_blue"></span> on the @fig-map). I do not trust the dataset provided by C. Deleuze: I do not know where it comes from, nor who provided it, but there are about 50% of the plot id (labelled `CPP` in the table) that cannot be found when I or Cedric Duprez do our own request. They are also subtleties with diameters and circumferences... Therefore, I decided to do my own request of the data, which is also better for reproducibility. Details are explained in @sec-nfi_query. Data range from 1988 to 2007.

3.  The 'Office National des Forêts (ONF)', with protocols from 1972 and from 1983. I do not use these data as there is no coordinates

4.  Institut Technologique Forêt, Cellulose, Bois-construction, Ameublement (FCBA), which I do not use so far

5.  L'Institut pour le développement forestier (IDF) which is the R&D of the Centre National de la Propriété Forestière and the Institut national de recherche en sciences et technologies pour l'environnement et l'agriculture (IRSTEA, currently INRAE)

```{mermaid}
%%| label: fig-partition
%%| fig-cap: Partition of a tree (inspired by @Gschwantner2009)
%%{init: {"flowchart": {"defaultRenderer": "elk"}} }%%
flowchart LR
subgraph SUB0 [Level 0]
	W(Whole tree)
end

subgraph SUB1 [Level 1]
	W --> A(Above-ground)
	W --> B(Below-ground)
end

subgraph SUB2 [Level 2]
	A --> M(Main stem)
	A --> L(Lateral)
	A --> F(Foliage)

	B --> E(...)
end

subgraph SUB3 [Level 3]
	M --> S(Stem top)
	M --> MB(Bole)
	M --> MS(Stump)
	L --> LB(Large branches)
	L --> SB(Small branches)
end
```

We decided to use the definitions from @Gschwantner2009 (see @fig-partition and @fig-treeDef):

- Main stem: The stem of a tree is the above-ground part of the main (off) shoot with apical dominance
	- Stem top: topmost part of the stem from an over-bark base-diameter of \qty{7}{\centi\metre} (French NFI) to the stem tip
	- Bole: above-ground part of the stem between stump and the stem top
	- Stump: above-ground base part of the stem which would remain after a tree was cut under normal felling practices
- Lateral parts:
	- Large branches: portion of the above-ground lateral parts with a diameter of more than or equal to \qty{7}{\centi\metre} (French NFI)
	- Large branches: portion of the above-ground lateral parts with a diameter of less than \qty{7}{\centi\metre} (French NFI)

![Tree partition, with Bole (<span class="egypt_green"></span>), stem top (<span class="egypt_yellow"></span>), large branches (<span class="egypt_blue"></span>), and small branches (<span class="egypt_red"></span>)](img/tree_ign.png){#fig-treeDef}

### Mount the remote folder {#sec-mount_folder}

1.  Switch to super user where you replace `JohnField-Admin` (really nice [Irish composer](https://www.youtube.com/watch?v=Uktj2MYSsaU)) by your admin name (typically, your IGN id followed by `-Admin`):

```{sh}
#| eval: false
#| code-fold: false
su JohnField-Admin
```

Your **admin** password will be asked

2.  Create a directory where you will mount the remote folder. By default I like to put it in `/mnt/local_share`. You need to be super user to write in `/mnt/`:

```{sh}
#| eval: false
#| code-fold: false
sudo mkdir /mnt/local_share
```

This step should be done only once.

3.  Mount the remote folder `smb://del1509n015/2024_faircarbon/`, where you replace `your_name` by your **usual** IGN id (NOT the admin one):

```{sh}
#| eval: false
#| code-fold: false
sudo mount -t cifs -o username=your_name,domain=ign,uid=your_name //del1509n015/2024_faircarbon /mnt/local_share/
```

Maybe two passwords will be asked, first your **admin** password to execute the `sudo`, and then your **usual** password. If you just did step 2, then the prompt will not ask again for your **admin** password again.

4.  Check that it worked, especially the reading and writting rigths:

```{sh}
#| eval: false
#| code-fold: false
ls -l /mnt/local_share/
```

The content of the remote folder should appear. You can close your admin session by using `ctrl + d` or `Cmd + d`

Now that the raw data are accessible to {{< fa brands r-project >}}, it is time to prepare them!

## Prepare the data

### Loading the data

The following packages are required to load and handle the data and print summary tables:
```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(inventR)
library(stringi)
library(terra)
library(gt)
```

And one helper function to convert degree coordinates to decimals (for the INRA data):
```{r}
angle2dec = function(angle)
{
	x = stri_match(angle, regex = "([+-]?\\d+)°(\\d+)'(\\d+)") # To split the degree from minute and second
	x = apply(x[, 2:4], 1L, function(y) {
		y = as.numeric(y)
		y[1] + y[2]/60 + y[3]/3600
	})
	return(x)
}
```

Read the data from (mounted) remote folder:
```{r}
#### Prepare data
## Loading
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
	path_data = paste0(mnt_point, "/data_orig/")
	if (!dir.exists(path_data))
		stop(paste0("Folder <", path_data, "> does not exist! Check mounting point and mounted folder"))
} else if (os == "Windows") {
	path_data = "//Del1509n015/2024_FairCarbon/data_orig/"
	if (!dir.exists(path_data))
		stop(paste0("Folder <", path_data, "> does not exist!"))
} else {
	stop(paste("Unknown Operating System:", os))
}

# Emerge data
filename_emerge = paste0(path_data, "EMERGE.RData")
if (!file.exists(filename_emerge))
	stop(paste0("The file <", filename_emerge, "> does not exist"))

load(filename_emerge)

# Swiss data
filename_switzerland = paste0(path_data, "switzerland/stembranchchwood_2024-04-25.txt")
if (!file.exists(filename_switzerland))
	stop(paste0("The file <", filename_switzerland, "> does not exist"))

swiss_dt = fread(filename_switzerland)
swiss_sp = fread(paste0(path_data, "switzerland/Species_correspondance_table.csv"))
```

### Variable names

The variable names are not necessarily unified (but the species names are, I checked! So I can safely use the data.table `codesessences`). I gather in @tbl-notations the data-specific variable names and the common english name I use hereafter.

| INRA            | NFI  | Common             | Description                        |
|----------------:|-----:|:-------------------|:-----------------------------------|
| id              | npp  | plot_id            | Plot id                            |
| nom_fichier     | \-   | unique_id          | Unique id                          |
| essence         | ess  | speciesName_sci    | Species name                       |
| c130            | c13  | circumference_m    | Circumference at 1.3 m             |
| h_tot           | htot | height             | Height in m                        |
| total_volume_m3 | \-   | total_volume_m3    | Total above-ground volume          |
| v_tronc         | v    | bole_volume_m3     | Volume bole up to 7 cm             |
| v_courrone      | \-   | crown_volume_m3    | Total volume minus bole volume     |
| genre           | \-   | genus              | Genus                              |
| longitude       | xl   | \-                 | Coordinates in different proj      |
| latitude        | yl   | \-                 | Coordinates in different proj      |

: Variable names {#tbl-notations .borderless .hover}

### Species
For convenience, I format the species data frame with strings rather than factor, change it to data.table, and add some variables:
```{r}
setDT(codesessences)

codesessences[, nfi := as.character(essence_ifn)]
codesessences[, genre := as.character(genre)]
codesessences[, espece := as.character(espece)]
codesessences[, nomessence := as.character(nomessence)]

codesessences[essence_ifn < 10, nfi := paste0("0", nfi)]
```

I noticed one error in the `codesessences` data.table for the species `essence_ifn = 65`. It is written *Cedrus atlantica ou libani* but it should be *Cedrus atlantica* according to the French NFI.

```{r}
codesessences[essence_ifn == 65, c("nomessence", "espece") := .("cèdre de l Atlas", "atlantica")]
```

Then, I also decided to merge *Pinus nigra ssp pallasiana* with *Pinus nigra* because there are only 7 individuals *v.s.* 240. Note that after all, *Pinus nigra ssp pallasiana* [is a synonym](https://inpn.mnhn.fr/espece/listeEspeces/pinus+nigra/) of *Pinus nigra ssp nigra*, which is quite close to *Pinus nigra*. There is also a mistake for `Thuja plicata`, it is written `Thuya`. The unknown genus are transformed when possible to `Broadleaves` or `Conifers`.

```{r}
codesessences[espece == "nigra ssp pallasiana", espece := "nigra"]
codesessences[genre == "Thuya", genre := "Thuja"]
codesessences[genre == "inconnu (feuillus)", genre := "Broadleaves"]
codesessences[genre == "inconnu (résineux)", genre := "Conifers"]
codesessences[, c("speciesName_sci", "fct_type") := .(paste(genre, espece), ifelse(feuillu, "broadleaf", "conifer"))]
```

Finally, the `essence_ifn = 99913` is for grouping *Quercus robur* and *Quercus petraea*, while `essence_ifn = 1` groups *Quercus robur*, *Quercus petraea*, and *Quercus pubescens*. I decided to merge these two codes, using the largest group (\ie `essence_ifn = 1`).
```{r}
ref_nomessence = codesessences[essence == 19, nomessence]
ref_espece = codesessences[essence == 19, espece]
ref_speciesName_sci = codesessences[essence == 19, speciesName_sci]
codesessences[essence == 22,
	c("nomessence", "espece", "speciesName_sci") := .(ref_nomessence, ref_espece, ref_speciesName_sci)]
```

### Clean the datasets and compute new variables

Keep only the columns of interest, change column names, transform everything to `data.table` for INRA data and for helper data tables (`codesforets`, which contains coordinates, and `codesessences`, which contains species codes):
```{r}
setDT(inra_arbres)
setDT(codesforets)

## Compute (total) volume in m³, and format data
inra_arbres[, total_volume_m3 := (v_tronc_verif + v_fourche_verif + v_fourche2_verif + v_br_verif + v_menu_verif)/1e3]
inra_arbres[, v_tronc_verif := v_tronc_verif/1e3] # Conversion to m3
inra_arbres[, v_courrone := total_volume_m3 - v_tronc_verif] # Volume of the crown, i.e., everything that is NOT trunk > 7 cm
inra_arbres[, circumference_m := c130/100]

inra_arbres[, year := format(as.Date(date, "%Y-%m-%d"), "%Y")]

## Keep only column of interest and rename them
inra_arbres = unique(inra_arbres[, .(nom_fichier, id_codesessences, circumference_m, h_tot, total_volume_m3, v_tronc_verif,
	v_courrone, genre, id_codesforets, year)])
inra_arbres = merge.data.table(inra_arbres, codesforets[, .(id, longitude, latitude)],
	by.x = "id_codesforets", by.y = "id")
inra_arbres = merge.data.table(inra_arbres, codesessences[, .(essence, speciesName_sci, fct_type)],
	by.x = "id_codesessences", by.y = "essence")

inra_arbres = na.omit(inra_arbres)

setnames(inra_arbres, new = c("species_code_inra", "plot_id", "unique_id", "circumference_m", "height", "total_volume_m3",
	"bole_volume_m3", "crown_volume_m3", "genus", "year", "lon", "lat", "speciesName_sci", "fct_type"))

## Change type of cols
inra_arbres[, unique_id := as.character(unique_id)]
inra_arbres[, genus := as.character(genus)]
```

### Request of the French NFI data (using inventR package) {#sec-nfi_query}

As said above, I do not trust the data.frame `ifn_arbres`. I do my own request here, to get tree volumes and the plot coordinates. Note that I filtered trees measured before 1988 because diameters were collected instead of circumferences. This is known to be less precise (as the trunk is more likely to be an ovoid) and so it is better to start from 1988, where the circumferences are measured (Florence Gohon, *pers. comm.*).

```{r}
## French NFI data query
db = connect_db()

nfi_data = exec_req(conn = db, req = "
	SELECT
		tree.NPP, tree.A, tree.ESS, tree.C13, tree.HTOT, tree.R, tree.V, tree.VTOT,
		tree.d26, tree.ddec, tree.dmed, tree.cmed, tree.hdec,
		log.surlon, log.surdia, log.ns,
		coords1.XL, coords1.YL,
		EXTRACT(YEAR FROM coords2.DATEPOINT) AS year
	FROM
		inv_exp_am.g3arbre AS tree
		
		LEFT JOIN inv_exp_am.g3bille AS log
		ON log.npp = tree.npp AND log.A = tree.A

		LEFT JOIN inv_exp_am.e1point AS coords1
		ON coords1.npp = tree.npp
		
		LEFT JOIN inv_exp_am.e2point AS coords2
		ON coords2.npp = tree.npp
	WHERE
		tree.CUBE = 'M' AND -- Tree volume measured rather than evaluated by a model
		tree.MC IN ('4', '5') AND -- Circumference measured, and not diameter
		(tree.DOM BETWEEN '0' AND '5') -- No pollarded nor heavily pruned tree
		-- coords2.DATEPOINT >= '1988-01-01'::date -- I think there is no need for this one
	ORDER BY
		npp, a;", DT = TRUE)

disconnect_db(db)
```

I believe that it is important to know how the data are built! Here, `vtot` is the sum of three volumes coming from:

1. A first log, from the base level to either \qty{2.60}{\metre} or $h_{\text{dec}}$, measured using the cylinder formula:
$$
v_1 = \begin{cases}
	\frac{h_{\text{dec}} c_{\text{med}}^2}{4 \pi} & \text{if } h_{\text{dec}} < 2.6
	\frac{2.60 c^2}{4 \pi} & \text{if } h_{\text{dec}} \geqslant 2.6 \\
\end{cases}
$$
where $c_{\text{med}}$ is the median circumference measured at $h_{\text{dec}}/2$. Note that when $h_{\text{dec}} = 2.6$, the median circumference is not necessarily equal to $c$! The difference, remains however quite small (see @fig-dens_cmed).
```{r}
#| echo: false
#| fig-cap: Density of $c_{\text{med}} - c$
#| label: fig-dens_cmed
plot(density(nfi_data[hdec == 2.6, cmed - c13]), main = "", xlab = "Median minus breast height circumferences",
	lwd = 3, axes = FALSE)
axis(1)
axis(2, las =  1)
```
2. A second log, from \qty{2.60}{\metre} to the taper cut-off height (height at which there is at least a 10% decrease in diameter within a meter), measured using the three-level Newton-Simpson formula:
$$
v_2 = \frac{\pi}{24} \cdot (d_{26}^2 + 4 d_{\text{m}}^2 + d_{\text{dec}}^2) \cdot (h_{\text{dec}} - 2.60)
$$
3. $n \geqslant 0$ log sections of the trunk, from the taper cut-off height (in the case of a taper cut) to the merchantable timber cut-off (\qty{7}{\centi\metre} diameter for the French NFI), calculated using the cylinder formula:
$$
v_3 = \frac{\pi}{4}\sum_{n \geqslant 0} d^2 l
$$

In the data, I downloaded both $v$ and $v_{\text{tot}}$ which should be equal only when there is no cull. Otherwise, $v > v_{\text{tot}}$ since $v = (1 - r) v_{\text{tot}}$, $r$ being the cull. However, I found that these two variables are always equal and that the cull volume is always removed! My reconstruction of the volume does not remove the cull, and should be used later on to relate volume and circumference.

```{r}
#| results: hold
nfi_data[hdec < 2.6, v1 := cmed^2/(4*pi)*hdec] # Volume first part: from 0 to hdec. Note that hdec == 2.6 still uses cmed
nfi_data[hdec >= 2.6, v1 := c13^2/(4*pi)*2.6] # Volume first part: from 0 to 2.6m high
nfi_data[, v2 := pi/24*(d26^2 + 4*dmed^2 + ddec^2)*(hdec - 2.6)] # Volume 2nd part: from 2.6m to hdec
nfi_data[, v3 := pi/4*sum(surdia^2*surlon), by = .(npp, a)] # Volume 3rd part: from hdec to diameter = 7cm

nfi_data[, c("surlon", "surdia", "ns") := NULL]

nfi_data[is.na(v2), v2 := 0]
nfi_data[is.na(v3), v3 := 0]
nfi_data[, bole_volume_reconstruct_m3 := v1 + v2 + v3]
nfi_data[, verif := (1 - r)*bole_volume_reconstruct_m3 - vtot] # This shows that the cull is removed from both v and vtot

## Distribution of the volume diff and of hdec (taper height) for 'high' differences (> 1e-2)
hist(nfi_data$verif)
plot(nfi_data[abs(verif) > 1e-2, density(hdec)], xlab = "hdec", main = "", axes = FALSE, lwd = 3)
abline(v = 2.6, lwd = 2, col = "#CD212A")
axis(1)
axis(2, las = 1)

## Remove columns of little interest
nfi_data[, c("v1", "v2", "v3", "d26", "dmed", "cmed", "verif") := NULL]

nfi_data = na.omit(nfi_data)

## Add scientific species names
nfi_data = merge.data.table(nfi_data, codesessences[, .(nfi, genre, speciesName_sci, fct_type)],
	by.x = "ess", by.y = "nfi")

## Strangely, v and vtot are the same... I keep v then
if (isTRUE(nfi_data[, all.equal(v, vtot, tol = 1e-5)]))
{
	print("The cols v and vtot are the same, which is strange as I was expecting vtot = (1 - r)*v. I remove vtot and r")
	nfi_data[, vtot := NULL]
	nfi_data[, r := NULL]
} else {
	stop("When I downloaded the data, v and vtot were the same. It seems it is not anymore! Check what could have happened")
}

## Change column names
setnames(nfi_data, new = c("species_code_nfi", "plot_id", "tree_id", "circumference_m", "height", "bole_volume_m3",
	"taper_diameter", "taper_height", "x_lambert", "y_lambert", "year", "bole_volume_reconstruct_m3", "genus",
	"speciesName_sci", "fct_type"))

## Densities of circumference and height for taper_height < 2.6
plot(nfi_data[taper_height <= 2.6, density(height)], xlab = "Height", main = "", axes = FALSE, lwd = 3)
axis(1)
axis(2, las = 1)

plot(nfi_data[taper_height <= 2.6, density(circumference_m)], xlab = "Circumference", main = "", axes = FALSE, lwd = 3)
axis(1)
axis(2, las = 1)

plot(nfi_data[taper_height <= 2.6, density(height/circumference_m)], xlab = "Slenderness", main = "", axes = FALSE, lwd = 3)
axis(1)
axis(2, las = 1)
```

For most of the trees I find back the volume. I do not really know why some differences still persist, and I do not have much time to investigate.

### Coordinates

Unfortunately, not all the coordinates are available... And when they are, different work must be performed depending on the source:

1.  'protocole Oudin' INRA data: the coordinates are directly available, in the table `codesforets` that I already joined to `inra_arbres`.

2.  French NFI: I included the coordinates in my query.

3.  ONF: I asked directly Christine Deleuze (answer from the 09 January 2025). There is unfortunately no coordinates (at least, none that can be provided to me...).

#### Coordinates 'protocole Oudin' INRA data

```{r}
## Coordinates
coords_inra = inra_arbres[, .(plot_id, lon, lat)]

coords_inra[, lon := as.character(lon)]
coords_inra[, lat := as.character(lat)]

coords_inra[, lon_dec := angle2dec(lon)]
coords_inra[, lat_dec := angle2dec(lat)]

coords_inra = vect(x = coords_inra[, .(plot_id, lon_dec, lat_dec)],
	geom = c("lon_dec", "lat_dec"), crs = "EPSG:4326")
```

#### Coordinates French NFI

```{r}
## Coordinates
coords_nfi = unique(nfi_data[, .(plot_id, x_lambert, y_lambert)])

coords_nfi = vect(x = coords_nfi[, .(plot_id, x_lambert, y_lambert)],
	geom = c("x_lambert", "y_lambert"), crs = "EPSG:27572") # Lambert zone II, I checked it is the used projection
```

### Gather all the datasets into a single one
We now joined all the datasets into a single one. First I harmonise some columns, such as the coordinates that are not in the same projection system. Then only, I do a row bind, with some columns to fill by NAs (such as the branch volume that is not measured by the French NFI).

```{r}
## Add column unique_id to NFI data
nfi_data[, unique_id := paste(plot_id, tree_id, sep = "_")]

## Add Lambert coordinates (EPSG:27572) to INRA data
coords_inra = project(coords_inra, coords_nfi)
inra_arbres[, c("x_lambert", "y_lambert") := crds(x = coords_inra, list = TRUE)]
inra_arbres[, c("lon", "lat") := NULL]
coords_inra = unique(coords_inra) # Now that I put the coords in inra_arbres, I can do a unique

## Merge both INRA and NFI datasets
forest_dt = rbindlist(l = list(inra = inra_arbres, nfi = nfi_data), fill = TRUE, idcol = "origin_data")

## Remove the unknown broadleaves and conifers
forest_dt = forest_dt[speciesName_sci != "Broadleaves sp."]
forest_dt = forest_dt[speciesName_sci != "Conifers sp."]

## Remove null volumes (all from inra actually)
if (forest_dt[, any(bole_volume_m3 <= 0)])
{
	warning(paste(forest_dt[bole_volume_m3 == 0, .N], "null volumes. Removed as juge impossible"))
	if (forest_dt[, any(bole_volume_m3 < 0)])
		warning(paste("There were even", forest_dt[bole_volume_m3 < 0, .N], "negative volumes!"))
	forest_dt = forest_dt[bole_volume_m3 > 0]
}

## Set bole_volume_reconstruct_m3 of inra data to bole_volume_m3. TO DO: RECONSTRUCT THE VOLUMES
forest_dt[origin_data == "inra", bole_volume_reconstruct_m3 := bole_volume_m3] # TO DO: RECONSTRUCT THE VOLUMES

## Compute number of individuals per species
forest_dt[, nb_indiv := .N, by = speciesName_sci]

## Subsample forest_dt for testing
set.seed(1969 - 08 - 18)
n = round(forest_dt[, .N]/10)
selected = sort(sample(x = forest_dt[, .N], size = n, replace = FALSE))

forest_dt_sub = forest_dt[selected]
forest_dt_sub[, nb_indiv := .N, by = speciesName_sci]
forest_dt_sub = forest_dt_sub[nb_indiv > 30]
setkey(forest_dt_sub, fct_type, speciesName_sci, origin_data, unique_id)

## Subsample forest_dt for testing, INRA alone
forest_dt_inra = forest_dt[origin_data == "inra"]
forest_dt_inra[, nb_indiv := .N, by = speciesName_sci]
forest_dt_inra = forest_dt_inra[nb_indiv > 30]
setkey(forest_dt_inra, fct_type, speciesName_sci, origin_data, unique_id)

## Subsample forest_dt for testing, 50-50 Inra/NFI
set.seed(1969 - 08 - 18)
n = forest_dt[origin_data == "inra", .N]
selected = forest_dt[origin_data == "nfi"][sort(sample(x = .N, size = n, replace = FALSE))]

forest_dt_50 = rbind(forest_dt[origin_data == "inra"], selected)
forest_dt_50[, nb_indiv := .N, by = speciesName_sci]
forest_dt_50 = forest_dt_50[nb_indiv > 30]
setkey(forest_dt_50, fct_type, speciesName_sci, origin_data, unique_id)

setkey(forest_dt, fct_type, speciesName_sci, origin_data, unique_id)
```

### Compute the indices for Stan

Stan language uses vectors and arrays (think matrices), but does not know data.frames or data.tables. Therefore, it is necessary to provide an ordered dataset accordingly to the structure of the model. Here, we need to order by functional type and by species within function type. Then, the index table just indicates when each functional type and each species starts and ends in the data. This is not only necessary for Stan, but can also accelerate the computation by vectorising certain calculus. Of course, it is important that the data order is not changed **after** the index table is generated.

```{r}
## Indices
# Find start and end indices for each species
ind_fct = function(dt)
{
	if (!all.equal(key(dt), c("fct_type", "speciesName_sci", "origin_data", "unique_id")))
		stop("DT must have the following keys in the same order: fct_type, speciesName_sci, origin_data, unique_id")

	ind_species_1 = dt[, .(start = .I[1], end = .I[.N], fct_type = unique(fct_type)), by = .(speciesName_sci)]
	ind_species_2 = dt[, .(start_sp_orig = .I[1], end_sp_orig = .I[.N], genus = unique(genus)),
		by = .(speciesName_sci, origin_data)]
	ind_species = merge.data.table(x = ind_species_1, y = ind_species_2, by = "speciesName_sci")
	ind_species[, n_indiv := end - start + 1, by = speciesName_sci]

	if (unique(ind_species[, .(speciesName_sci, n_indiv)])[, sum(n_indiv)] != dt[, .N])
		stop("The number of individuals in ind_species does not correspond to the number of individuals in dt!")

	ind_species[, colour := if(fct_type == "broadleaf") "#FFAF37" else "#007BA5", by = .(speciesName_sci, origin_data)]
	setorder(ind_species, start)

	n_sp = ind_species[, .N, by = .(fct_type, origin_data)]
	setkey(n_sp, fct_type, origin_data)
	return(list(ind_species = ind_species, n_sp = n_sp))
}

ind_species = ind_fct(forest_dt)
ind_species_sub = ind_fct(forest_dt_sub)
ind_species_inra = ind_fct(forest_dt_inra)
ind_species_50 = ind_fct(forest_dt_50)
```

### Format the data for stan

```{r}
## Stan data
makeData = function(dt, ind_ls)
{
	if (!is.list(ind_ls))
		stop("ind_ls should be a list")

	if (!all(names(ind_ls) %in% c("n_sp", "ind_species")))
		stop("ind_ls must contain n_sp and ind_species. Run ind_fct first")

	n_sp = ind_ls[["n_sp"]]
	ind_species = ind_ls[["ind_species"]]

	stanData = list(
		N = dt[, .N],
		N_inra = dt[!is.na(crown_volume_m3), .N],
		S = ind_species[, .N],
		n_sp_broad_tot = n_sp["broadleaf", sum(N)],
		n_sp_conif_tot = n_sp["conifer", sum(N)],
		n_sp_broad_inra = n_sp[CJ("broadleaf", "inra"), N],
		n_sp_conif_inra = n_sp[CJ("conifer", "inra"), N],

		ind_start_broad = ind_species[fct_type == "broadleaf", start],
		ind_start_conif = ind_species[fct_type == "conifer", start],
		ind_end_broad = ind_species[fct_type == "broadleaf", end],
		ind_end_conif = ind_species[fct_type == "conifer", end],

		ind_start_broad_inra = ind_species[(fct_type == "broadleaf") & (origin_data == "inra"), start_sp_orig],
		ind_start_conif_inra = ind_species[(fct_type == "conifer") & (origin_data == "inra"), start_sp_orig],
		ind_end_broad_inra = ind_species[(fct_type == "broadleaf") & (origin_data == "inra"), end_sp_orig],
		ind_end_conif_inra = ind_species[(fct_type == "conifer") & (origin_data == "inra"), end_sp_orig],

		height = dt[, height],
		circumference_m = dt[, circumference_m],

		total_volume_m3 = dt[, total_volume_m3],
		bole_volume_m3 = dt[, bole_volume_reconstruct_m3],
		crown_volume_m3 = dt[, crown_volume_m3]
	)

	return(stanData)
}

stanData = makeData(forest_dt, ind_species)
stanData_sub = makeData(forest_dt_sub, ind_species)
stanData_inra = makeData(forest_dt_inra, ind_species)
stanData_50 = makeData(forest_dt_50, ind_species)
```

### Save the data

The data are now ready and can be saved:
```{r}
## Complete dataset
add_name = "_full"
saveRDS(stanData, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))
if (!dir.exists(paste0(mnt_point, "data/coords_inra", add_name)))
	writeVector(x = coords_inra, filename = paste0(mnt_point, "data/coords_inra", add_name), filetype = "ESRI Shapefile",
		overwrite = TRUE)

if (!dir.exists(paste0(mnt_point, "data/coords_nfi", add_name)))
	writeVector(x = coords_nfi, filename = paste0(mnt_point, "data/coords_nfi", add_name), filetype = "ESRI Shapefile",
		overwrite = TRUE)

## Random sub dataset
add_name = ""
saveRDS(stanData_sub, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt_sub, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species_sub, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))

## Inra dataset
add_name = "_inra"
saveRDS(stanData_inra, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt_inra, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species_inra, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))

## 50-50 dataset
add_name = "_50"
saveRDS(stanData_50, paste0(mnt_point, "data/stanData_nfi-inra", add_name, ".rds"))
saveRDS(forest_dt_50, paste0(mnt_point, "data/nfi-inra_dt", add_name, ".rds"))
saveRDS(ind_species_50, paste0(mnt_point, "data/ind_species_nfi-inra", add_name, ".rds"))
```

## Data for posterior checks

After running a Bayesian model, it is important to do a 'predict' on new data to check that the model can generate sensible volume. For this, I use the volume-measured trees dataset from 2009 and 2010, which I format in this section. There are three datasets for each year, one for:

1. `emerge_2010_profils`: tree profiles, containing bole dimensions (circumference every 2 meters)
2. `emerge_2010_branches`: tree branches, containing small and large branches dimensions
3. `emerge_2010_arbres`: tree information, such as dbh, plot, etc... It also contains the total above-ground volume, the total branch volume, and the bole volume. Note that I was able to reconstruct the total branch volume, but that I never succeeded to reconstruct the bole volume

### Reconstruct bole volumes from profiles and comparison with provided data {#sec-trunkVol}
```{r}
## Change to data table
setDT(emerge_2010_arbres)
setDT(emerge_2010_profils)

## Clean the tree dataset and keep only columns of interest (tree is already unique id, no need for site, nor parcelle)
emerge_2010_profils[, c("circ_bottom_m", "circ_top_m") := .(circ_bas_cm/100, circ_haut_cm/100)]
emerge_2010_profils[, c("id", "poids_hum_billon_kg", "poids_hum_rondelle_partiebef_kg", "circ_haut_cm",
	"poids_hum_rondelle_partieqb_kg", "poids_hum_rondelle_kg", "commentaires", "circ_bas_cm")  := NULL]
setnames(emerge_2010_profils, old = c("tree", "longueur_billon_pese_m", "niveau_bas_m", "niveau_haut_m"),
	new = c("tree_id", "length", "h_bottom", "h_top")) 

setkey(emerge_2010_profils, tree_id, h_bottom)
setkey(emerge_2010_profils, tree_id)

## Compute length when missing, and volumes using the frustum and cylinder formulae
emerge_2010_profils[is.na(length), length := h_top - h_bottom]

emerge_2010_profils[, vol_log_conic := length/(12*pi)*(circ_bottom_m^2 + circ_top_m^2 + circ_bottom_m*circ_top_m)]
emerge_2010_profils[, cumulated_vol_conic := cumsum(vol_log_conic), by = tree_id]
emerge_2010_profils[, bole_volume_conic_m3 := sum(vol_log_conic), by = tree_id]

emerge_2010_profils[, vol_log_cyl := length/(16*pi)*(circ_bottom_m + circ_top_m)^2]
emerge_2010_profils[, cumulated_vol_cyl := cumsum(vol_log_cyl), by = tree_id]
emerge_2010_profils[, bole_volume_cyl_m3 := sum(vol_log_cyl), by = tree_id]

## Height
emerge_2010_profils[, height := max(h_top), by = tree_id]

## Compare with the volume provided in emerge_2010_arbres
compare = unique(emerge_2010_profils[, .(tree_id, bole_volume_cyl_m3, bole_volume_conic_m3)])
compare = merge.data.table(compare, emerge_2010_arbres[, .(tree, v_tronc_cone_verif, v_tronc_cylindre_verif)],
	by.x = "tree_id", by.y = "tree")
```

Now, I compare these reconstructed volumes with those provided in `emerge_2010_arbres`.
```{r}
#| echo: false
#| label: fig-compare_bole_vol
#| fig-cap: Compare the volumes (reconstruction - provided)
#| fig-subcap: 
#|   - "Frustum formula"
#|   - "Cylinder"
#| layout-ncol: 2
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

plot(density(compare[, (bole_volume_conic_m3 - v_tronc_cone_verif)/v_tronc_cone_verif]),
	xlab = "Relative change in conical volume", main = "", lwd = 4, axes = FALSE, log = "x")
axis(1)
axis(2, las = 1)

plot(density(compare[, (bole_volume_cyl_m3 - v_tronc_cylindre_verif)/v_tronc_cylindre_verif]),
	xlab = "Relative change in cylinder volume", main = "", lwd = 4, axes = FALSE, log = "x")
axis(1)
axis(2, las = 1)
```

Given that I believe it is important to know how the data are constructed and also because the differences are negligeable as can be seen on @fig-compare_bole_vol. Mind the log scale on the x-axis of the relative change computed as:

$$
\frac{\text{my volume} - \text{provided volume}}{\text{provided volume}}
$$

### Reconstruct branch volume and comparison with provided data {#sec-branchVol}

BLABLABLA

```{r}
## Change class to data table
setDT(emerge_2010_branches)
setnames(emerge_2010_branches, old = "tree", new = "tree_id")

# qq = copy(emerge_2010_branches)
# emerge_2010_branches = copy(qq)

## Clean the branch dataset and compute total branch volume per tree
# Remove lines for which I cannot deduce a volume because all information are missing
emerge_2010_branches = emerge_2010_branches[!(is.na(l_cm) & is.na(c_cm) & is.na(m_wet_kg))]

# Remove lines for which I cannot deduce a volume because there is only l_cm or c_cm provided but no m_wet_kg
emerge_2010_branches = emerge_2010_branches[!((is.na(l_cm) & is.na(m_wet_kg)) | (is.na(c_cm) & is.na(m_wet_kg)))]

# Compute branch volumes for branches with both a length and circumference, using a cylinder formula
emerge_2010_branches[!is.na(c_cm) & !is.na(l_cm), vol_branches_m3 := c_cm^2*l_cm/(4*pi*1e6)]

# Use a density of 1000 kg/m^3 to convert the wet weight into volume when both c_cm, and l_cm are missing
emerge_2010_branches[is.na(l_cm) & is.na(c_cm), vol_branches_m3 := m_wet_kg/1e3]

# Remove NAs
emerge_2010_branches = emerge_2010_branches[!is.na(vol_branches_m3)] # It removes one branch which was broken

## Compute total branch volume
emerge_2010_branches[, vol_tot_branch_m3 := sum(vol_branches_m3), by = tree_id]

compare = unique(emerge_2010_branches[, .(tree_id, vol_tot_branch_m3)])
compare = merge.data.table(compare, emerge_2010_arbres[, .(tree, v_br_verif)],
	by.x = "tree_id", by.y = "tree")
```

My reconstruction matches the provided branch volumes except for `{r} compare[abs(vol_tot_branch_m3 - v_br_verif) > 1e-5, .N]` trees. Note that I did like Christine Deleuze and her team: for the incomplete trees I use a density of \qty{1000}{\kilogram\per\cubic\metre} to convert the wet weight into a volume when branch's length or circumference are missing.

### Join my reconstructions together

Here, it would be good to join both profile and branches tables. However, there remains some questions! See @sec-TODO where I details what to do

```{r}
## Join both profile and branches table
emerge_2010 = merge.data.table(x = unique(emerge_2010_branches[, .(tree_id, vol_tot_branch_m3)]),
	y = unique(emerge_2010_profils[, .(tree_id, bole_volume_cyl_m3, bole_volume_conic_m3)]), all.y = TRUE)

emerge_2010 = merge.data.table(emerge_2010, emerge_2010_arbres[, .(tree, id_codesforets, id_codesessences, c130,
	v_br_verif, v_tronc_cone_verif, v_menu_verif)], by.x = "tree_id", by.y = "tree")

# emerge_2010[is.na(vol_tot_branch_m3)] # I checked, v_br_verif is set to 0 in this case, so no branch
```

```{r}
# trees_2010 = merge.data.table(unique(emerge_2010_branches[, .(tree_id, vol_tot_branch_m3)]),
# 	unique(emerge_2010_profils[, .(tree_id, bole_volume_cyl_m3, bole_volume_conic_m3)]))

# emerge_2010_arbres = merge.data.table(emerge_2010_arbres, codesessences[, .(essence, genre, espece)],
# 	by.x = "id_codesessences", by.y = "essence", all.x = TRUE)



# emerge_2010_arbres = unique(emerge_2010_arbres[, .(date, id_codesforets, id_codesessences, genre, espece, tree, species, c130,
# 	hauteur_souche_m, longueur_arbre_m, longueur_d7_m, v_br_verif, v_menu_verif, v_tronc_cone_verif, v_tronc_cylindre_verif)])

# emerge_2010_arbres[is.na(genre)]

# ## Add species name sci
# emerge_2010_arbres[, speciesName_sci := paste(genre, espece)]

# setnames(emerge_2010_arbres, old = c("c130", "longueur_arbre_m", "v_tronc_cone_verif", "v_tronc_cylindre_verif"),
# 	new = c("circumference_m", "height", "bole_volume_conic_m3", "bole_volume_cyl_m3"))

# ## Keep only variables of interest
# data_check = unique(emerge_2010_profils[, .(tree, speciesName_sci, height, circumference_m,
# 	bole_volume_conic_m3, bole_volume_cyl_m3)])

# ## Change vernacular species names to scientific
# species_dt = data.table(species = c("Frêne", "Chêne vert", "Tilia cordata", "Chêne sessile", "Eucalyptus",
# 		"Robinier", "Pin Alep", "Chêne pubescent", "Aulne", "Bouleau"),
# 	speciesName_sci = c("Fraxinus excelsior", "Quercus ilex", "Tilia cordata", "Quercus petraea", "Eucalyptus spp.",
# 		"Robinia pseudoacacia", "Pinus halepensis", "Quercus pubescens", "Alnus glutinosa", "Betula pendula"),
# 	fct_type = c(rep("broadleaf", 6), "conifer", rep("broadleaf", 3)))

# data_check = merge.data.table(data_check, species_dt, by = "species")
# data_check[, species := NULL]
# data_check[speciesName_sci == "Quercus petraea", speciesName_sci := "Quercus robur_petraea"] # Because of inra_arbres
# setkey(data_check, speciesName_sci)

# data_check = data_check[speciesName_sci %in% species_nb[, speciesName_sci]]

# data_check[, hdn := sqrt(circumference_m)/height]
# data_check[, slenderness := height/circumference_m]
# data_check[, corrected_cyl_vol := height*circumference_m^2/(4*pi*(1 - 1.3/height)^2)]

# data_check[, feuil.res := as.factor(fct_type)]
```

## TO DO!!!!! {#sec-TODO}
Menus bois?? Je fais comment pour reconstruire ça??? Comment ça a été calculé? Demandé à Christine Deleuze.

## Felled trees across Switzwerland 
Data similar to EMERGE has also been collected in Switzerland, spanning from 1888 and 1974 [@Didion2024]. It represents more than \num{40000} felled trees, with diameter measurements every two meters (when possible) up to the taper height of \qty{7}{\centi\metre}. All the trees have a diameter measured at \qty{1}{\metre}, \qty{3}{\metre}, \qty{5}{\metre}, and so on. The original data provided volumes, however the authors of @Didion2024 never succeded to reconstruct them fully (*personal comm.*). Therefore, they decided to let the reconstruction of the volume open. I reconstruct the bole volume using cylinders 

```{r}
#### Reshape data
## Melt
swiss_dt = melt(swiss_dt, measure = patterns("^DM[[:digit:]]"), variable.name = "diameter_height", value.name = "diameter",
	variable.factor = FALSE)

## Define new variables, convert some to m, and rename some columns
swiss_dt[, c("diameter", "dbh_m", "height", "L_coarsestemfinal", "L_top", "D_coarsestemfinal", "D_top") :=
	.(diameter/1e3, DBH/1e3, H_total/10, L_coarsestemfinal/10, L_top/10, D_coarsestemfinal/1e3, D_top/1e3)]

swiss_dt[, c("Elevation", "NFI_PR", "StandAge", "StandComp", "TreeAge", "NFI_mainspecies", "DBH", "H_total") := NULL]

setnames(swiss_dt, old = c("SiteID", "Lat", "Long", "InvYear", "TreeID", "TreeSpecies"),
	new = c("plot_id", "lat", "lon", "year", "tree_id", "sp_code"))

swiss_dt[diameter_height == "DM065", diameter_height_m := 0.65]
swiss_dt[diameter_height != "DM065",
	diameter_height_m := as.numeric(stri_replace(str = diameter_height, regex = "DM", replacement = ""))]

## Get coordinates
coords_swiss = vect(x = unique(swiss_dt[!is.na(lon) | !is.na(lat), .(plot_id, lon, lat)]), crs = "EPSG:4326")
swiss_dt[, c("lon", "lat") := NULL]

## Sort by tree id, and then diameter height (tree_id is already a unique identifier, no need for plot_id)
setkey(swiss_dt, tree_id, diameter_height_m)

## Set D_coarsestemfinal, L_coarsestemfinal, D_top, and L_top to 0 when NA
swiss_dt[is.na(D_coarsestemfinal), D_coarsestemfinal := 0]
swiss_dt[is.na(L_coarsestemfinal), L_coarsestemfinal := 0]
swiss_dt[is.na(D_top), D_top := 0]
swiss_dt[is.na(L_top), L_top := 0]

swiss_dt[is.na(V_coarsebranch), V_coarsebranch := 0]
swiss_dt[is.na(V_finebranch), V_finebranch := 0]
swiss_dt[is.na(V_finewoodytotal), V_finewoodytotal := 0] # Includes the top of the tree, but is NA if V_finebranch = NA!

## Remove useless lines
swiss_dt = swiss_dt[!is.na(diameter)] # Diameters that do not exist or where not given
swiss_dt = swiss_dt[!is.na(sp_code)] # Missing species information

## Compute volumes
# Volume trunk using cylindre formula with median diameter: log 0 to 2 --> DM1, log 2 to 4 --> DM3, etc...
swiss_dt[, vol_log_cyl := pi*diameter^2/4*2] # The *2 comes from the fact that each log is 2m long
swiss_dt[, bole_volume_cyl_m3 := sum(vol_log_cyl) + pi*D_coarsestemfinal^2/4*L_coarsestemfinal, by = tree_id]
swiss_dt[, top_volume_m3 := pi*D_top^2/4*L_top, by = tree_id]

# Volume crown (already provided)
swiss_dt[, V_coarsebranch := V_coarsebranch/1e3] # Conversion to m³
swiss_dt[, V_finebranch := V_finebranch/1e3] # Conversion to m³
swiss_dt[, V_finewoodytotal := V_finewoodytotal/1e3] # Conversion to m³

swiss_dt[, crown_volume_m3 := V_coarsebranch + V_finebranch + top_volume_m3]

# Total volume
swiss_dt[, total_volume_m3 := bole_volume_cyl_m3 + crown_volume_m3]

## Keep only cols and rows of interest
swiss_dt = unique(swiss_dt[, .(plot_id, year, tree_id, sp_code, dbh_m, height, bole_volume_cyl_m3,
	crown_volume_m3, total_volume_m3)])

## Add circumference for ease
swiss_dt[, circumference_m := pi*dbh_m]
```

Add species to the swiss data. Few species names are modified to match the French NFI names. For instance, *Pinus mugo Turra subsp. mugo* becomes *Pinus mugo*, while *Acer campestre, platanoides*, and *pseudoplatanus*, become *Acer sp.*. Note that for the second case, it creates two corresponding match: 'petit érable' (for *A. campestre*) and 'grand érable' (for the two others). There is unfortunately no way to distinguish them. Same for the three *Quercus petraea*, *robur*, and *rubra* that are grouped in the swiss EFM, while in France the group is *Quercus petraea*, *pubescens*, and *robur*.

```{r}
## Add species
# Change colnames and keep columns of interest
swiss_sp[, c("NFI main species", "N") := NULL]
setnames(swiss_sp, old = c("Species ID", "Species name"),
	new = c("sp_code_swiss", "speciesName_sci"))

# Correct/modify few species to match codesessences
swiss_sp[speciesName_sci == "Pinus mugo Turra subsp. mugo", speciesName_sci := "Pinus mugo"]
swiss_sp[speciesName_sci == "Chamaecyparis", speciesName_sci := "Chamaecyparis sp."]
swiss_sp[speciesName_sci == "Picea omorika", speciesName_sci := "Picea sp."] # There are only 14 individuals...
swiss_sp[speciesName_sci == "Larix kaempferi (Lamb.) Carrière", speciesName_sci := "Larix kaempferi"]
swiss_sp[speciesName_sci == "Quercus petraea, Q. robur, Q. rubra", speciesName_sci := "Quercus sp."] # 1821 individuals
swiss_sp[speciesName_sci == "Fraxinus americana, F. excelsior", speciesName_sci := "Fraxinus sp."] # 141 individuals
swiss_sp[speciesName_sci == "Acer campestre, A. platanoides, A. pseudoplatanus", speciesName_sci := "Acer sp."] # 90 indiv
swiss_sp[speciesName_sci == "Juglans regia", speciesName_sci := "Juglans sp."] # 207 individuals
swiss_sp[speciesName_sci == "Other broadleaves, incl. Sorbus spp and Tilia spp",
	speciesName_sci := "Broadleaves sp."] # 9 individuals

codesessences = merge.data.table(x = codesessences, y = swiss_sp, all.x = TRUE, by = "speciesName_sci")

non_unique = codesessences[!is.na(sp_code_swiss)][, .N, by = sp_code_swiss][N > 1][, sort(sp_code_swiss)]

# Drop the nfi codes from codesessences that are not present in forest_dt
nfi_to_check = codesessences[sp_code_swiss %in% non_unique, nfi]
nfi_to_dump = nfi_to_check[!(nfi_to_check %in% forest_dt$species_code_nfi)]
codesessences = codesessences[!(nfi %in% nfi_to_dump)]

# Drop the inra codes from codesessences that are not present in forest_dt
inra_to_check = codesessences[sp_code_swiss %in% non_unique, essence]
inra_to_dump = inra_to_check[!(inra_to_check %in% forest_dt$species_code_inra)]
codesessences = codesessences[!(essence %in% inra_to_dump)]

# Check there is no duplicates left
non_unique = codesessences[!is.na(sp_code_swiss)][, .N, by = sp_code_swiss][N > 1][, sort(sp_code_swiss)]

if (length(non_unique) != 0)
	warning("There are still duplicates, which might create problems")

swiss_dt = merge.data.table(x = swiss_dt,
	y = codesessences[!is.na(sp_code_swiss), .(sp_code_swiss, speciesName_sci, genus = genre, fct_type)],
	by.x = "sp_code", by.y = "sp_code_swiss")
```

```{r}
saveRDS(swiss_dt, paste0(mnt_point, "data/switzerland.rds"))
if (!dir.exists(paste0(mnt_point, "data/coords_switzerland")))
	writeVector(x = coords_swiss, filename = paste0(mnt_point, "data/coords_switzerland"),
		filetype = "ESRI Shapefile", overwrite = TRUE)
```

## Presentation of the data

### Distribution of the data in terms of circumference, height, slenderness, and coordinates

The data are composed by the following species:
```{r}
#| echo: false
#| label: fig-data
#| fig-cap: Number of individuals per genus (French data), with conifers in blue and broadleaves in orange. Watch out, it is a $\\log_{10}$ scale
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
species_nb = unique(ind_species[["ind_species"]][, .(n_indiv = sum(n_indiv), colour), by = genus])[order(n_indiv)]

par(mar = c(5, 12, 2, 2))
# Use barplot f or horizontal bars
barplot(
	species_nb[, n_indiv],
	names.arg = species_nb[, genus],
	horiz = TRUE, # Horizontal bars
	xlab = "Number of individuals",
	ylab = "",
	main = "",
	las = 1,
	log = "x",
	col = species_nb[, colour]
)
```

::: {.callout-note collapse=true}

```{r}
unique(forest_dt[, .N, by = speciesName_sci])[order(speciesName_sci)] |>
	gt() |>
	cols_label(
		speciesName_sci = "Species",
		N = "N. individuals"
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = speciesName_sci)
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(align = "left")),
		locations = cells_body(columns = N)
	)
```

:::

and the plots are located:

```{r}
#| echo: false
#| label: fig-map
#| fig-cap: "Location of the plots, with NFI for the Naional Forest Invetory of France, and EFM the Experimental Forest Monitoring of Switzerland [@Didion2024]"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

#### Coordinates
## Read shapefiles
switzerland = project(vect(paste0(mnt_point, "data/shapefiles/switzerland/CHE_adm0.shp")), coords_inra)
france = project(vect(paste0(mnt_point, "data/shapefiles/france/FRA_adm0.shp")), coords_inra)
belgium = project(vect(paste0(mnt_point, "data/shapefiles/belgium/gadm41_BEL_0.shp")), coords_inra)
italy = project(vect(paste0(mnt_point, "data/shapefiles/italy/gadm41_ITA_0.shp")), coords_inra)
luxembourg = project(vect(paste0(mnt_point, "data/shapefiles/luxembourg/gadm41_LUX_0.shp")), coords_inra)
germany = project(vect(paste0(mnt_point, "data/shapefiles/germany/gadm41_DEU_0.shp")), coords_inra)

fr_ch = project(rbind(france, switzerland), coords_inra)

## Projections
colours = met.brewer(name = "Lakota", n = 3)
names(colours) = c("nfi", "swiss", "inra")

## Plot
plot(fr_ch, lwd = 2, axes = FALSE)
points(coords_nfi, col = colours["nfi"], pch = 20, cex = 0.35)
points(coords_inra, col = colours["inra"], pch = 20, cex = 1.15)
points(project(coords_swiss, coords_inra), col = colours["swiss"], pch = 20, cex = 0.55)
plot(fr_ch, lwd = 2, add = TRUE, bg = "transparent")
plot(luxembourg, lwd = 2, add = TRUE)
plot(germany, lwd = 2, add = TRUE)
plot(belgium, lwd = 2, add = TRUE)
plot(italy, lwd = 2, add = TRUE)

legend(x = "bottomleft", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n", inset = c(0, 0.1))
```

It is now time to explore how the data are distributed, if they cover the same range of tree diameters, heights, and volumes.

```{r}
#| echo: false
#| label: fig-distrib
#| fig-cap: Distribution of the data
#| fig-subcap: 
#|   - "Densities of circumferences"
#|   - "Densities of heights"
#|   - "Densities of slenderness (height/circumference)"
#| layout-nrow: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

# --- Circumferences
dd_fr = density(forest_dt[origin_data == "nfi", circumference_m]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", circumference_m]) # Inra/Emerge data
dd_ch = density(swiss_dt[, circumference_m]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Circumference (m)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")

# --- Heights
dd_fr = density(forest_dt[origin_data == "nfi", height]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", height]) # Inra/Emerge data
dd_ch = density(swiss_dt[, height]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Height (m)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")

# --- Slenderness
dd_fr = density(forest_dt[origin_data == "nfi", height/circumference_m]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", height/circumference_m]) # Inra/Emerge data
dd_ch = density(swiss_dt[, height/circumference_m]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Slenderness (height/circumference)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")
```

### Response plots, bole
```{r}
#| echo: false

#### Binding both forest_dt and swiss_dt
## Temporary data
temp = rbind(forest_dt[, .(plot_id, tree_id, genus, circumference_m,
		bole_volume_m3 = bole_volume_reconstruct_m3, crown_volume_m3, origin_data)],
	swiss_dt[, .(plot_id, tree_id, genus, circumference_m,
		bole_volume_m3 = bole_volume_cyl_m3, crown_volume_m3)], fill = TRUE)

## Origin data and colours
temp[is.na(origin_data), origin_data := "swiss"]
temp[, colour := colours[origin_data], by = origin_data]

# ## Check composition data (complete)
# n = temp[, .N]
# # temp[, round(.N/n*100, 2), by = origin_data]

# ## Subset data
# set.seed(1969 - 08 - 18) # Woodstock seed
# n_sample = 1e5
# temp = temp[sort(sample(x = 1:.N, size = n_sample, replace = FALSE))]

# ## Check composition data (sampled)
# n = temp[, .N]
# # temp[, round(.N/n*100, 2), by = origin_data]

# ## Remove 'lonely' genus, i.e., less than 1e3 individuals
# temp[, n_indiv := .N, by = genus]
# temp = temp[n_indiv > 1000]

## Remove genus that 
select_genus = temp[, .N, by = .(genus, origin_data)][, .N, by = genus][N > 1, genus]

## List genus and set keys
temp = temp[genus %in% select_genus]

setkey(temp, genus, origin_data)
ls_genus = unique(temp[, genus]) # Insured that it is sorter by alphabetical order
```

::: {.callout-note collapse=true}

```{r}
temp[, .N, by = .(genus, origin_data)] |>
	gt() |>
	tab_options(
		quarto.disable_processing = TRUE,
		ihtml.use_highlight = TRUE
	) |>
	cols_label(
		genus = "Genus",
		origin_data = "Dataset",
		N = "N. individual"
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = genus)
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(align = "left")),
		locations = cells_body(columns = c(N, origin_data))
	)
```

:::

```{r}
#| echo: false
#| label: fig-responses
#| fig-cap: Response of volume to circumference for the 17 genus that are present in at least two datasets
#| fig-subcap:
#|   - "Abies"
#|   - "Acer"
#|   - "Betula"     
#|   - "Carpinus"
#|   - "Castanea"
#|   - "Cedrus"     
#|   - "Fagus"
#|   - "Fraxinus"
#|   - "Juglans"    
#|   - "Larix"
#|   - "Picea"
#|   - "Pinus"      
#|   - "Populus"
#|   - "Prunus"
#|   - "Pseudotsuga"
#|   - "Quercus"
#|   - "Ulmus" 
#| layout-nrow: 6
#| layout-col: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

for (current_gen in ls_genus)
{
	pres_inra = FALSE
	pres_swiss = FALSE

	plot(temp[.(current_gen, "nfi"), circumference_m], temp[.(current_gen, "nfi"), bole_volume_m3], cex = 0.45,
		xlab = "Circumference (m)", ylab = "Bole volume (m³)", main = "", axes = FALSE, pch = 19, lwd = 0,
		col = colours["nfi"], xlim = c(0, max(temp[.(current_gen), circumference_m])))
	
	if (temp[.(current_gen, "inra"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "inra"), circumference_m], temp[.(current_gen, "inra"), bole_volume_m3],
			cex = 0.55, col = colours["inra"], pch = 19, lwd = 0)
		pres_inra = TRUE
	}
		
	if (temp[.(current_gen, "swiss"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "swiss"), circumference_m], temp[.(current_gen, "swiss"), bole_volume_m3],
			cex = 0.55, col = paste0(colours["swiss"], ifelse(pres_inra, "66", "FF")), pch = 19, lwd = 0)
		pres_swiss = TRUE
	}

	axis(1)
	axis(2, las = 1)

	if (pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")
	if (pres_inra && !pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI"), fill = colours[c("inra", "nfi")], bty = "n")
	if (!pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("NFI", "EFM"), fill = colours[c("nfi", "swiss")], bty = "n")
}
```

### Response plots, crown
```{r}
# --- Circumferences
dd_in = density(forest_dt[origin_data == "inra", crown_volume_m3], n = 512, from = 0, to = 0.3) # Inra/Emerge data
dd_ch = density(swiss_dt[, crown_volume_m3], n = 512, from = 0, to = 0.3) # swiss data

range(dd_in$x)
range(dd_ch$x)

range(dd_in$y)
range(dd_ch$y)

plot(dd_in, col = colours["inra"], axes = FALSE, lwd = 3, xlab = "Crown volume (m)", main = "")
polygon(c(dd_in$x, rev(dd_in$x)), c(rep(0, length(dd_in$x)), rev(dd_in$y)), col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(c(dd_ch$x, rev(dd_ch$x)), c(rep(0, length(dd_ch$x)), rev(dd_ch$y)), col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "EFM"), fill = colours[c("inra", "swiss")], bty = "n")
```

### Relation between crown and (merchantable) bole volume
```{r}

ch_inra = temp[CJ(unique(genus), c("inra", "swiss")), nomatch = 0]

plot(ch_inra[, bole_volume_m3], ch_inra[, crown_volume_m3], col = ch_inra[, colour], pch = 19, lwd = 0, axes = FALSE,
	xlab = "Bole volume", ylab = "Crown volume")
axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "EFM"), fill = colours[c("inra", "swiss")], bty = "n")

cor(ch_inra[.(unique(genus), "inra"), bole_volume_m3, nomatch = 0],
	ch_inra[.(unique(genus), "inra"), crown_volume_m3, nomatch = 0])

cor(ch_inra[.(unique(genus), "swiss"), bole_volume_m3, nomatch = 0],
	ch_inra[.(unique(genus), "swiss"), crown_volume_m3, nomatch = 0])
```
