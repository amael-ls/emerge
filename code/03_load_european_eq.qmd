---
title: "Extract European tree volume equations"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
  cache: true
bibliography: references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
---

\newcommand{\ie}{*i.e.,*}

```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(pdftools)
library(stringi)
library(tm)
```

## Introduction
A bunch of equations (230) on bole volume has been collected [@Zianis2005], and I want to extract them automatically rather than copy-paste and format...

## Load pdf
```{r}
test = pdf_text("~/work/library/Zianis2005.pdf")
# length(test) # 63 pages

dt = data.table(species = character(230), country = character(230), equation = character(230))
dt[, letters[1:7] := numeric(.N)]
params_names = letters[1:7]

counter_even = 1
counter_odd = 1

problem = FALSE

ls_country = c("Austria", "Belgium", "Croatia", "Czech Republic", "Finland", "Germany", "Iceland", "Italy",
	"Netherlands", "Norway", "Poland", "Romania", "Sweden", "UK")

for (p in 52:63)
{
	current_page = stri_split(str = test[p], regex = "\n")
	if (p %% 2 == 0) # Even pages contain the country and species
	{
		start = 1
		while(start < length(current_page[[1]]) && !stri_detect(str = current_page[[1]][start], regex = "Equation"))
			start = start + 1	
		current_page = current_page[[1]][(start + 1):length(current_page[[1]])]

		for (r in seq_along(current_page)) # r is the row, even pages
		{
			current_line = stri_split(str = current_page[r], regex = " ", simplify = TRUE)

			if (current_page[r] == "")
				next;

			if (stri_detect(str = current_line[1, 1], regex = "^[A-Z]")) # It means it is a species
			{
				sp = paste(current_line[1, 1:2], collapse = "_")
				dt[counter_even, species := sp]
			} else if (stri_detect(str = current_line[1, 1], regex = "^[[:digit:]]")) { # It means it is a country
				if (ncol(current_line) <= 1)
					next;
				cc = current_line[1, 2]
				cc = stri_replace_all_regex(cc, "\uFFFD", "") # Remove the weird character �
				if (cc == "Czech")
					cc = paste(current_line[1, 2:3], collapse = " ")
				eq = current_line[1, ncol(current_line)]
				if (!(cc %in% ls_country))
					stop("This country is unknown")
				dt[counter_even, c("species", "country", "equation") := .(sp, cc, eq)]
				counter_even = counter_even + 1
			}
		}
	} else { # Odd pages contain the parameter values
		start = 1
		while(start < length(current_page[[1]]) && !stri_detect(str = current_page[[1]][start], regex = "Parameters"))
			start = start + 1
		current_page = current_page[[1]][(start + 1):length(current_page[[1]])]

		for (r in seq_along(current_page)) # r is the row, odd pages
		{
			if (current_page[r] == "" || problem)
			{
				problem = FALSE
				next;
			}

			current_line = stri_split(str = current_page[r], regex = " ", simplify = TRUE)
			current_line = stri_split(str = current_line, regex = "\t", simplify = FALSE)
			current_line = unlist(current_line[current_line != ""])
			current_line = current_line[current_line != ""]
			current_line = stri_replace_all_regex(current_line, "\u2013", "-") # Change the En dash to hyphen (minus sign)

			if (any(stri_detect(str = current_line, regex = "\uFFFD")))
			{
				warning(paste("Problem to process the row", current_line[1], "page", p, "--> merged with next row"))
				problem = TRUE
				if (current_line[1] != counter_odd)
					warning(paste("Watch out, the counter", counter_odd, "stored in problems mismatch", current_line[1]))
				
				row_id = current_line[1]
				current_line = stri_split(str = current_page[r + 1], regex = " ", simplify = TRUE)
				current_line = stri_split(str = current_line, regex = "\t", simplify = FALSE)
				current_line = unlist(current_line[current_line != ""])
				current_line = current_line[current_line != ""]
				current_line = stri_replace_all_regex(current_line, "\u2013", "-") # Change the En dash to hyphen (minus sign)
				current_line = c(row_id, current_line)
			}

			if (length(current_line) <= 1) # That means it is the page number for instance
					next;

			if (stri_detect(str = current_line[1], regex = "^[[:digit:]]")) # It means it is a row of parameters
			{
				current_line = current_line[2:length(current_line)]
				values = as.numeric(current_line)
				dt[counter_odd, c(params_names) := as.list(values)]
				counter_odd = counter_odd + 1
			}
		}
		if (counter_even != counter_odd)
			stop("Counters mismatch!")
	}
}
```
