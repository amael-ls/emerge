---
title: "Extract European tree volume equations from @Zianis2005"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
  cache: true
bibliography: references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
---

\newcommand{\ie}{*i.e.,*}

```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(pdftools)
library(stringi)
library(tm)
```

## Introduction
A bunch of equations (230) on bole volume has been collected [@Zianis2005], and I want to extract them automatically rather than copy-paste and format...

## Extract equations and parameters from the pdf
In this section I extract the species/country-specific equations and parameters from the pdf. The equations are in appendix C @Zianis2005 (pp. 52--63).

```{r}
pdf_file = pdf_text("~/work/library/Zianis2005.pdf")

dt = data.table(species = character(230), country = character(230), equation = character(230))
dt[, letters[1:7] := numeric(.N)]
params_names = letters[1:7]

counter_even = 1
counter_odd = 1

problem = FALSE

ls_country = c("Austria", "Belgium", "Croatia", "Czech Republic", "Finland", "Germany", "Iceland", "Italy",
	"Netherlands", "Norway", "Poland", "Romania", "Sweden", "UK")

for (p in 52:63)
{
	current_page = stri_split(str = pdf_file[p], regex = "\n")
	if (p %% 2 == 0) # Even pages contain the country and species
	{
		start = 1
		while(start < length(current_page[[1]]) && !stri_detect(str = current_page[[1]][start], regex = "Equation"))
			start = start + 1	
		current_page = current_page[[1]][(start + 1):length(current_page[[1]])]

		for (r in seq_along(current_page)) # r is the row, even pages
		{
			current_line = stri_split(str = current_page[r], regex = " ", simplify = TRUE)

			if (current_page[r] == "")
				next;

			if (stri_detect(str = current_line[1, 1], regex = "^[A-Z]")) # It means it is a species
			{
				sp = paste(current_line[1, 1:2], collapse = "_")
				dt[counter_even, species := sp]
			} else if (stri_detect(str = current_line[1, 1], regex = "^[[:digit:]]")) { # It means it is a country
				if (ncol(current_line) <= 1)
					next;
				cc = current_line[1, 2]
				cc = stri_replace_all_regex(cc, "\uFFFD", "") # Remove the weird character �
				if (cc == "Czech")
					cc = paste(current_line[1, 2:3], collapse = " ")
				eq = current_line[1, ncol(current_line)]
				if (!(cc %in% ls_country))
					stop("This country is unknown")
				dt[counter_even, c("species", "country", "equation") := .(sp, cc, eq)]
				counter_even = counter_even + 1
			}
		}
	} else { # Odd pages contain the parameter values
		start = 1
		while(start < length(current_page[[1]]) && !stri_detect(str = current_page[[1]][start], regex = "Parameters"))
			start = start + 1
		current_page = current_page[[1]][(start + 1):length(current_page[[1]])]

		for (r in seq_along(current_page)) # r is the row, odd pages
		{
			if (current_page[r] == "" || problem)
			{
				problem = FALSE
				next;
			}

			current_line = stri_split(str = current_page[r], regex = " ", simplify = TRUE)
			current_line = stri_split(str = current_line, regex = "\t", simplify = FALSE)
			current_line = unlist(current_line[current_line != ""])
			current_line = current_line[current_line != ""]
			current_line = stri_replace_all_regex(current_line, "\u2013", "-") # Change the En dash to hyphen (minus sign)

			if (any(stri_detect(str = current_line, regex = "\uFFFD")))
			{
				warning(paste("Problem to process the row", current_line[1], "page", p, "--> merged with next row"))
				problem = TRUE
				if (current_line[1] != counter_odd)
					warning(paste("Watch out, the counter", counter_odd, "stored in problems mismatch", current_line[1]))
				
				row_id = current_line[1]
				current_line = stri_split(str = current_page[r + 1], regex = " ", simplify = TRUE)
				current_line = stri_split(str = current_line, regex = "\t", simplify = FALSE)
				current_line = unlist(current_line[current_line != ""])
				current_line = current_line[current_line != ""]
				current_line = stri_replace_all_regex(current_line, "\u2013", "-") # Change the En dash to hyphen (minus sign)
				current_line = c(row_id, current_line)
			}

			if (length(current_line) <= 1) # That means it is the page number for instance
					next;

			if (stri_detect(str = current_line[1], regex = "^[[:digit:]]")) # It means it is a row of parameters
			{
				current_line = current_line[2:length(current_line)]
				values = as.numeric(current_line)
				dt[counter_odd, c(params_names) := as.list(values)]
				counter_odd = counter_odd + 1
			}
		}
		if (counter_even != counter_odd)
			stop("Counters mismatch!")
	}
}
```

## Correcting some errors
It seems that there are some errors in @Zianis2005. For instance, equations 5 and 6 clearly miss one closing parenthesis. I assume this parenthesis is at the end of the equation, since equation 45 or 82, or ... (also coming from Austria) have an extra parenthesis at the end.

```{r}
dt[5, equation := paste0(equation, ")")]
dt[6, equation := paste0(equation, ")")]
```
## Transform the equations (class char) to R functions

```{r}
create_function = function(equation)
{
	equation = gsub("·", "*", equation) # Replace · with *
	
	equation = gsub("([A-Z])([0-9]+)", "\\1^\\2", equation) # Replace Xn with X^n, n an integer
	equation = gsub("([A-Z)])([0-9]+)", "\\1^\\2", equation) # Replace ...X)n with ...X)^n, n an integer
	equation = gsub("([A-Z])([a-z]+)", "\\1^\\2", equation) # Replace Xb with X^b, b a parameter
	equation = gsub("([A-Z)])([a-z]+)", "\\1^\\2", equation) # Replace ...X)b with ...X)^b, b a parameter
	equation = gsub("(\\^\\d)([A-Z])", "\\1*\\2", equation) # Replace ...^nX with ...^n*X, n an integer; no change for 10a

	equation = gsub("\u03C0", "pi", equation) # Replace π with pi

	equation = gsub("log", "log10", equation) # Replace log with log10 (see in the article)
	equation = gsub("ln", "log", equation) # Replace ln with log (see in the article)
	
	equation = gsub("(\\d)\\(", "\\1^(", equation)  # Replace 10(...) by 10^(...), I have only seen power
	equation = gsub("(10)([a-z])", "\\1^\\2", equation)  # Replace 10a by 10^a, I have only seen power
	
	equation = gsub("\u2013", "-", equation)  # Replace en dash by minus sign
	
	expr = paste0("function(a, b, c, d, e, f, g, H, D) {return(", equation, ")}") # Convert string into R fct
	return(eval(parse(text = expr)))
}

# qq = copy(dt)
# dt = copy(qq)

for (i in 1:230)
	fct = create_function(dt[i, equation])

dt[, test := lapply(equation, create_function)]

dt[1, test[[1]](a, b, c, d, e, f, g, H = 8, D = 9)]
dt[4, test[[1]](a, b, c, d, e, f, g, H = 8, D = 9)]
```