---
title: "Hierachical models"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
  warning: false
  message: false
bibliography: /home/ALe-Squin/work/library/bib_file/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\Vcro}{V_{\text{crown}}}
\newcommand{\Vtot}{V_{\text{tot}}}
\newcommand{\hdec}{h_{\text{tap}}}
\newcommand{\ddec}{\phi_{\text{tap}}}

\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\E}{\mathds{E}}

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
library(DHARMa)
library(interp)
library(gt)

## Tool function
source("./toolFunctions.R")
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra", opt, ".rds"))
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra", opt, ".rds"))

colours = paste0(met.brewer("Egypt")[1:4])
names(colours) = c("conifer", "broadleaf", "inra", "nfi")

forest_dt[fct_type == "broadleaf", fct_colour := colours["broadleaf"]]
forest_dt[fct_type == "conifer", fct_colour := colours["conifer"]]
forest_dt[origin_data == "inra", origin_colour := colours["inra"]]
forest_dt[origin_data == "nfi", origin_colour := colours["nfi"]]

setkey(forest_dt, origin_data, fct_type)

forest_dt[.("inra", "broadleaf"), origin_fct_colour := paste0(colours["nfi"], "FF")]
forest_dt[.("inra", "conifer"), origin_fct_colour := paste0(colours["inra"], "AA")]
forest_dt[.("nfi", "broadleaf"), origin_fct_colour := paste0(colours["broadleaf"], "88")]
forest_dt[.("nfi", "conifer"), origin_fct_colour := paste0(colours["conifer"], "55")]

dt_hull = unique(forest_dt[, .(scaled_c = (circumference_m - mean(circumference_m))/sd(circumference_m),
	scaled_h = (height - mean(height))/sd(height), origin_fct_colour), by = .(origin_data, fct_type)])

## Subset data
inra = forest_dt["inra"]
inra = inra[, n_indiv := .N, by = speciesName_sci]
inra = inra[n_indiv > 50]

inra[, ratio := bole_volume_m3/total_volume_m3]
inra[, hdn := sqrt(circumference_m)/height]

setkey(inra, speciesName_sci)
ls_species = inra[, unique(speciesName_sci)]

nfi = forest_dt["nfi"]
nfi = nfi[, n_indiv := .N, by = speciesName_sci]
nfi = nfi[n_indiv > 5000]
```

## Exploration on the 'stability' of total volume *v.s.* bole volume

C. Deleuze claims that the total volume is 'more stable' than the bole volume. By more stable, I understand that there is less variability in total volume for a given couple of height--circumference. I doubt about this claim, and think that this is an artefact from the Emerge dataset itself. The NFI is exhaustive both geographically and in terms of monitored trees, while Emerge mostly has slendered trees (as can be seen in `01_prepare_data.qmd`), especially for *Fagus* and *Picea*.

So, in the next figures, I plot heatmaps of bole volume, total volume, and the ratio bole of total in the circumference--height space. If there is no difference, we should see similar figures between bole and total volume, while the ratio should be evenly distributed in the space once the 'threshold' of small trees passed (for which the ratio is quite deterministic).

```{r}
#| label: fig-results_simple
#| fig-cap: Correlation between the bole volume and the total volume
#| fig-subcap:
#|   - "Abies alba, bole vol"
#|   - "Abies alba, tot vol"
#|   - "Abies alba, ratio"
#|   - "Carpinus betulus, bole vol"
#|   - "Carpinus betulus, tot vol"
#|   - "Carpinus betulus, ratio"
#|   - "Cedrus atlantica, bole vol"
#|   - "Cedrus atlantica, tot vol"
#|   - "Cedrus atlantica, ratio"
#|   - "Fagus sylvatica, bole vol"
#|   - "Fagus sylvatica, tot vol"
#|   - "Fagus sylvatica, ratio"
#|   - "Fraxinus excelsior, bole vol"
#|   - "Fraxinus excelsior, tot vol"
#|   - "Fraxinus excelsior, ratio"
#|   - "Larix decidua, bole vol"
#|   - "Larix decidua, tot vol"
#|   - "Larix decidua, ratio"
#|   - "Picea abies, bole vol"
#|   - "Picea abies, tot vol"
#|   - "Picea abies, ratio"
#|   - "Pinus halepensis, bole vol"
#|   - "Pinus halepensis, tot vol"
#|   - "Pinus halepensis, ratio"
#|   - "Pinus laricio, bole vol"
#|   - "Pinus laricio, tot vol"
#|   - "Pinus laricio, ratio"
#|   - "Pinus nigra, bole vol"
#|   - "Pinus nigra, tot vol"
#|   - "Pinus nigra, ratio"
#|   - "Pinus pinaster, bole vol"
#|   - "Pinus pinaster, tot vol"
#|   - "Pinus pinaster, ratio"
#|   - "Pinus sylvestris, bole vol"
#|   - "Pinus sylvestris, tot vol"
#|   - "Pinus sylvestris, ratio"
#|   - "Pinus uncinata, bole vol"
#|   - "Pinus uncinata, tot vol"
#|   - "Pinus uncinata, ratio"
#|   - "Pseudotsuga menziesii, bole vol"
#|   - "Pseudotsuga menziesii, tot vol"
#|   - "Pseudotsuga menziesii, ratio"
#|   - "Quercus petraea, bole vol"
#|   - "Quercus petraea, tot vol"
#|   - "Quercus petraea, ratio"
#|   - "Quercus rubra, bole vol"
#|   - "Quercus rubra, tot vol"
#|   - "Quercus rubra, ratio"
#|   - "Quercus sp., bole vol"
#|   - "Quercus sp., tot vol"
#|   - "Quercus sp., ratio"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 6
#| layout-ncol: 3
#| output: true

forest_dt_heatmap = unique(inra[, .(speciesName_sci, circumference_m, height,
	bole_volume_m3, total_volume_m3, ratio)], by = c("speciesName_sci", "circumference_m", "height"))

# Heatmap of bole volume (trunk, from base to diameter = 7 cm)
for (current_sp in ls_species)
{
	si = interp(x = forest_dt_heatmap[current_sp, circumference_m], y = forest_dt_heatmap[current_sp, height],
		z = forest_dt_heatmap[current_sp, bole_volume_m3], method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Circumference", ylab = "Height", frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)

	# Heatmap of total volume
	si = interp(x = forest_dt_heatmap[current_sp, circumference_m], y = forest_dt_heatmap[current_sp, height],
		z = forest_dt_heatmap[current_sp, total_volume_m3], method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Circumference", ylab = "Height", frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)

	# Heatmap of ratio
	si = interp(x = forest_dt_heatmap[current_sp, circumference_m], y = forest_dt_heatmap[current_sp, height],
		z = forest_dt_heatmap[current_sp, ratio], method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Circumference", ylab = "Height", frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)
}

rm(forest_dt_heatmap)
```

Out of curiosity, I also 'replicate' the Fig. 2 of @Jucker2025 for my own study, with the height of trees, $h$, and their circumference, $c$. Both are standardised.

```{r}
#| label: fig-jucker2025
#| fig-cap: "Figure inspired by @Jucker2025"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 6

plot(dt_hull[, scaled_c], dt_hull[, scaled_h], axes = FALSE, xlab = "Circumference (m)", ylab = "Height (m)",
	pch = 20, col = dt_hull[, origin_fct_colour], xlim = c(-3, 10), ylim = c(-3, 5), lwd = 0)
axis(1)
axis(2, las = 1)
abline(h = 0, lty = 2, cex = 0.8, col = "#57895758")
abline(v = 0, lty = 2, cex = 0.8, col = "#57895758")

legend(x = "topleft", legend = c("nfi-conif", "nfi-broad", "inra-conif", "inra-broad"),
	fill = colours, bty = "n", cex = 1.25)
```

```{r}
#| label: fig-jucker2025_hull
#| fig-cap: "Figure inspired by @Jucker2025 using alpha convex hull"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 6

epsilon = 1e-5

min_dt_hull = dt_hull[, .(min_scaled_c = min(scaled_c)), by = .(origin_data, fct_type)]

dt_hull[origin_data == "nfi" & fct_type == "broadleaf" & scaled_c == min_dt_hull[.("nfi", "broadleaf"), min_scaled_c],
	scaled_c := scaled_c + runif(.N, 0, epsilon)] # Hull problem because vertical line at min(dbh)

dt_hull[origin_data == "nfi" & fct_type == "conifer" & scaled_c == min_dt_hull[.("nfi", "conifer"), min_scaled_c],
	scaled_c := scaled_c + runif(.N, 0, epsilon)] # Hull problem because vertical line at min(dbh)

a1 = alphahull::ahull(x = dt_hull[.("inra", "broadleaf"), .(scaled_c, scaled_h)],
	alpha = 5)
a2 = alphahull::ahull(x = dt_hull[.("inra", "conifer"), .(scaled_c, scaled_h)],
	alpha = 5)
a3 = alphahull::ahull(x = dt_hull[.("nfi", "broadleaf"), .(scaled_c, scaled_h)],
	alpha = 5)
a4 = alphahull::ahull(x = dt_hull[.("nfi", "conifer"), .(scaled_c, scaled_h)],
	alpha = 5)

plot(NA, NA, xlim = c(-3, 10), ylim = c(-3, 5), xlab = "Circumference (m)", ylab = "Height (m)", axes = FALSE)

plot(a1, col = colours["nfi"], add = TRUE, wpoints = FALSE, lwd = 4)
plot(a2, col = colours["inra"], add = TRUE, wpoints = FALSE, lwd = 4)
plot(a3, col = colours["broadleaf"], add = TRUE, wpoints = FALSE, lwd = 4)
plot(a4, col = colours["conifer"], add = TRUE, wpoints = FALSE, lwd = 4)

axis(1)
axis(2, las = 1)
abline(h = 0, lty = 2, cex = 0.8, col = "#57895758")
abline(v = 0, lty = 2, cex = 0.8, col = "#57895758")

legend(x = "topleft", legend = c("nfi-conif", "nfi-broad", "inra-conif", "inra-broad"),
	fill = colours, bty = "n", cex = 1.25)
```

Finally, here are the variances of both bole and total volume per species and per class of circumference. As can be seen, we cannot claim that one volume is more stable than the other...

::: {.callout-note collapse=true}

## Overview of the data

```{r}
inra[, class_circumference := as.numeric(cut(circumference_m, breaks = 4)), by = speciesName_sci]
inra[, .(n_indiv = .N, var_tot = var(total_volume_m3), var_bole = var(bole_volume_m3)),
	by = .(speciesName_sci, class_circumference)][order(speciesName_sci, class_circumference)] |>
	gt() |>
	cols_label(
		speciesName_sci = "Species",
		class_circumference = "Circ. class",
		n_indiv = "N indiv.",
		var_tot = "Var(tot vol)",
		var_bole = "Var(bole vol)"
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = speciesName_sci)
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(align = "right")),
		locations = cells_body(columns = class_circumference)
	) |>
	fmt_number(
		columns = starts_with("var_"),
		decimals = 2
	)

## This shows that I can just compare the variances as they both follow the same law:
# ceil_halfway = function(x)
# 	return (ceiling(x * 2) / 2)

# xx = inra[speciesName_sci == "Fagus sylvatica", total_volume_m3]
# yy = inra[speciesName_sci == "Fagus sylvatica", bole_volume_m3]

# hist(xx, breaks = seq(0, ceil_halfway(max(xx)), by = 0.1), prob = TRUE)
# mm = mean(xx)
# vv = var(xx)
# curve(dgamma(x, shape = mm^2/vv, rate = mm/vv), lwd = 2, col = "#CD212A", add = TRUE)

# hist(yy, breaks = seq(0, ceil_halfway(max(yy)), by = 0.1), prob = TRUE)
# mm = mean(yy)
# vv = var(yy)
# curve(dgamma(x, shape = mm^2/vv, rate = mm/vv), lwd = 2, col = "#CD212A", add = TRUE)
```

:::

As a conclusion, the two volumes are as 'stable' or messy as each other!

## A first not so simple joined model

WHAT FOLLOWS IN THIS SECTION IS OUT OF DATE! I AM EVEN NOT DOING A JOINED MODEL HERE. GO TO NEXT SECTION FOR FIRST TRIAL.

This model is based on the ratio developed in `06_zhou.qmd` for the total volume, $\Vtot$. For $\Vbft$, I explore few relations between the taper diameter, $\ddec$, and taper height, $\hdec$.

### Heatmaps $\ddec$, $\hdec$, and $\Vbft$

```{r}
forest_dt_heatmap = unique(nfi[!is.na(taper_diameter), .(speciesName_sci, taper_diameter, taper_height,
	bole_volume_m3)], by = c("speciesName_sci", "taper_diameter", "taper_height"))

forest_dt_heatmap2 = unique(nfi[, .(speciesName_sci, circumference_m, height,
	bole_volume_m3)], by = c("speciesName_sci", "circumference_m", "height"))

setkey(forest_dt_heatmap, speciesName_sci)
setkey(forest_dt_heatmap2, speciesName_sci)

# Heatmap of bole volume (trunk, from base to diameter = 7 cm)
for (current_sp in forest_dt_heatmap[, unique(speciesName_sci)])
{
	si = interp(x = forest_dt_heatmap[current_sp, taper_diameter], y = forest_dt_heatmap[current_sp, taper_height],
		z = forest_dt_heatmap[current_sp, bole_volume_m3], method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Taper diametre", ylab = "Taper height", main = current_sp, frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)

	si = interp(x = forest_dt_heatmap2[current_sp, circumference_m], y = forest_dt_heatmap2[current_sp, height],
		z = forest_dt_heatmap2[current_sp, bole_volume_m3], method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Circumference", ylab = "Height", main = current_sp, frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)
}

rm(forest_dt_heatmap)
```

THE NEXT PIECE OF CODE IS CURRENTLY NOT EVALUATED

```{r}
#| eval: false

model = cmdstan_model("./temp.stan")

current_sp = "Fagus sylvatica" # "Pinus nigra"
test = nfi[speciesName_sci == current_sp] #[sample(x = seq_len(.N), size = 500)]

stanData = list(
	N = test[, .N],

	circumference_m = test[, circumference_m],
	height = test[, height],
	taper_height = test[, taper_height],

	taper_volume_m3 = test[, bole_volume_m3]
)

n_chains = 4

filename = paste0("./fit_taperVol_", stri_replace(current_sp, regex = " ", replacement = "-"), ".rds")

if (!file.exists(filename))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)
	fit$save_output_files(dir = "./", basename = paste0("fit_tapperVol"), random = FALSE)
	saveRDS(fit, filename)
} else {
	fit = readRDS(filename)
}

# lazyTrace(fit$draws("max_potential_v_taper"), main = "potential taper volume")
# lazyTrace(fit$draws("rho"), main = "rho")
# lazyTrace(fit$draws("loc_circum"), main = "loc circum")
# lazyTrace(fit$draws("disp_circum"), main = "disp circum")
# lazyTrace(fit$draws("loc_height"), main = "loc height")
# lazyTrace(fit$draws("disp_height"), main = "disp height")

lazyTrace(fit$draws("beta0"), main = "beta 0")
lazyTrace(fit$draws("beta1"), main = "beta 1")
lazyTrace(fit$draws("beta2"), main = "beta 2")
lazyTrace(fit$draws("sigma"), main = "sigma")

lazyPosterior(fit$draws("sigma"), main = "sigma", fun = dgamma, shape = 0.1, rate = 0.1)

# lazyTrace(fit$draws("alpha"), main = "alpha")
# lazyTrace(fit$draws("beta_"), main = "beta")

sim = apply(X = fit$draws("taper_vol_gen"), MARGIN = 3, FUN = mean)

sigma = apply(X = fit$draws("sigma"), MARGIN = 3, FUN = mean)


tt = which(stanData$taper_volume_m3 < 7) # 1
qq = which(sim > 12) # 2.5

cc = qq[qq %in% tt]

test[cc]

png("bourrin.png")
plot(stanData$taper_volume_m3, sim, pch = 19, lwd = 0)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
abline(lm(sim ~ stanData$taper_volume_m3), col = "#FAB255", lwd = 2)
points(stanData$taper_volume_m3[cc], sim[cc], pch = 4, col = "#0F7BA2", cex = 2, lwd = 3)
dev.off()



#### Heatmap with weird point
## Heatmap circum/height
si = interp(x = forest_dt_heatmap2[current_sp, circumference_m], y = forest_dt_heatmap2[current_sp, height],
	z = forest_dt_heatmap2[current_sp, bole_volume_m3], method = "linear", duplicate = "mean")

filled.contour(si,
	plot.axes = {
		axis(1)
		axis(2, las = 1)
		contour(si, add = TRUE, lwd = 2, axes = NULL)
	}, xlab = "Circumference", ylab = "Height", main = current_sp, frame.plot = FALSE,
	color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
)
points(x = nfi[speciesName_sci == current_sp][cc, circumference_m], y = nfi[speciesName_sci == current_sp][cc, height], pch = 4, col = "#CD212A", cex = 2, lwd = 3)

## Heatmap taper circum/height
si = interp(x = forest_dt_heatmap[current_sp, taper_diameter], y = forest_dt_heatmap[current_sp, taper_height],
	z = forest_dt_heatmap[current_sp, bole_volume_m3], method = "linear", duplicate = "mean")

filled.contour(si,
	plot.axes = {
		axis(1)
		axis(2, las = 1)
		contour(si, add = TRUE, lwd = 2, axes = NULL)
	}, xlab = "Taper diametre", ylab = "Taper height", main = current_sp, frame.plot = FALSE,
	color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
)
points(x = nfi[speciesName_sci == current_sp][cc, taper_diameter], y = nfi[speciesName_sci == current_sp][cc, taper_height], pch = 4, col = "#CD212A", cex = 2, lwd = 3)

#### Other stuff
plot(stanData$taper_volume_m3, sigma, pch = 19, lwd = 0)

aa = lm(stanData$taper_volume_m3 ~ I(stanData$circumference_m^2*stanData$height))
plot(stanData$circumference_m^2*stanData$height, stanData$taper_volume_m3, pch = 19, lwd = 0)
abline(aa, lwd = 2, col = "#CD212A")

si = interp(x = stanData$circumference_m, y = stanData$height,
	z = sim, method = "linear", duplicate = "mean")

filled.contour(si,
	plot.axes = {
		axis(1)
		axis(2, las = 1)
		contour(si, add = TRUE, lwd = 2, axes = NULL)
	}, xlab = "Circumference", ylab = "Height", main = "Pinus nigra (sim)", frame.plot = FALSE,
	color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
)



#### Residuals
n_sampling = fit$metadata()$iter_sampling

simResp = fit$draws("taper_vol_gen")
dim(simResp)
if (dim(simResp)[2]  != n_chains)# Number of successful chains
	stop("The number of successful chains is not equal to n_chains")

# Reshape simResp as a matrix nobs x n_repetition
simResp_matrix = matrix(data = 0, nrow = length(stanData$taper_volume_m3), ncol = n_sampling*n_chains)
for (obs in seq_len(length(stanData$taper_volume_m3)))
	for (chain in 1:n_chains)
		simResp_matrix[obs, ] = simResp[, chain, obs] # One line of n_sampling*n_chains simulations per observation

## Simulated residuals
sim_dharma = createDHARMa(simulatedResponse = simResp_matrix,
	observedResponse = stanData$taper_volume_m3,
	fittedPredictedResponse = apply(simResp, MARGIN = 3, median),
	integerResponse = FALSE)

plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, stanData$circumference_m, quantreg = TRUE)
plotResiduals(sim_dharma, stanData$height, quantreg = TRUE)

plot(log(stanData$circumference_m), log(stanData$taper_volume_m3))




si = interp(x = forest_dt_heatmap2[current_sp, log(circumference_m)], y = forest_dt_heatmap2[current_sp, log(height)],
		z = forest_dt_heatmap2[current_sp, log(bole_volume_m3)], method = "linear", duplicate = "mean")

filled.contour(si,
	plot.axes = {
		axis(1)
		axis(2, las = 1)
		contour(si, add = TRUE, lwd = 2, axes = NULL)
	}, xlab = "Circumference", ylab = "Height", main = current_sp, frame.plot = FALSE,
	color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
)

# met.brewer("Egypt")[1:4]
# [1] "#dd5129" "#0f7ba2" "#43b284" "#fab255"


```

## Joined model fake data

In this section, I create a dataset and fit the joined model that I want to use later on real data. This way I can verify that the model is capturing what is desired.

The parameters (to estimate later by our model) are defined as below:
```{r}
#### Parameters
mu_logit_r = 1.386 # Mean logit(ratio)
mu_log_v = -1.194 # Mean total volume

sigma_logit_r = 0.5625 # Std. dev. logit(ratio)
sigma_log_v = 1.25 # Std. dev. total volume. Not ideal but larger makes it too fat-tailed compared to real distrib

rho = 0.22 # Covariance between logit(ratio) and log(total volume)

#### Var-Cov matrix
sigma_mat = diag(c(sigma_logit_r, sigma_log_v))
rho_mat = matrix(c(1, rho, rho, 1), nrow = 2, ncol = 2)

varCov_mat = sigma_mat %*% rho_mat %*% sigma_mat

#### Other variables
n_sim = 2e3
```

```{r}
#### Create data following our model (intercepts only, with corrleation in the residuals)
set.seed(1969 - 08 - 18) # Woodstock seed
data = as.data.table(MASS::mvrnorm(n_sim, c(mu_logit_r, mu_log_v), varCov_mat))
setnames(data, c("logit_r", "log_v"))

inv_logit = function(x)
	return (1 / (1 + exp(-x)))

stanData = list(
	N = data[, .N],
	p = data[, inv_logit(logit_r)],
	total_volume_m3 = data[, exp(log_v)]
)

model = cmdstan_model("./temp_joined.stan")

n_chains = 4

fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

mean(fit$draws("mu_p"))
mean(fit$draws("mu_v"))

lazyPosterior(fit$draws("mu_p"), val1 = mu_logit_r)
lazyPosterior(fit$draws("mu_v"), val1 = mu_log_v)
lazyPosterior(fit$draws("rho"), val1 = rho)

lazyPosterior(fit$draws("sigma_p"), val1 = sigma_logit_r)
lazyPosterior(fit$draws("sigma_v"), val1 = sigma_log_v)

varCov_mat_est = matrix(data = apply(X = fit$draws("Sigma"), FUN = mean, MARGIN = 3), nrow = 2, byrow = 2)

round(varCov_mat, 2)
round(varCov_mat_est, 2)

## FIT 2 WITHOUT CORR IN MODEL
model2 = cmdstan_model("./help.stan")
fit2 = model2$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

lazyPosterior(fit2$draws("mu_p"), val1 = mu_logit_r)
lazyPosterior(fit2$draws("mu_v"), val1 = mu_log_v)

lazyPosterior(fit2$draws("sigma_p"), val1 = sigma_logit_r)
lazyPosterior(fit2$draws("sigma_v"), val1 = sigma_log_v)
```

## Joined model ratio and total volume

I here try a first joined model on $\Vtot$ and the ratio of $\Vbft$ over $\Vtot$, that is to say the proportion of trunk in the total volume. This was simulated in `06_zhou.qmd` with a rather flexible but complexe function and a beta distribution. I cannot do that here, except if I use copulas, as $\Vtot$ does not follow a beta distribution! I am therefore limited to multivariate normal, gamma, lognormal, and so on...

I will use two transformations in order to be able to use a MVN distribution:

- A `logit` on the proportion (as it is never 0 nor 1)
- A log on $\Vtot$ to also put it on $\mathds{R}$ rather than $\mathds{R}^{+}$

::: {.callout-note}

## Intractibility

Note that whatever I try to model, there will always be intractability somewhere! Either I model both components, trunk and crown, with a multivariate lognormal, and the total volume is untractable (sum of two lognormals), or I model the trunk volume, $\Vtot$ and the ratio, $r$, and $\Vbft$ is untractable. Indeed:

$$
\begin{aligned}
	\E[\Vbft] &= \E[r \Vtot] \\
	\E[\Vbft] &= \E[r] \E[\Vtot] + \Cov[r, \Vtot]
\end{aligned}
$$

and similar stuff for the variance. In any case, I will not have the distribution...

:::

```{r}
# plot(inra$total_volume_m3, inra$bole_volume_m3/inra$total_volume_m3, pch = 19, cex = 0.75)

p = inra["Fagus sylvatica", bole_volume_m3]/inra["Fagus sylvatica", total_volume_m3]

plot(inra["Fagus sylvatica", circumference_m], log(p/(1 - p)), pch = 19, cex = 0.75, axes = FALSE,
	xlab = "Circumference (m)", ylab = "logit(p)")
axis(1)
axis(2, las = 1)

plot(inra["Fagus sylvatica", class_circumference], log(p/(1 - p)), pch = 19, cex = 0.75, axes = FALSE,
	xlab = "Class circumference", ylab = "logit(p)")
axis(1)
axis(2, las = 1)

plot(inra["Fagus sylvatica", circumference_m^2*height], log(p/(1 - p)), pch = 19, cex = 0.75, axes = FALSE,
	xlab = "Cylinder volume", ylab = "logit(p)")
axis(1)
axis(2, las = 1)
```

```{r}
model = cmdstan_model("./temp_joined.stan")

stanData = list(
	N = inra["Fagus sylvatica", .N],
	p = inra["Fagus sylvatica", ratio],
	total_volume_m3 = inra["Fagus sylvatica", total_volume_m3]
)

n_chains = 4

fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

mean(fit$draws("rho"))

lazyPosterior(fit$draws("rho"))
```

## Joined model taper and crown volumes

### Fake data
```{r}

Vbft = inra["Fagus sylvatica", bole_volume_m3]
Vtot = inra["Fagus sylvatica", total_volume_m3]
Vcro = inra["Fagus sylvatica", crown_volume_m3]

#### Parameters
mu_tap = 0.54 # Mean taper vol
mu_cro = 0.18 # Mean crown volume

var_tap = 0.5 # Var taper volume
var_cro = 0.12 # Var crown volume

rho = 0.2 # Covariance between logit(ratio) and log(total volume)

plot(density(Vbft))
curve(dgamma(x, shape = mu_tap^2/var_tap, rate = mu_tap/var_tap), add = TRUE, col = "#CD212A", lwd = 2)

plot(density(Vcro))
curve(dgamma(x, shape = mu_cro^2/var_cro, rate = mu_cro/var_cro), add = TRUE, col = "#CD212A", lwd = 2)

#### Var-Cov matrix
sigma_mat = diag(c(sqrt(var_tap), sqrt(var_cro)))
rho_mat = matrix(c(1, rho, rho, 1), nrow = 2, ncol = 2)

varCov_mat = sigma_mat %*% rho_mat %*% sigma_mat

#### Other variables
n_sim = 2e3
```

```{r}
#### Create data following our model (intercepts only, with corrleation in the residuals)
set.seed(1969 - 08 - 18) # Woodstock seed
data = as.data.table(MASS::mvrnorm(n_sim, c(mu_logit_r, mu_log_v), varCov_mat))
setnames(data, c("logit_r", "log_v"))

inv_logit = function(x)
	return (1 / (1 + exp(-x)))

stanData = list(
	N = data[, .N],
	p = data[, inv_logit(logit_r)],
	total_volume_m3 = data[, exp(log_v)]
)

model = cmdstan_model("./temp_joined.stan")

n_chains = 4

fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)
```

## Et continue le bordel! Faut réorganiser
```{r}
inra[, logit_ratio := log(ratio/(1 - ratio))]
inra[, logit_ratio := log(ratio/(1 - ratio))]

## Fagus sylvatica
for (selectedSpecies in ls_species[c(1, 4, 11, 12, 15)])
{
	plot(inra[selectedSpecies, circumference_m], inra[selectedSpecies, ratio], pch = 19,
		axes = FALSE, xlab = "Circumference", ylab = "ratio", main = selectedSpecies, col = "#0F7BA2")
	axis(1)
	axis(2, las = 1)

	plot(inra[selectedSpecies, circumference_m], inra[selectedSpecies, logit_ratio], pch = 19,
		axes = FALSE, xlab = "Circumference", ylab = "logit(ratio)", main = selectedSpecies, col = "#43B284")
	axis(1)
	axis(2, las = 1)

	plot(inra[selectedSpecies, log(circumference_m)], inra[selectedSpecies, logit_ratio], pch = 19,
		axes = FALSE, xlab = "log(Circumference)", ylab = "logit(ratio)", main = selectedSpecies, col = "#FAB255")
	axis(1)
	axis(2, las = 1)
}

model = cmdstan_model("./temp_joined_experience.stan")

stanData = list(
	N = inra["Fagus sylvatica"][, .N],
	circumference_m = inra["Fagus sylvatica"][, circumference_m],
	p = inra["Fagus sylvatica"][, ratio],
	total_volume_m3 = inra["Fagus sylvatica"][, total_volume_m3]
)

n_chains = 4

fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)
```

```{r}
mean(fit$draws("rho"))

varCov_mat_est = matrix(data = apply(X = fit$draws("Sigma"), FUN = mean, MARGIN = 3), nrow = 2, byrow = 2)

round(varCov_mat_est, 3)

pred = fit$draws("pred_Vbole")
quant = apply(X = pred, MARGIN = 3, FUN = quantile, probs = c(0.05, 0.95))

pred_avg = apply(X = pred, MARGIN = 3, FUN = mean)

plot(inra["Fagus sylvatica", bole_volume_m3], pred_avg, pch = 19, axes = FALSE,
	xlab = "Observed", ylab = "Predicted")
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#FAB255", lwd = 3)
```

## Bibliography {.unnumbered}

::: {#refs}
:::
