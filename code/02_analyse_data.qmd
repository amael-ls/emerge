---
title: "Analyse data to estimate volumes"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
  cache: true
bibliography: references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    keep-tex: true
    pdf-engine: lualatex
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

\newcommand{\ie}{*i.e.,*}
\newcommand{\F}{\mathscr{F}}
\newcommand{\N}{\mathbfscr{N}}
\newcommand{\logN}{log\mathbfscr{N}}

\newcommand{\vtot}{v_{\text{tot}}}
\newcommand{\vbole}{v_{\text{bole}}}
\newcommand{\vbr}{v_{\text{branches}}}

```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(rootSolve)
library(bayesplot)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
```

## Introduction
The data have been prepared in `01_prepare_data.qmd`. In this document, I fit a model on both INRA and French NFI data. In this section, I explore the data, and in the next section I define the model. Lastly  I explore few results.

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra.rds"))
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt.rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra.rds"))

colours = paste0(met.brewer("Egypt")[1:4])
names(colours) = c("conifer", "broadleaf", "inra", "nfi")

forest_dt[fct_type == "broadleaf", fct_colour := colours["broadleaf"]]
forest_dt[fct_type == "conifer", fct_colour := colours["conifer"]]
forest_dt[origin_data == "inra", origin_colour := colours["inra"]]
forest_dt[origin_data == "nfi", origin_colour := colours["nfi"]]
```

```{r}
#| echo: false
#| label: fig-explore_data
#| fig-cap: "Explore the data"
#| fig-subcap: 
#|   - "Bole"
#|   - "Crown"
#| layout-ncol: 2
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

plot(forest_dt[, log(circumference_m)], forest_dt[, log(bole_volume_m3)], col = forest_dt[, fct_colour], pch = 19,
	xlab = "Circumference", ylab = "Bole volume")
legend(x = "topright", legend = c("Broadleaf", "Conifer"), fill = colours[c("broadleaf", "conifer")])

plot(forest_dt[!is.na(crown_volume_m3), log(circumference_m)], forest_dt[!is.na(crown_volume_m3), log(crown_volume_m3)],
	col = forest_dt[!is.na(crown_volume_m3), fct_colour], pch = 19, xlab = "Circumference", ylab = "Crown volume")
legend(x = "topright", legend = c("Broadleaf", "Conifer"), fill = colours[c("broadleaf", "conifer")])
```

## Methods
I first try a simple model:
$$
\vtot = \vbole + \vbr
$$
where the bole volume, $\vbole$, and the branch volume, $\vbr$, both follow a lognormal distribution (see @sec-reconstruct for a proof). For a definition of this volumes see `01_prepare_data.qmd`. The sum of the lognormals can be approximated via a method described in @Mehta2007.

```{stan output.var = "nfi_inra", cache = TRUE}
data {
	// Dimensions and indices
	int <lower = 1> N; // Total number of individuals
	int <lower = 1, upper = N> N_inra; // Number of individuals with a measured crown
	int <lower = 1, upper = N> S; // Number of species
	int <lower = 0, upper = S> n_sp_broad_inra; // Number of broadleaf species
	int <lower = 0, upper = S - n_sp_broad_inra> n_sp_conif_inra; // Number of conifer species

	int <lower = 1, upper = N - 1> ind_start_broad; // Broadleaf index start
	int <lower = 1, upper = N> ind_end_broad; // Broadleaf index end
	int <lower = 1, upper = N - 1> ind_start_conif; // Conifer index start
	int <lower = 1, upper = N> ind_end_conif; // Conifer index end
	
	array[n_sp_broad_inra] int ind_start_broad_inra; // Broadleaf crown species index start
	array[n_sp_broad_inra] int ind_end_broad_inra; // Broadleaf crown species index end
	array[n_sp_conif_inra] int ind_start_conif_inra; // Conifer crown species index start
	array[n_sp_conif_inra] int ind_end_conif_inra; // Conifer crown species index end

	// Predictors
	vector <lower = 0> [N] circumference_m;

	// Response variables
	vector <lower = 0> [N] bole_volume_m3;
	vector <lower = 0> [N] crown_volume_m3;
}

transformed data {
	// Predictors
	vector [N] log_circumference_m = log(circumference_m);

	// Response variables
	vector [N] log_bole_volume_m3 = log(bole_volume_m3);
	vector [N] log_crown_volume_m3 = log(crown_volume_m3);
}

parameters {
	// Intercepts
	vector [2] a_bole;
	vector [2] a_crown;

	// Slopes
	vector [2] b_bole;
	vector [2] b_crown;
	vector [2] c_bole;
	vector [2] c_crown;

	// Variances
	vector <lower = 0> [2] sigma_bole;
	vector <lower = 0> [2] sigma_crown;
}

model {
	// Priors
	// --- Intercepts
	target += normal_lpdf(a_bole | 0, 2);
	target += normal_lpdf(a_crown | 0, 2);

	// --- Slopes
	target += normal_lpdf(b_bole | 0, 2);
	target += normal_lpdf(b_crown | 0, 2);

	target += normal_lpdf(c_bole | 0, 2);
	target += normal_lpdf(c_crown | 0, 2);

	// --- Variances
	target += gamma_lpdf(sigma_bole | 1.0^2/5.0, 1.0/5.0);
	target += gamma_lpdf(sigma_crown | 1.0^2/5.0, 1.0/5.0);

	// Likelihood
	// --- Broadleaves, bole
	target += normal_lpdf(log_bole_volume_m3[ind_start_broad:ind_end_broad] | a_bole[1] + 
		b_bole[1]*log_circumference_m[ind_start_broad:ind_end_broad] +
		c_bole[1]*log_circumference_m[ind_start_broad:ind_end_broad].^4, sigma_bole[1]);
	
	// --- Conifers, bole
	target += normal_lpdf(log_bole_volume_m3[ind_start_conif:ind_end_conif] | a_bole[2] + 
		b_bole[2]*log_circumference_m[ind_start_conif:ind_end_conif] +
		c_bole[2]*log_circumference_m[ind_start_conif:ind_end_conif].^4, sigma_bole[2]);

	// --- Broadleaves, crown
	for (i in 1:n_sp_broad_inra)
		target += normal_lpdf(log_crown_volume_m3[ind_start_broad_inra[i]:ind_end_broad_inra[i]] | a_crown[1] + 
			b_crown[1]*log_circumference_m[ind_start_broad_inra[i]:ind_end_broad_inra[i]] +
			c_crown[1]*log_circumference_m[ind_start_broad_inra[i]:ind_end_broad_inra[i]].^4, sigma_crown[1]);
	
	// --- Conifers, crown
	for (i in 1:n_sp_conif_inra)
		target += normal_lpdf(log_crown_volume_m3[ind_start_conif_inra[i]:ind_end_conif_inra[i]] | a_crown[2] + 
			b_crown[2]*log_circumference_m[ind_start_conif_inra[i]:ind_end_conif_inra[i]] +
			c_crown[2]*log_circumference_m[ind_start_conif_inra[i]:ind_end_conif_inra[i]].^4, sigma_crown[2]);
}
```


```{r}
n_chains = 4
# woodstock_seed = 1969 - 08 - 18
iter_warmup = 350
iter_sampling = 500

# nfi_inra = cmdstan_model("./test_nfi-inra.stan")

stanData$total_volume_m3 = NULL
stanData$crown_volume_m3[is.na(stanData$crown_volume_m3)] = Inf
stanData$ind_start_broad = min(stanData$ind_start_broad)
stanData$ind_end_broad = max(stanData$ind_end_broad)
stanData$ind_start_conif = min(stanData$ind_start_conif)
stanData$ind_end_conif = max(stanData$ind_end_conif)

## Fit
if (!file.exists("fit_inra-nfi.rds"))
{
	fit = nfi_inra$sample(data = stanData, chains = n_chains, parallel_chains = ifelse(n_chains < 4, n_chains, 4),
		seed = NULL, refresh = 50, max_treedepth = 12, save_warmup = TRUE,
		iter_sampling = iter_sampling, iter_warmup = iter_warmup, adapt_delta = 0.8)
	fit$save_output_files(dir = "./", basename = paste0("fit_inra-nfi"), random = FALSE)
	saveRDS(fit, "./fit_inra-nfi.rds")
} else {
	fit = readRDS("./fit_inra-nfi.rds")
}
```

## Results
As can be seen here in what follows there is no problem of convergence:
```{r}
#| results: hold
mcmc_trace(fit$draws(c("a_bole", "a_crown")))
mcmc_trace(fit$draws(c("b_bole", "b_crown")))
mcmc_trace(fit$draws(c("c_bole", "c_crown")))
mcmc_trace(fit$draws(c("sigma_bole", "sigma_crown")))

mcmc_rhat(bayesplot::rhat(fit))
mcmc_nuts_divergence(bayesplot::nuts_params(fit), lp = log_posterior(fit))
```

I now do some posterior checks:

1. Reconstruct the volume variable after the log transformation
2. What are the residuals?
3. How well does it predict an independent dataset?

### Reconstruction {#sec-reconstruct}

So far, I fit a model on $X = \log(V) \sim \N(\mu, \sigma)$. Following @Wasserman2003[pp. 41] I get:

1. $A_y = ] -\infty; \log(y)]$, if $y > 0$.
2. For the cumulative density function, I get:
\begin{align*}
	F_Y(y) &= \int_{A_y} f_X(x) \, dx \\
		&= \int_{-\infty}^{\log(y)} \frac{1}{\sqrt{2 \pi} \sigma} \exp\left[ -\frac{1}{2} \left(\frac{x - \mu}{\sigma} \right) \right] \, dx \\
		&= \int_{-\infty}^{y} \frac{1}{\sqrt{2 \pi} \sigma z} \exp\left[ -\frac{1}{2} \left(\frac{\log(z) - \mu}{\sigma} \right) \right] \, dz && \text{with change of variable } z = \exp(x)
\end{align*}
which is the lognormal distribution $\logN(\mu, \sigma)$.
3. Now the total volume can be approximated by the formula of @Mehta2007 coded below.

```{r}
approx_logN = function(mu1, mu2, sigma1, sigma2, s1 = 0.2, s2 = 1, N = 12, start = c(-0.5, 0.5))
{
	# The source of the method is:
	#	Mehta, N.B. and Wu, Jingxian and Molisch, A.F. and Zhang, Jin, 2007
	#	Approximating a Sum of Random Variables with a Lognormal
	#	IEEE Transactions on Wireless Communications, vol. 7, pp. 2690–2699
	#	10.1109/twc.2007.051000
	#
	# The source of the weights and abscissa is:
	#	Herbert E. Salzer, Ruth Zucker, and Ruth Capuano, 1952
	#	Table of the Zeros and Weight Factors of the First Twenty Hermite Polynomials
	#	Journal of Research of the National Bureau of Standards Vol. 48, No.2

	## Gauß-Hermite 
	if (N != 12)
		stop("You must choose N = 12 as I did not write the coefficients and abscissa for any other value of N")

	abscissa = c(0.314240376254359,
		0.947788391240164,
		1.597682635152605,
		2.279507080501060,
		3.020637025120890,
		3.889724897869782)

	hermite_dt = data.table(
		abscissa = c(-abscissa, abscissa),
		weights = rep(c(
			5.701352362625e-1,
			2.604923102642e-1,
			5.160798561588e-2,
			3.905390584629e-3,
			8.573687043588e-5,
			2.658551684356e-7
		), 2)
	)

	gaussHermite = function(s, mu, sigma, hermite_dt)
	{
		gh = hermite_dt[, weights] %*% exp(-s * exp(sqrt(2)*sigma*hermite_dt[, abscissa] + mu))
		return(1/sqrt(pi) * gh)
	}

	psi_hat_s1 = gaussHermite(s1, mu1, sigma1, hermite_dt)*gaussHermite(s1, mu2, sigma2, hermite_dt)
	psi_hat_s2 = gaussHermite(s2, mu1, sigma1, hermite_dt)*gaussHermite(s2, mu2, sigma2, hermite_dt)

	fun_to_optim = function(x, s1, s2, psi_hat_s1, psi_hat_s2, hermite_dt) # x = c(mu, sigma)
	{
		Eq1 = gaussHermite(s1, x[1], x[2], hermite_dt) - psi_hat_s1
		Eq2 = gaussHermite(s2, x[1], x[2], hermite_dt) - psi_hat_s2

		return(c(Eq1, Eq2))
	}

	mu_sigma = multiroot(f = fun_to_optim, start = start, s1 = s1, s2 = s2, psi_hat_s1 = psi_hat_s1,
		psi_hat_s2 = psi_hat_s2, hermite_dt = hermite_dt)
	
	return(c(mu = mu_sigma[["root"]][1], sigma = mu_sigma[["root"]][2], iter = mu_sigma[["iter"]],
		estimated_prec = mu_sigma[["estim.precis"]]))
}
```

Test of the function `approx_logN`:
```{r}
#| label: fig-approx_logN
#| fig-cap: "Approximation of the sum of two lognormal variables"

## Test of the function
# Parameters of the lognormals
mu1 = 1
mu2 = -3
sigma1 = 0.25
sigma2 = 0.42

# Generate numbers
set.seed(1968 - 08 - 18)
aa = rlnorm(1e4, mu1, sigma1)
bb = rlnorm(1e4, mu2, sigma2)
cc = aa + bb

# Test
test = approx_logN(mu1, mu2, sigma1, sigma2, start = c(1, 1))

plot(density(cc), lwd = 5)
curve(dlnorm(x, test["mu"], test["sigma"]), lwd = 2, col = "#CD212A", add = TRUE)
```

### Residuals
We compute the residuals as the mean of the bayesian simulations minus the observed. Note that we use the lognormal distribution and the real observations rather than the normal distribution and the log-transformed observation.

```{stan output.var = "genQ", cache = TRUE}
data {
	// Dimensions and indices
	int <lower = 1> N_new; // Total number of individuals for simulations
	int <lower = 0, upper = N_new> N_inra_new; // Number of individuals with a measured crown for simulations
	int <lower = 0> n_sp_broad_inra_new; // Number of broadleaf species for simulations
	int <lower = 0> n_sp_conif_inra_new; // Number of conifer species for simulations

	int <lower = 0, upper = N_new> start_broad_new; // Broadleaf index start (for simulations)
	int <lower = 0, upper = N_new> end_broad_new; // Broadleaf index end (for simulations)
	int <lower = 0, upper = N_new> start_conif_new; // Conifer index start (for simulations)
	int <lower = 0, upper = N_new> end_conif_new; // Conifer index end (for simulations)
	
	array[n_sp_broad_inra_new] int start_broad_inra_new; // Broadleaf crown species index start (for simulations)
	array[n_sp_broad_inra_new] int end_broad_inra_new; // Broadleaf crown species index end (for simulations)
	array[n_sp_conif_inra_new] int start_conif_inra_new; // Conifer crown species index start (for simulations)
	array[n_sp_conif_inra_new] int end_conif_inra_new; // Conifer crown species index end (for simulations)

	// Predictors
	vector <lower = 0> [N_new] circumference_m_new;

	// Boolean, Stan uses 0 to encode false, and 1 to encode true
	int <lower = 0, upper = 1> predict_crown; // Should crown volume predicted for trees without crown measurements
}

transformed data {
	// Predictors
	vector [N_new] log_circumference_m_new = log(circumference_m_new);
}

parameters {
	// Intercepts
	vector [2] a_bole;
	vector [2] a_crown;

	// Slopes
	vector [2] b_bole;
	vector [2] b_crown;
	vector [2] c_bole;
	vector [2] c_crown;

	// Variances
	vector <lower = 0> [2] sigma_bole;
	vector <lower = 0> [2] sigma_crown;
}

generated quantities {
	// Declare quantities
	array[N_new] real bole_volume_new;
	array[N_inra_new] real crown_volume_new;
	array[N_new] real crown_volume_new_pred;

	// Generate bole volume simulations
	bole_volume_new[start_broad_new:end_broad_new] = lognormal_rng(a_bole[1] + 
			b_bole[1]*log_circumference_m_new[start_broad_new:end_broad_new] +
			c_bole[1]*log_circumference_m_new[start_broad_new:end_broad_new].^4, sigma_bole[1]);

	bole_volume_new[start_conif_new:end_conif_new] = lognormal_rng(a_bole[2] + 
			b_bole[2]*log_circumference_m_new[start_conif_new:end_conif_new] +
			c_bole[2]*log_circumference_m_new[start_conif_new:end_conif_new].^4, sigma_bole[2]);

	// Generate crown volume simulations
	if (N_inra_new > 0)
	{
		int temp_start = 1;
		int temp_end;

		// --- Broadleaves, crown
		for (i in 1:n_sp_broad_inra_new)
		{
			temp_end = temp_start + end_broad_inra_new[i] - start_broad_inra_new[i];
			
			crown_volume_new[temp_start:temp_end] = lognormal_rng(a_crown[1] + 
				b_crown[1]*log_circumference_m_new[start_broad_inra_new[i]:end_broad_inra_new[i]] +
				c_crown[1]*log_circumference_m_new[start_broad_inra_new[i]:end_broad_inra_new[i]].^4, sigma_crown[1]);
			
			temp_start = temp_end + 1;
		}
		
		// --- Conifers, crown
		for (i in 1:n_sp_conif_inra_new)
		{
			temp_end = temp_start + end_conif_inra_new[i] - start_conif_inra_new[i];

			crown_volume_new[temp_start:temp_end] = lognormal_rng(a_crown[2] + 
				b_crown[2]*log_circumference_m_new[start_conif_inra_new[i]:end_conif_inra_new[i]] +
				c_crown[2]*log_circumference_m_new[start_conif_inra_new[i]:end_conif_inra_new[i]].^4, sigma_crown[2]);

			temp_start = temp_end + 1;
		}
	}

	// Generate crown volume simulations with predictions for non crown-measured trees
	if (predict_crown)
	{
		// --- Broadleaves, crown
		crown_volume_new_pred[start_broad_new:end_broad_new] = lognormal_rng(a_crown[1] + 
				b_crown[1]*log_circumference_m_new[start_broad_new:end_broad_new] +
				c_crown[1]*log_circumference_m_new[start_broad_new:end_broad_new].^4, sigma_crown[1]);

		// --- Conifers, crown
		crown_volume_new_pred[start_conif_new:end_conif_new] = lognormal_rng(a_crown[2] + 
				b_crown[2]*log_circumference_m_new[start_conif_new:end_conif_new] +
				c_crown[2]*log_circumference_m_new[start_conif_new:end_conif_new].^4, sigma_crown[2]);
	}
}
```

```{r}
#| warning: false
#| output: false

stanData_new = stanData
stanData_new$N_new = stanData$N
stanData_new$N_inra_new = stanData$N_inra
stanData_new$n_sp_broad_inra_new = stanData_new$n_sp_broad_inra
stanData_new$n_sp_conif_inra_new = stanData_new$n_sp_conif_inra

stanData_new$start_broad_new = stanData_new$ind_start_broad
stanData_new$end_broad_new = stanData_new$ind_end_broad
stanData_new$start_conif_new = stanData_new$ind_start_conif
stanData_new$end_conif_new = stanData_new$ind_end_conif

stanData_new$start_broad_inra_new = stanData_new$ind_start_broad_inra
stanData_new$end_broad_inra_new = stanData_new$ind_end_broad_inra
stanData_new$start_conif_inra_new = stanData_new$ind_start_conif_inra
stanData_new$end_conif_inra_new = stanData_new$ind_end_conif_inra

stanData_new$circumference_m_new = stanData_new$circumference_m

stanData_new$predict_crown = 1 # Stan uses 0 to encode false, and 1 to encode true

posteriorVols = genQ$generate_quantities(fitted_params = fit$draws(inc_warmup = FALSE), data = stanData_new,
	parallel_chains = min(n_chains, 4))

sim_bole = apply(X = posteriorVols$draws("bole_volume_new"), MARGIN = 3, FUN = mean)
sim_crown = apply(X = posteriorVols$draws("crown_volume_new"), MARGIN = 3, FUN = mean)

rm(posteriorVols, stanData_new)

a_bole = apply(X = fit$draws("a_bole"), MARGIN = 3, FUN = mean)
b_bole = apply(X = fit$draws("b_bole"), MARGIN = 3, FUN = mean)
c_bole = apply(X = fit$draws("c_bole"), MARGIN = 3, FUN = mean)

a_crown = apply(X = fit$draws("a_crown"), MARGIN = 3, FUN = mean)
b_crown = apply(X = fit$draws("a_crown"), MARGIN = 3, FUN = mean)
c_crown = apply(X = fit$draws("a_crown"), MARGIN = 3, FUN = mean)

sigma_bole = apply(X = fit$draws("sigma_bole"), MARGIN = 3, FUN = mean)
sigma_crown = apply(X = fit$draws("sigma_crown"), MARGIN = 3, FUN = mean)

ind_crown = unlist(mapply(seq, ind_species[origin_data == "inra", start_sp_orig],
	ind_species[origin_data == "inra", end_sp_orig]))

approx_dt = forest_dt[!is.na(crown_volume_m3), .(fct_type, circumference_m, bole_volume_m3, crown_volume_m3,
	total_volume_m3, fct_colour, origin_colour)]

approx_dt[, sim_bole_m3 := sim_bole[ind_crown]]
approx_dt[, sim_crown_m3 := sim_crown]
approx_dt[, sim_tot_m3 := sim_bole_m3 + sim_crown_m3]

approx_dt[, res_bole_m3 := sim_bole_m3 - bole_volume_m3]
approx_dt[, res_crown_m3 := sim_crown_m3 - crown_volume_m3]
approx_dt[, res_tot_m3 := sim_tot_m3 - total_volume_m3]

## Compute the mu_bole for each tree, and add sd_bole
approx_dt[fct_type == "broadleaf", c("mu_bole", "sd_bole") := .(a_bole[1] +
	b_bole[1]*log(circumference_m) + c_bole[1]*log(circumference_m)^4, sigma_bole[1])]
approx_dt[fct_type == "conifer", c("mu_bole", "sd_bole") := .(a_bole[2] +
	b_bole[2]*log(circumference_m) + c_bole[2]*log(circumference_m)^4, sigma_bole[2])]

## Compute the mu_crown for each tree, and add sd_crown
approx_dt[fct_type == "broadleaf", c("mu_crown", "sd_crown") := .(a_crown[1] +
	b_crown[1]*log(circumference_m) + c_crown[1]*log(circumference_m)^4, sigma_crown[1])]
approx_dt[fct_type == "conifer", c("mu_crown", "sd_crown") := .(a_crown[2] +
	b_crown[2]*log(circumference_m) + c_crown[2]*log(circumference_m)^4, sigma_crown[2])]

approx_dt = approx_dt[mu_crown > -15]

approx_dt[, c("mu_tot_est", "sigma_tot_est") := as.list(approx_logN(mu_bole, mu_crown, sd_bole, sd_crown)[c("mu", "sigma")]),
	by = .I]

approx_dt[sigma_tot_est < 0, c("mu_tot_est", "sigma_tot_est") := as.list(
	approx_logN(mu_bole, mu_crown, sd_bole, sd_crown, start = c(1, 1))[c("mu", "sigma")]), by = .I]

approx_dt[abs(mu_tot_est) > 100, c("mu_tot_est", "sigma_tot_est") := as.list(
	approx_logN(mu_bole, mu_crown, sd_bole, sd_crown, start = c(1, 1))[c("mu", "sigma")]), by = .I]

approx_dt[, mean_v_tot_pred := exp(mu_tot_est + sigma_tot_est^2/2)]
```

```{r}
#| echo: false
#| label: fig-residual_densities
#| fig-cap: "Densities of the residuals for bole, crown, and total volume"
#| fig-subcap: 
#|   - "Bole"
#|   - "Crown"
#|   - "Total"
#| layout-nrow: 3
#| fig-asp: 0.7
#| out-width: 95%
#| fig-width: 8.142857

plot(density(approx_dt[, res_bole_m3]), lwd = 2, main = "Bole")
plot(density(approx_dt[, res_crown_m3]), lwd = 2, main = "Crown")
plot(density(approx_dt[, res_tot_m3]), lwd = 2, main = "Total")
```

```{r}
#| echo: false
#| label: fig-residuals
#| fig-cap: "Scatter plots of the residuals for bole, crown, and total volume"
#| fig-subcap: 
#|   - "Bole"
#|   - "Crown"
#|   - "Total"
#| layout-nrow: 3
#| fig-asp: 0.7
#| out-width: 95%
#| fig-width: 8.142857

plot(approx_dt[, res_bole_m3], pch = 19, cex = 0.05, xlab = "", ylab = "Residuals bole")
plot(approx_dt[, res_crown_m3], pch = 19, cex = 0.05, xlab = "", ylab = "Residuals crown")
plot(approx_dt[, res_tot_m3], pch = 19, cex = 0.05, xlab = "", ylab = "Residuals tot")
```

```{r}
#| echo: false
#| label: fig-bole_pred
#| fig-cap: "Predicted vs measured bole volumes"
#| fig-subcap: 
#|   - "Conifer *vs* broadleaf (whole dataset)"
#|   - "Conifer *vs* broadleaf (Inra)"
#|   - "NFI *vs* Inra"
#| layout-nrow: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

plot(forest_dt[, bole_volume_m3], sim_bole, pch = 19, col = forest_dt[, fct_colour], cex = 0.2,
	xlab = "Measured bole volume (m³)", ylab = "Predicted bole volume (m³)")
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])

plot(approx_dt[, bole_volume_m3], approx_dt[, sim_bole_m3], pch = 19, col = approx_dt[, fct_colour], cex = 0.2,
	xlab = "Measured bole volume (m³)", ylab = "Predicted bole volume (m³)")
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])

plot(forest_dt[, bole_volume_m3], sim_bole, pch = 19, col = forest_dt[, origin_colour], cex = 0.2,
	xlab = "Measured bole volume (m³)", ylab = "Predicted bole volume (m³)")
points(approx_dt[, bole_volume_m3], approx_dt[, sim_bole_m3], , pch = 19, col = approx_dt[, origin_colour], cex = 0.2)
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("NFI", "Inra"), fill = colours[c("nfi", "inra")])
```

```{r}
#| echo: false
#| label: fig-crown_pred
#| fig-cap: "Predicted vs measured crown volumes"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

plot(approx_dt[, crown_volume_m3], approx_dt[, sim_crown_m3], pch = 19, col = approx_dt[, fct_colour],
	cex = 0.2, xlab = "Measured crown volume (m³)", ylab = "Predicted crown volume (m³)")
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])
```

```{r}
#| echo: false
#| label: fig-tot_pred
#| fig-cap: "Predicted vs measured total volumes"
#| fig-subcap: 
#|   - "Averaged simulation"
#|   - "Averaged value of the approximation, using the formula of @Mehta2007"
#| layout-nrow: 2
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

plot(approx_dt[, total_volume_m3], approx_dt[, sim_tot_m3], pch = 19, col = approx_dt[, fct_colour], cex = 0.2,
	xlab = "Total measured volume", ylab = "Avg volume")
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])

plot(approx_dt[, total_volume_m3], approx_dt[, mean_v_tot_pred], pch = 19, col = approx_dt[, fct_colour], cex = 0.2,
	xlab = "Total measured volume", ylab = "Approx sum logN avg volume")
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])
```