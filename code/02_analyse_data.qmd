---
title: "Analyse data to estimate volumes"
date: today
author: AmaÃ«l Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
  cache: true
bibliography: references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    keep-tex: true
    pdf-engine: lualatex
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

\newcommand{\ie}{*i.e.,*}
\newcommand{\F}{\mathscr{F}}
\newcommand{\N}{\mathbfscr{N}}
\newcommand{\logN}{log\mathbfscr{N}}

\newcommand{\vtot}{v_{\text{tot}}}
\newcommand{\vbole}{v_{\text{bole}}}
\newcommand{\vbr}{v_{\text{branches}}}

```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(rootSolve)
library(bayesplot)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
```

## Introduction
The data have been prepared in `01_prepare_data.qmd`. In this document, I fit a model on both INRA and French NFI data. In this section, I explore the data, and in the next section I define the model. Lastly  I explore few results.

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra.rds"))
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt.rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra.rds"))

colours = paste0(met.brewer("Egypt")[1:4])
names(colours) = c("conifer", "broadleaf", "inra", "nfi")

forest_dt[fct_type == "broadleaf", fct_colour := colours["broadleaf"]]
forest_dt[fct_type == "conifer", fct_colour := colours["conifer"]]
forest_dt[origin_data == "inra", origin_colour := colours["inra"]]
forest_dt[origin_data == "nfi", origin_colour := colours["nfi"]]
```

```{r}
colnames(forest_dt)

forest_dt[!is.na(crown_volume_m3), .N, by = fct_type]

png("./test.png", res = 120, height = 1080, width = 1080)
plot(forest_dt[, log(circumference_m)], forest_dt[, log(bole_volume_m3)], col = forest_dt[, fct_colour], pch = 19,
	xlab = "Circumference", ylab = "Bole volume")
legend(x = "topright", legend = c("Broadleaf", "Conifer"), fill = colours[c("broadleaf", "conifer")])
dev.off()

png("./test2.png", res = 120, height = 1080, width = 1080)
plot(forest_dt[!is.na(crown_volume_m3), log(circumference_m)], forest_dt[!is.na(crown_volume_m3), log(crown_volume_m3)],
	col = forest_dt[!is.na(crown_volume_m3), fct_colour], pch = 19, xlab = "Circumference", ylab = "Crown volume")
legend(x = "topright", legend = c("Broadleaf", "Conifer"), fill = colours[c("broadleaf", "conifer")])
dev.off()

lm_bole = lm(forest_dt[, log(bole_volume_m3)] ~ 1 + forest_dt[, log(circumference_m)] + forest_dt[, log(circumference_m)^4])
lm_crown = lm(forest_dt[, log(crown_volume_m3)] ~ 1 + forest_dt[, log(circumference_m)] + forest_dt[, log(circumference_m)^4])
```

## Methods
I first try a simple model:
$$
\vtot = \vbole + \vbr
$$
where the bole volume, $\vbole$, and the branch volume, $\vbr$, both follow a lognormal distribution (see @sec-reconstruct for a proof). For a definition of this volumes see `01_prepare_data.qmd`. The sum of the lognormals can be approximated via a method described in @Lo2012.

```{stan output.var = "nfi_inra", cache = TRUE}
data {
	// Dimensions and indices
	int <lower = 1> N; // Total number of individuals
	int <lower = 1, upper = N> N_inra; // Number of individuals with a measured crown
	int <lower = 1, upper = N> S; // Number of species
	int <lower = 0, upper = S> n_sp_broad_inra; // Number of broadleaf species
	int <lower = 0, upper = S - n_sp_broad_inra> n_sp_conif_inra; // Number of conifer species

	int <lower = 1, upper = N - 1> ind_start_broad; // Broadleaf index start
	int <lower = 1, upper = N> ind_end_broad; // Broadleaf index end
	int <lower = 1, upper = N - 1> ind_start_conif; // Conifer index start
	int <lower = 1, upper = N> ind_end_conif; // Conifer index end
	
	array[n_sp_broad_inra] int ind_start_broad_inra; // Broadleaf crown species index start
	array[n_sp_broad_inra] int ind_end_broad_inra; // Broadleaf crown species index end
	array[n_sp_conif_inra] int ind_start_conif_inra; // Conifer crown species index start
	array[n_sp_conif_inra] int ind_end_conif_inra; // Conifer crown species index end

	// Predictors
	vector <lower = 0> [N] circumference_m;

	// Response variables
	vector <lower = 0> [N] bole_volume_m3;
	vector <lower = 0> [N] crown_volume_m3;
}

transformed data {
	// Predictors
	vector [N] log_circumference_m = log(circumference_m);

	// Response variables
	vector [N] log_bole_volume_m3 = log(bole_volume_m3);
	vector [N] log_crown_volume_m3 = log(crown_volume_m3);
}

parameters {
	// Intercepts
	vector [2] a_bole;
	vector [2] a_crown;

	// Slopes
	vector [2] b_bole;
	vector [2] b_crown;
	vector [2] c_bole;
	vector [2] c_crown;

	// Variances
	vector <lower = 0> [2] sigma_bole;
	vector <lower = 0> [2] sigma_crown;
}

model {
	// Priors
	// --- Intercepts
	target += normal_lpdf(a_bole | 0, 2);
	target += normal_lpdf(a_crown | 0, 2);

	// --- Slopes
	target += normal_lpdf(b_bole | 0, 2);
	target += normal_lpdf(b_crown | 0, 2);

	target += normal_lpdf(c_bole | 0, 2);
	target += normal_lpdf(c_crown | 0, 2);

	// --- Variances
	target += gamma_lpdf(sigma_bole | 1.0^2/5.0, 1.0/5.0);
	target += gamma_lpdf(sigma_crown | 1.0^2/5.0, 1.0/5.0);

	// Likelihood
	// --- Broadleaves, bole
	target += normal_lpdf(log_bole_volume_m3[ind_start_broad:ind_end_broad] | a_bole[1] + 
		b_bole[1]*log_circumference_m[ind_start_broad:ind_end_broad] +
		c_bole[1]*log_circumference_m[ind_start_broad:ind_end_broad].^4, sigma_bole[1]);
	
	// --- Conifers, bole
	target += normal_lpdf(log_bole_volume_m3[ind_start_conif:ind_end_conif] | a_bole[2] + 
		b_bole[2]*log_circumference_m[ind_start_conif:ind_end_conif] +
		c_bole[2]*log_circumference_m[ind_start_conif:ind_end_conif].^4, sigma_bole[2]);

	// --- Broadleaves, crown
	for (i in 1:n_sp_broad_inra)
		target += normal_lpdf(log_crown_volume_m3[ind_start_broad_inra[i]:ind_end_broad_inra[i]] | a_crown[1] + 
			b_crown[1]*log_circumference_m[ind_start_broad_inra[i]:ind_end_broad_inra[i]] +
			c_crown[1]*log_circumference_m[ind_start_broad_inra[i]:ind_end_broad_inra[i]].^4, sigma_crown[1]);
	
	// --- Conifers, crown
	for (i in 1:n_sp_conif_inra)
		target += normal_lpdf(log_crown_volume_m3[ind_start_conif_inra[i]:ind_end_conif_inra[i]] | a_crown[2] + 
			b_crown[2]*log_circumference_m[ind_start_conif_inra[i]:ind_end_conif_inra[i]] +
			c_crown[2]*log_circumference_m[ind_start_conif_inra[i]:ind_end_conif_inra[i]].^4, sigma_crown[2]);
}
```


```{r}
n_chains = 4
# woodstock_seed = 1969 - 08 - 18
iter_warmup = 350
iter_sampling = 500

nfi_inra = cmdstan_model("./test_nfi-inra.stan")

stanData$total_volume_m3 = NULL
stanData$crown_volume_m3[is.na(stanData$crown_volume_m3)] = Inf
stanData$ind_start_broad = min(stanData$ind_start_broad)
stanData$ind_end_broad = max(stanData$ind_end_broad)
stanData$ind_start_conif = min(stanData$ind_start_conif)
stanData$ind_end_conif = max(stanData$ind_end_conif)

## Fit
if (!file.exists("fit_inra-nfi.rds"))
{
	fit = nfi_inra$sample(data = stanData, chains = n_chains, parallel_chains = ifelse(n_chains < 4, n_chains, 4),
		seed = NULL, refresh = 50, max_treedepth = 12, save_warmup = TRUE,
		iter_sampling = iter_sampling, iter_warmup = iter_warmup, adapt_delta = 0.8)
	fit$save_output_files(dir = "./", basename = paste0("fit_inra-nfi"), random = FALSE)
	saveRDS(fit, "./fit_inra-nfi.rds")
} else {
	fit = readRDS("./fit_inra-nfi.rds")
}
```

## Results
As can be seen here in what follows there is no problem of convergence:
```{r}
mcmc_trace(fit$draws(c("a_bole", "a_crown")))
mcmc_trace(fit$draws(c("b_bole", "b_crown")))
mcmc_trace(fit$draws(c("c_bole", "c_crown")))
mcmc_trace(fit$draws(c("sigma_bole", "sigma_crown")))

mcmc_rhat(bayesplot::rhat(fit))
mcmc_nuts_divergence(bayesplot::nuts_params(fit), lp = log_posterior(fit))
```

I now do some posterior checks:

1. Reconstruct the volume variable after the log transformation
2. What are the residuals?
3. How well does it predict an independent dataset?

### Reconstruction {#sec-reconstruct}

So far, I fit a model on $X = \log(V) \sim \N(\mu, \sigma)$. Following @Wasserman2003[pp. 41] I get:

1. $A_y = ] -\infty; \log(y)]$, if $y > 0$.
2. For the cumulative density function, I get:
\begin{align*}
	F_Y(y) &= \int_{A_y} f_X(x) \, dx \\
		&= \int_{-\infty}^{\log(y)} \frac{1}{\sqrt{2 \pi} \sigma} \exp\left[ -\frac{1}{2} \left(\frac{x - \mu}{\sigma} \right) \right] \, dx \\
		&= \int_{-\infty}^{y} \frac{1}{\sqrt{2 \pi} \sigma z} \exp\left[ -\frac{1}{2} \left(\frac{\log(z) - \mu}{\sigma} \right) \right] \, dz && \text{with change of variable } z = \exp(x)
\end{align*}
which is the lognormal distribution $\logN(\mu, \sigma)$.
3. Now the total volume can be approximated by the formula of @Lo2012.

### Residuals
We compute the residuals as the mean of the bayesian simulations minus the observed. Note that we use the lognormal distribution and the real observations rather than the normal distribution and the log-transformed observation.

```{stan output.var = "genQ", cache = TRUE}
// This standalone script generates volume for a given species

data {
	// Dimensions and indices for parameters
	int S; // Number of species
	
	// New data for generating posterior
	int N_new; // Number of new individuals
	int<lower = 1, upper = S> species_id; // Index of the species
	int<lower = 1, upper = 2> fct_type; // Functional type, 1 = broadleaf, 2 = conifer

	// Predictors
	vector [N_new] hdn_new;
	vector [N_new] slenderness_new;
	vector [N_new] corrected_cyl_vol_new;
}

parameters {
	// Fixed effects (population parameters) for broadleaf and conifer
	vector[2] b0;
	vector[2] b1;
	vector[2] b2;
	
	// Random effects (group parameters)
	vector[S] beta0;
	vector[S] beta2;

	// Variances
	real<lower = 0> sigma; // sd residuals
	real<lower = 0> sigma_beta0; // sd random effect beta0
	real<lower = 0> sigma_beta2; // sd random effect beta2
}

generated quantities {
	vector[N_new] avg = (beta0[species_id] + b1[fct_type]*hdn_new + beta2[species_id]*slenderness_new) .*
		corrected_cyl_vol_new;
	array[N_new] real volume_new = normal_rng(avg, sigma);
}
```

```{r}
genQ = cmdstan_model("./genQ_nfi-inra.stan")

stanData_new = stanData
stanData_new$N_new = stanData$N
stanData_new$N_inra_new = stanData$N_inra
stanData_new$n_sp_broad_inra_new = stanData_new$n_sp_broad_inra
stanData_new$n_sp_conif_inra_new = stanData_new$n_sp_conif_inra

stanData_new$start_broad_new = stanData_new$ind_start_broad
stanData_new$end_broad_new = stanData_new$ind_end_broad
stanData_new$start_conif_new = stanData_new$ind_start_conif
stanData_new$end_conif_new = stanData_new$ind_end_conif

stanData_new$start_broad_inra_new = stanData_new$ind_start_broad_inra
stanData_new$end_broad_inra_new = stanData_new$ind_end_broad_inra
stanData_new$start_conif_inra_new = stanData_new$ind_start_conif_inra
stanData_new$end_conif_inra_new = stanData_new$ind_end_conif_inra

stanData_new$circumference_m_new = stanData_new$circumference_m

stanData_new$predict_crown = 1 # Stan uses 0 to encode false, and 1 to encode true

posteriorVols = genQ$generate_quantities(fitted_params = fit$draws(inc_warmup = FALSE), data = stanData_new,
	parallel_chains = min(n_chains, 4))

sim_bole = apply(X = posteriorVols$draws("bole_volume_new"), MARGIN = 3, FUN = mean)
sim_crown = apply(X = posteriorVols$draws("crown_volume_new"), MARGIN = 3, FUN = mean)

approx_dt = forest_dt[!is.na(crown_volume_m3), .(fct_type, circumference_m, total_volume_m3)]

approx_dt[fct_type == "broadleaf", c("mu_bole", "sd_bole") := .(apply(X = fit$draws("a_bole[1]"), MARGIN = 3, FUN = mean) +
	apply(X = fit$draws("b_bole[1]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m) +
	apply(X = fit$draws("c_bole[1]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m)^4,
	apply(X = fit$draws("sigma_bole[1]"), MARGIN = 3, FUN = mean))]
approx_dt[fct_type == "conifer", c("mu_bole", "sd_bole") := .(apply(X = fit$draws("a_bole[2]"), MARGIN = 3, FUN = mean) +
	apply(X = fit$draws("b_bole[2]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m) +
	apply(X = fit$draws("c_bole[2]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m)^4,
	apply(X = fit$draws("sigma_bole[2]"), MARGIN = 3, FUN = mean))]

approx_dt[fct_type == "broadleaf", c("mu_crown", "sd_crown") := .(apply(X = fit$draws("a_crown[1]"), MARGIN = 3, FUN = mean) +
	apply(X = fit$draws("b_crown[1]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m) +
	apply(X = fit$draws("c_crown[1]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m)^4,
	apply(X = fit$draws("sigma_crown[1]"), MARGIN = 3, FUN = mean))]
approx_dt[fct_type == "conifer", c("mu_crown", "sd_crown") := .(apply(X = fit$draws("a_crown[2]"), MARGIN = 3, FUN = mean) +
	apply(X = fit$draws("b_crown[2]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m) +
	apply(X = fit$draws("c_crown[2]", inc_warmup = FALSE), MARGIN = 3, FUN = mean)*log(circumference_m)^4,
	apply(X = fit$draws("sigma_crown[2]"), MARGIN = 3, FUN = mean))]


matmat = vector(mode = "list", length = approx_dt[, .N])

a_bole = fit$draws("a_bole")
b_bole = fit$draws("b_bole")
c_bole = fit$draws("c_bole")

a_crown = fit$draws("a_crown")
b_crown = fit$draws("a_crown")
c_crown = fit$draws("a_crown")

sigma_bole = fit$draws("sigma_bole")
sigma_crown = fit$draws("sigma_crown")

for (i in seq_along(matmat))
{
	if (approx_dt[i, fct_type] == "broadleaf")
	{
		temp = data.table(
			mu_bole = as.vector(a_bole[, , 1] + b_bole[, , 1]*log(approx_dt[i, circumference_m]) +
				c_bole[, , 1]*log(approx_dt[i, circumference_m])^4),
			mu_crown = as.vector(a_crown[, , 1] + b_crown[, , 1]*log(approx_dt[i, circumference_m]) +
				c_crown[, , 1]*log(approx_dt[i, circumference_m])^4),
			sigma_bole = as.vector(sigma_bole),
			sigma_crown = as.vector(sigma_crown)
		)
		matmat[[i]] = cor(temp)
	} else {
		temp = data.table(
			mu_bole = as.vector(a_bole[, , 2] + b_bole[, , 2]*log(approx_dt[i, circumference_m]) +
				c_bole[, , 2]*log(approx_dt[i, circumference_m])^4),
			mu_crown = as.vector(a_crown[, , 2] + b_crown[, , 2]*log(approx_dt[i, circumference_m]) +
				c_crown[, , 2]*log(approx_dt[i, circumference_m])^4),
			sigma_bole = as.vector(sigma_bole),
			sigma_crown = as.vector(sigma_crown)
		)
		matmat[[i]] = cor(temp)
	}
}

approx_dt[, c("mu_tot", "sigma_tot") := as.list(estimateSumLognormal(mu = c(mu_bole, mu_crown),
	sigma = c(sd_bole, sd_crown), corr = matmat[[.I]])), by = .I]

approx_dt[, v_tot_pred := exp(mu_tot + sigma_tot^2/2)]

curve(dlnorm(x, meanlog = -1.084176, sdlog = 0.2897294), lwd = 2, col = "#CD212A", to = 1.5)
abline(v = 0.51050, lwd = 2)
abline(v = 0.35267655, lwd = 2)

estimateSumLognormal(mu = c(-1.347949, -2.709285), sigma = c(0.3366277, 0.5570702), corr = matmat[[1]]) -
estimateSumLognormal(mu = c(-1.347949, -2.709285), sigma = c(0.3366277, 0.5570702))

exp(-1.083712 + 0.288125^2/2) - exp(-1.1880649 + 0.5401125^2/2)

rm(posteriorVols)
rm(stanData_new)

res = sim_bole - stanData$bole_volume_m3

pdf("density_res.pdf")
plot(density(res))
dev.off()

pdf("res.pdf")
plot(res, pch = 19, col = forest_dt[, origin_colour], cex = 0.05)
legend(x = "topright", legend = c("inra", "nfi"), fill = colours[c("inra", "nfi")])
dev.off()

pdf("pred_bole.pdf")
plot(stanData$bole_volume_m3, sim_bole, pch = 19, col = forest_dt[, fct_colour], cex = 0.2)
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])
dev.off()

pdf("pred_crown.pdf")
plot(forest_dt[!is.na(crown_volume_m3), crown_volume_m3], sim_crown, pch = 19,
	col = forest_dt[!is.na(crown_volume_m3), fct_colour], cex = 0.2)
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])
dev.off()

pdf("pred_vtot.pdf")
plot(approx_dt[, total_volume_m3], approx_dt[, v_tot_pred], pch = 19,
	col = forest_dt[!is.na(crown_volume_m3), fct_colour], cex = 0.2)
abline(a = 0, b = 1, lwd = 2, col = "#020202")
legend(x = "topright", legend = c("conifer", "broadleaf"), fill = colours[c("conifer", "broadleaf")])
dev.off()
```

```{r}
approx_logN = function(mu1, mu2, sigma1, sigma2, s1 = 0.2, s2 = 1, N = 12, start = c(1, 1))
{
	# The source of the method is:
	#	Mehta, N.B. and Wu, Jingxian and Molisch, A.F. and Zhang, Jin, 2007
	#	Approximating a Sum of Random Variables with a Lognormal
	#	IEEE Transactions on Wireless Communications, vol. 7, pp. 2690â2699
	#	10.1109/twc.2007.051000
	#
	# The source of the weights and abscissa is:
	#	Herbert E. Salzer, Ruth Zucker, and Ruth Capuano, 1952
	#	Table of the Zeros and Weight Factors of the First Twenty Hermite Polynomials
	#	Journal of Research of the National Bureau of Standards Vol. 48, No.2

	## GauÃ-Hermite 
	if (N != 12)
		stop("You must choose N = 12 as I did not write the coefficients and abscissa for any other value of N")

	abscissa = c(0.314240376254359,
		0.947788391240164,
		1.597682635152605,
		2.279507080501060,
		3.020637025120890,
		3.889724897869782)

	hermite_dt = data.table(
		abscissa = c(-abscissa, abscissa),
		weights = rep(c(
			5.701352362625e-1,
			2.604923102642e-1,
			5.160798561588e-2,
			3.905390584629e-3,
			8.573687043588e-5,
			2.658551684356e-7
		), 2)
	)

	gaussHermite = function(s, mu, sigma, hermite_dt)
	{
		gh = hermite_dt[, weights] %*% exp(-s * exp(sqrt(2)*sigma*hermite_dt[, abscissa] + mu))
		return(1/sqrt(pi) * gh)
	}

	psi_hat_s1 = gaussHermite(s1, mu1, sigma1, hermite_dt)*gaussHermite(s1, mu2, sigma2, hermite_dt)
	psi_hat_s2 = gaussHermite(s2, mu1, sigma1, hermite_dt)*gaussHermite(s2, mu2, sigma2, hermite_dt)

	fun_to_optim = function(x, s1, s2, psi_hat_s1, psi_hat_s2, hermite_dt) # x = c(mu, sigma)
	{
		Eq1 = gaussHermite(s1, x[1], x[2], hermite_dt) - psi_hat_s1
		Eq2 = gaussHermite(s2, x[1], x[2], hermite_dt) - psi_hat_s2

		return(c(Eq1, Eq2))
	}

	mu_sigma = multiroot(f = fun_to_optim, start = start, s1 = s1, s2 = s2, psi_hat_s1 = psi_hat_s1,
		psi_hat_s2 = psi_hat_s2, hermite_dt = hermite_dt)
	
	return(c(mu = mu_sigma[["root"]][1], sigma = mu_sigma[["root"]][2], iter = mu_sigma[["iter"]],
		estimated_prec = mu_sigma[["estim.precis"]]))
}

## Parameters of the lognormals
mu1 = 1
mu2 = -3
sigma1 = 0.25
sigma2 = 0.42

set.seed(1968 - 08 - 18)
aa = rlnorm(1e4, mu1, sigma1)
bb = rlnorm(1e4, mu2, sigma2)
cc = aa + bb

test = approx_logN(mu1, mu2, sigma1, sigma2)

plot(density(cc), lwd = 4)
curve(dlnorm(x, test["mu"], test["sigma"]), lwd = 2, col = "#CD212A", add = TRUE)
```