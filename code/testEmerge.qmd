---
title: "Reproducing the Emerge parametrisation by C. Deleuze"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
execute:
  error: true
bibliography: references.bib
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    keep-tex: true
    pdf-engine: lualatex
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

\newcommand{\ie}{*i.e.,*}
\newcommand{\F}{\mathscr{F}}
\newcommand{\N}{\mathbfscr{N}}

## Introduction

The original model can be found in @Deleuze2014. In their scripts, they used the following code:
```{r}
#| eval: false
Modele_mai2 = nlme(formTotNew ~ a + b*hdn + d*hsurd, data = Grdata.PV,
	start = c(a = 0.4, 0, b = 1.5, 0, d = 0.0005, 0),
	fixed = list(a + b + d ~ feuil.res), random = a + d ~ 1|nomessence2)
```

The model `Modele_mai2` computes the form factor $\F$ for an individual of height $h$ and circumference at breast height $c$, of species $j$ and functional group (conifer or broadleaf) $i$ as:
\begin{equation} \label{eq::deleuze}
\begin{aligned}
	\F &\sim \N(\mu, \sigma) \\
	\mu_{i, j} &= a_{i, j} + b_i \frac{\sqrt{c}}{h} + d_{i, j} \frac{h}{c} \\
	a_{i, j} &\sim \N(\alpha_i, \sigma_{\alpha}) \\
	d_{i, j} &\sim \N(\delta_i, \sigma_{\delta}),
\end{aligned}
\end{equation}
where $\alpha_i$ and $\delta_i$ are the 'group intercepts' (common values within conifers and broadleaves). Therefore, it seems to be a GLMM, and I am not sure `nlme` is relevant here. In the next sections, I will try to reproduce their model with real data. A previous analysis was done in the file `00_notes.qmd`.

I rewrite the equations with new variable names and without the indices $i$ and $j$, in order to correspond to stan code:
\begin{equation} \label{eq::deleuze-modified}
\begin{aligned}
	\F &\sim \N(\mu, \sigma) \\
	\mu &= \beta_0 + b_1 \frac{\sqrt{c}}{h} + \beta_2 \frac{h}{c} \\
	\beta_0 &\sim \N(b_0, \sigma_0) \\
	\beta_2 &\sim \N(b_2, \sigma_2),
\end{aligned}
\end{equation}

## Prepare the data
### Packages and helpers
First, I load the necessary packages:
```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
library(curl)
library(nlme)
library(gt)

setHook(packageEvent("grDevices", "onLoad"),
function(...) grDevices::X11.options(type='cairo'))
options(device='x11')
```

::: {.callout-tip}
## Stan engine
By default, Quarto uses the knitr's built-in stan engine `rstan`. To override it so that all stan chunks are processed with `CmdStanR`, I need to specify:
```{r}
#| eval: false
#| code-fold: false
register_knitr_engine(override = TRUE)
```
:::

Then, I define useful functions:
```{r}
#### Tool functions
## Tools
source("./toolFunctions.R")

## Function to compute tree volume according to model
vol_fct = function(params_vec, predictor_mat, corrected_cyl_vol)
	return((predictor_mat %*% params_vec) * corrected_cyl_vol)
```

### Fitting data
The data are saved remotely on the remote server `smb://del1509n015/` in the folder `2024_faircarbon/data_orig/`. On Linux, it is first necessary to mount locally the folder, so that R can access the files:

1. Switch to super user where you replace `JohnField-Admin` by your admin name (typically, your IGN id followed by `-Admin`):
```{sh}
#| eval: false
#| code-fold: false
su JohnField-Admin
```
Your **admin** password will be asked

2. Create a directory where you will mount the remote folder. By default I like to put it in `/mnt/local_share`. You need to be super user to write in `/mnt/`:
```{sh}
#| eval: false
#| code-fold: false
mkdir /mnt/local_share
```

3. Mount the remote folder `smb://del1509n015/2024_faircarbon/`, where you replace `your_name` by your **usual** IGN id (NOT the admin one):
```{sh}
#| eval: false
#| code-fold: false
sudo mount -t cifs -o username=your_name,domain=ign,uid=your_name //del1509n015/2024_faircarbon /mnt/local_share/
```
Maybe two passwords will be asked, first your **admin** password to execute the `sudo`, and then your **usual** password.

4. Check that it worked:
```{sh}
#| eval: false
#| code-fold: false
ls /mnt/local_share/
```
The content of the remote folder should appear. You can close your admin session by using `ctrl + d` or `Cmd + d`

Now that the data are available to {{< fa brands r-project >}}, it is time to prepare them:
```{r}
#### Prepare data
## Loading
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data_orig/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Are you sure you mounted the good remote folder?"))

if (list.files(path = path_data) != "EMERGE.RData")
	stop("There should be only the file <EMERGE.RData> in the data_orig folder")

load(paste0(path_data, "EMERGE.RData"))
rm(list = setdiff(ls(), c("inra_arbres", "emerge_2010_arbres", "emerge_2010_profils")))
setDT(inra_arbres)

## Keep only column of interest and rename them
inra_arbres[, tot_vol := v_tronc_verif + v_fourche_verif + v_fourche2_verif + v_br_verif + v_menu_verif]
inra_arbres = unique(inra_arbres[, .(nom_fichier, essence, c130, h_tot, tot_vol, genre)])
inra_arbres = na.omit(inra_arbres)

setnames(inra_arbres, new = c("unique_id", "speciesName_sci", "circumference_cm", "height", "tot_vol", "genus"))

inra_arbres[, fct_type := "broadleaf"] # Functional type, either broadleaf or conifer
inra_arbres[genus %in% c("Abies", "Cedrus", "Larix", "Picea", "Pinus", "Pseudotsuga", "Thuya", "Tsuga"),
	fct_type := "conifer"]

inra_arbres[, unique_id := as.character(unique_id)]
inra_arbres[, speciesName_sci := as.character(speciesName_sci)]
inra_arbres[, genus := as.character(genus)]

inra_arbres[, nb_indiv := .N, by = speciesName_sci]
# inra_arbres = inra_arbres[nb_indiv > 20]

## Compute (total) volume in m³, circumference in m, hardiness, and slenderness
inra_arbres[, volume_m3 := tot_vol/1e3]
inra_arbres[, circumference_m := circumference_cm/100]
inra_arbres[, hdn := sqrt(circumference_m)/height]
inra_arbres[, slenderness := height/circumference_m]

## In the original model, there are the variables formTot, and formTotNew. I need to rebuild them
inra_arbres[, formTot := 4*pi*volume_m3/(height*circumference_m^2)]
inra_arbres[, formTotNew := formTot * (1 - 1.3/height)^2]
inra_arbres[, feuil.res := as.factor(fct_type)]

## Indices
# Find start and end indices for each species
setkey(inra_arbres, fct_type, speciesName_sci, unique_id)
ind_species = inra_arbres[, .(start = .I[1], end = .I[.N]), by = .(speciesName_sci)]
ind_species[, n_indiv := end - start + 1, by = speciesName_sci]

if (ind_species[, sum(n_indiv)] != inra_arbres[, .N])
	stop("The number of individuals in ind_species does not correspond to the number of individuals in inra_arbres!")

ind_species = merge.data.table(ind_species, unique(inra_arbres[, .(speciesName_sci, fct_type)]), by = "speciesName_sci")
ind_species[, colour := if(fct_type == "broadleaf") "#FFAF37" else "#007BA5", by = speciesName_sci]
setorder(ind_species, start)

n_sp = ind_species[, .N, by = fct_type]
setkey(n_sp, fct_type)

## Stan data
stanData = list(
	N = inra_arbres[, .N],
	S = ind_species[, .N],
	n_sp_conif = n_sp["conifer", N],
	n_sp_broad = n_sp["broadleaf", N],
	ind_start_broad = ind_species[fct_type == "broadleaf", start],
	ind_start_conif = ind_species[fct_type == "conifer", start],
	ind_end_broad = ind_species[fct_type == "broadleaf", end],
	ind_end_conif = ind_species[fct_type == "conifer", end],
	height = inra_arbres[, height],
	circumference_m = inra_arbres[, circumference_cm/100],
	volume_m3 = inra_arbres[, volume_m3]
)
```

The data are now ready! Here is the composition:
```{r}
#| echo: false
#| label: fig-data
#| fig-cap: "Number of individuals per species, with conifers in blue and broadleaves in orange. Watch out, it is a $\\log_{10}$ scale"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
species_nb = ind_species[, .(speciesName_sci, n_indiv, colour)]
setorder(species_nb, n_indiv)

par(mar = c(5, 12, 2, 2))
# Use barplot f or horizontal bars
barplot(
	species_nb[, n_indiv],
	names.arg = species_nb[, speciesName_sci],
	horiz = TRUE, # Horizontal bars
	xlab = "Number of individuals",
	ylab = "",
	main = "",
	las = 1,
	log = "x",
	col = species_nb[, colour]
)
abline(v = 30, lwd = 2, lty = "dashed", col = "#CD212A")
```
The correlation between the hardiness and the slenderness is `{r} round(inra_arbres[, cor(hdn, slenderness)], 2)`, which is expected and I guess problematic...

### Data for posterior checks
```{r}
## Add species to the profiles
setDT(emerge_2010_profils)
setDT(emerge_2010_arbres)

emerge_2010_arbres = unique(emerge_2010_arbres[, .(tree, species)])
emerge_2010_profils = emerge_2010_arbres[emerge_2010_profils, on = "tree"]

## Compute dbh top/bottom of each log
emerge_2010_profils[, dbh_bottom_m := circ_bas_cm/(100*pi)]
emerge_2010_profils[, dbh_top_m := circ_haut_cm/(100*pi)]

## Reorganising
emerge_2010_profils[, species := as.character(species)]
setorder(emerge_2010_profils, tree, niveau_bas_m)
emerge_2010_profils[, id := NULL]
setnames(x = emerge_2010_profils, old = c("niveau_bas_m", "niveau_haut_m"), c("h_bottom", "h_top"))
emerge_2010_profils = emerge_2010_profils[, .(tree, species, dbh_bottom_m, dbh_top_m, h_bottom, h_top)]

## Compute log and cumulated volumes
emerge_2010_profils[, h_tot := max(h_top), by = tree]
emerge_2010_profils[, vol_tot := pi/12*max(dbh_bottom_m)^2*h_tot, by = tree]
emerge_2010_profils[, vol_log := pi/12*dbh_bottom_m^2*(h_tot - h_bottom) - pi/12*dbh_top_m^2*(h_tot - h_top)]

emerge_2010_profils[, cumulated_vol := cumsum(vol_log), by = tree]
emerge_2010_profils[, cumulated_percent_vol := cumulated_vol/vol_tot, by = tree]

data_check = unique(emerge_2010_profils[, .(tree, species, vol_tot)]) #! RESTART HERE I NEED ALSO THE DBH AND HTOT
library(data.table)

tree_dt = data.table(species = c("Frêne", "Chêne vert", "Tilia cordata", "Chêne sessile", "Eucalyptus",
		"Robinier", "Pin Alep", "Chêne pubescent", "Aulne", "Bouleau"),
	speciesName_sci = c("Fraxinus excelsior", "Quercus ilex", "Tilia cordata", "Quercus petraea", "Eucalyptus spp.",
		"Robinia pseudoacacia", "Pinus halepensis", "Quercus pubescens", "Alnus glutinosa", "Betula pendula"))
data_check = merge.data.table(data_check, tree_dt, by = "species")
data_check[, species := NULL]
setkey(data_check, speciesName_sci)
```

## Model using `CmdStanR`
I use the following model, which has been tested with simulated data in `00_notes.qmd`:
```{stan output.var = "stan_deleuze", cache = TRUE}
data {
	// Dimensions and indices
	int N; // Number of individuals
	int S; // Number of species
	int<lower = 0, upper = S> n_sp_broad; // number of broadleaf species
	int<lower = S - n_sp_broad, upper = S - n_sp_broad> n_sp_conif; // number of conifer species
	array[n_sp_broad] int ind_start_broad; // Broadleaf species index start
	array[n_sp_conif] int ind_start_conif; // Conifer species index start
	array[n_sp_broad] int ind_end_broad; // Broadleaf species index end
	array[n_sp_conif] int ind_end_conif; // Conifer species index end

	// Predictors
	vector<lower = 0> [N] height;
	vector<lower = 0> [N] circumference_m;

	// Response variable
	vector [N] volume_m3;
}

transformed data {
	vector [N] hdn = sqrt(circumference_m) ./ height;
	vector [N] slenderness = height ./ circumference_m;
	vector [N] corrected_cyl_vol = height .* circumference_m^2 ./ (4*pi()*(1 - 1.3/height)^2);
}

parameters {
	// Fixed effects (population parameters) for broadleaf and conifer
	vector[2] b0;
	vector[2] b1;
	vector[2] b2;
	
	// Random effects (group parameters)
	// vector[S] eta0;
	// vector[S] eta2;
	vector[S] beta0;
	vector[S] beta2;

	// Variances
	real<lower = 0> sigma; // sd residuals
	real<lower = 0> sigma_beta0; // sd random effect beta0
	real<lower = 0> sigma_beta2; // sd random effect beta2
}

// transformed parameters {
// 	vector[S] beta0;
// 	vector[S] beta2;
	
// 	beta0[1:n_sp_broad] = b0[1] + eta0[1:n_sp_broad]*sigma_beta0;
// 	beta0[(n_sp_broad + 1):S] = b0[2] + eta0[(n_sp_broad + 1):S]*sigma_beta0;
	
// 	beta2[1:n_sp_broad] = b2[1] + eta2[1:n_sp_broad]*sigma_beta2;
// 	beta2[(n_sp_broad + 1):S] = b2[2] + eta2[(n_sp_broad + 1):S]*sigma_beta2;
// }

model {
	// Priors
	// --- Population parameters
	target += normal_lpdf(b0 | 0, 1);
	target += normal_lpdf(b1 | 2, 1);
	target += normal_lpdf(b2 | 0, 0.2);

	// --- Residual variance and population variance
	target += inv_gamma_lpdf(sigma | 2, 1); // Uses shape and scale (which is the rate from gamma perspective)
	target += inv_gamma_lpdf(sigma_beta0 | 3, 0.5);
	target += inv_gamma_lpdf(sigma_beta2 | 3, 0.5);

	// Hierarchy
	target += normal_lpdf(beta0[1:n_sp_broad] | b0[1], sigma_beta0);
	target += normal_lpdf(beta2[1:n_sp_broad] | b2[1], sigma_beta2);
	target += normal_lpdf(beta0[(n_sp_broad + 1):S] | b0[2], sigma_beta0);
	target += normal_lpdf(beta2[(n_sp_broad + 1):S] | b2[2], sigma_beta2);
	// target += normal_lpdf(eta0 | 0, 1);
	// target += normal_lpdf(eta2 | 0, 1);

	// Likelihood broadleaves, i = species
	for (i in 1:n_sp_broad)
	{
		target += normal_lpdf(volume_m3[ind_start_broad[i]:ind_end_broad[i]] |
			(beta0[i] +
			b1[1]*hdn[ind_start_broad[i]:ind_end_broad[i]] +
			beta2[i]*slenderness[ind_start_broad[i]:ind_end_broad[i]]) .*
			corrected_cyl_vol[ind_start_broad[i]:ind_end_broad[i]],
			sigma);
	}

	// Likelihood conifers, i = species
	for (i in 1:n_sp_conif)
	{
		target += normal_lpdf(volume_m3[ind_start_conif[i]:ind_end_conif[i]] |
			(beta0[n_sp_broad + i] +
			b1[2]*hdn[ind_start_conif[i]:ind_end_conif[i]] +
			beta2[n_sp_broad + i]*slenderness[ind_start_conif[i]:ind_end_conif[i]]) .*
			corrected_cyl_vol[ind_start_conif[i]:ind_end_conif[i]],
			sigma);
	}
}
```

The commented parts correspond to a [non-centred parametrisation](https://betanalpha.github.io/assets/case_studies/hierarchical_modeling.html), which did not work in my case. I now do the standard procedure for a Bayesian analysis:

1. Computational model checks using fake data simulation (done in `00_notes.qmd`) and the prior predictive distribution (done in @sec-prior_check)
2. Run the model (in @sec-run)
3. Posterior predictive checks

### Prior predictive checks {#sec-prior_check}
```{r}
n_sim = 20
gen_data = vector(mode = "list", length = 20)
S = ind_species[, .N]
volume = numeric(length = inra_arbres[, .N])

corrected_cyl_vol = inra_arbres[, height]*inra_arbres[, circumference_m^2]/(4*pi*(1 - 1.3/inra_arbres[, height])^2)

for (sim in seq_len(n_sim))
{
	# Simulate the variances
	sigma = 1/rgamma(n = 1, shape = 2, rate = 1);
	sigma_beta0 = 1/rgamma(n = 1, shape = 3, rate = 0.5);
	sigma_beta2 = 1/rgamma(n = 1, shape = 3, rate = 0.5);

	# Simulate the common group intercepts and hdn/slenderness slopes
	b0 = rnorm(n = 2, mean = 0, sd = 1);
	b1 = rnorm(n = 2, mean = 2, sd = 1);
	b2 = rnorm(n = 2, mean = 0, sd = 0.2);

	# Simulate group-specific intercepts and slenderness slopes
	n_sp_broad = stanData[["n_sp_broad"]]
	n_sp_conif = stanData[["n_sp_conif"]]
	beta0 = numeric(length = S)
	beta2 = numeric(length = S)
	beta0[1:n_sp_broad] = rnorm(n = n_sp_broad, mean = b0[1], sd = sigma_beta0);
	beta0[(n_sp_broad + 1):S] = rnorm(n = n_sp_conif, mean = b0[2], sd = sigma_beta0);
	beta2[1:n_sp_broad] = rnorm(n = n_sp_broad, mean = b2[1], sd = sigma_beta2);
	beta2[(n_sp_broad + 1):S] = rnorm(n = n_sp_conif, mean = b2[2], sd = sigma_beta2);

	# Simulate individual volume data
	# --- Broadleaves
	for (s in 1:n_sp_broad)
	{
		ind_start = ind_species[s, start]
		ind_end = ind_species[s, end]
		n_indiv = ind_species[s, n_indiv]
		
		volume[ind_start:ind_end] = rnorm(n = n_indiv, mean = (beta0[s] +
			b1[1]*inra_arbres[ind_start:ind_end, hdn] +
			beta2[s]*inra_arbres[ind_start:ind_end, slenderness]) * corrected_cyl_vol[ind_start:ind_end],
			sd = sigma);
	}

	# --- Conifers
	for (s in (n_sp_broad + 1):S)
	{
		ind_start = ind_species[s, start]
		ind_end = ind_species[s, end]
		n_indiv = ind_species[s, n_indiv]
		
		volume[ind_start:ind_end] = rnorm(n = n_indiv, mean = (beta0[s] +
			b1[2]*inra_arbres[ind_start:ind_end, hdn] +
			beta2[s]*inra_arbres[ind_start:ind_end, slenderness]) * corrected_cyl_vol[ind_start:ind_end],
			sd = sigma);
	}

	gen_data[[sim]] = data.table(volume = volume)
}

gen_data = rbindlist(l = gen_data, idcol = "simulation")

hist(gen_data[, volume])
```

### Run the model {#sec-run}
```{r}
n_chains = 4
# woodstock_seed = 1969 - 08 - 18
iter_warmup = 750
iter_sampling = 1250

## Fit
if (!file.exists("fit_deleuze.rds"))
{
	fit = stan_deleuze$sample(data = stanData, chains = n_chains, parallel_chains = ifelse(n_chains < 4, n_chains, 4),
		seed = NULL, refresh = 200, max_treedepth = 12, save_warmup = TRUE,
		iter_sampling = iter_sampling, iter_warmup = iter_warmup, adapt_delta = 0.95)
	fit$save_output_files(dir = "./", basename = paste0("fit_deleuze"), random = FALSE)
	saveRDS(fit, "./fit_deleuze.rds")
} else {
	fit = readRDS("./fit_deleuze.rds")
}

# mcmc_rhat(bayesplot::rhat(fit))
# mcmc_neff(bayesplot::neff_ratio(fit))
# mcmc_nuts_divergence(bayesplot::nuts_params(fit), lp = log_posterior(fit))

# mcmc_scatter(x = fit$draws(c("b2[1]", "b1[1]")), alpha = 1, np = nuts_params(fit))
# mcmc_hex(x = fit$draws(c("b0[1]", "b1[1]")))

# mcmc_pairs(x = fit$draws(c("b0", "b1", "b2", "sigma")), np = nuts_params(fit))
```

### Posterior predictive checks
```{stan output.var = "genQ", cache = TRUE}
data {
	// Dimensions and indices
	int N; // Number of individuals
	int S; // Number of species
	int<lower = 0, upper = S> n_sp_broad; // number of broadleaf species
	int<lower = S - n_sp_broad, upper = S - n_sp_broad> n_sp_conif; // number of conifer species
	array[n_sp_broad] int ind_start_broad; // Broadleaf species index start
	array[n_sp_conif] int ind_start_conif; // Conifer species index start
	array[n_sp_broad] int ind_end_broad; // Broadleaf species index end
	array[n_sp_conif] int ind_end_conif; // Conifer species index end

	// Predictors
	vector<lower = 0> [N] height;
	vector<lower = 0> [N] circumference_m;

	// Response variable
	vector [N] volume_m3;
}

transformed data {
	vector [N] hdn = sqrt(circumference_m) ./ height;
	vector [N] slenderness = height ./ circumference_m;
	vector [N] corrected_cyl_vol = height .* circumference_m^2 ./ (4*pi()*(1 - 1.3/height)^2);
}

parameters {
	// Fixed effects (population parameters) for broadleaf and conifer
	vector[2] b0;
	vector[2] b1;
	vector[2] b2;
	
	// Random effects (group parameters)
	// vector[S] eta0;
	// vector[S] eta2;
	vector[S] beta0;
	vector[S] beta2;

	// Variances
	real<lower = 0> sigma; // sd residuals
	real<lower = 0> sigma_beta0; // sd random effect beta0
	real<lower = 0> sigma_beta2; // sd random effect beta2
}

generated quantities {
	;
}
```

```{r}

genQ$generate_quantities
```
## Model using `nlme`
This is the model and package used in @Deleuze2014:
```{r}
Modele_mai2 = nlme(formTotNew ~ a + b*hdn + d*slenderness, data = inra_arbres,
	start = c(a = 0.4, 0, b = 1.5, 0, d = 0.0005, 0),
	fixed = list(a + b + d ~ feuil.res), random = a + d ~ 1|speciesName_sci)
```

Rebuild the parameters for *Fagus sylvatica*:
```{r}
## Rebuild species-specific params from nlme
fixed_effects = fixed.effects(Modele_mai2)
# random_effects = ranef(Modele_mai2)[sp_name, ]

# if (nrow(random_effects) != 1)
# 	stop("Dimensions mismatch")

# b0_nlme = fixed_effects["a.(Intercept)"] + random_effects[1, "a.(Intercept)"] +
# 	if (select_tp == 2) fixed_effects["a.feuil.resconifer"] else 0

# b1_nlme = fixed_effects["b.(Intercept)"] + if (select_tp == 2) fixed_effects["b.feuil.resconifer"] else 0

# b2_nlme = fixed_effects["d.(Intercept)"] + random_effects[1, "d.(Intercept)"] +
# 	if (select_tp == 2) fixed_effects["d.feuil.resconifer"] else 0

# species_params_nlme = round(c(beta0 = unname(b0_nlme), b1 = unname(b1_nlme), beta2 = unname(b2_nlme)), 4)

```

## Model using `lme4`
This is the equivalent model with the package `lme4`:
```{r}
test_lme4 = lme4::lmer(formTotNew ~ feuil.res * (hdn + slenderness) + (1 + slenderness | speciesName_sci), data = inra_arbres)
```

```{r}
fixed_effects_lme4 = lme4::fixef(test_lme4)
# random_effects_lme4 = lme4::ranef(test_lme4)$speciesName_sci[sp_name, c("(Intercept)", "slenderness")]

# if (nrow(random_effects_lme4) != 1)
# 	stop("Dimensions mismatch")

# b0_lme4 = fixed_effects_lme4["(Intercept)"] + random_effects_lme4[1, "(Intercept)"] +
# 	if (select_tp == 2) fixed_effects_lme4["feuil.resconifer"] else 0

# b1_lme4 = fixed_effects_lme4["hdn"] + if (select_tp == 2) fixed_effects_lme4["feuil.resconifer:hdn"] else 0

# b2_lme4 = fixed_effects_lme4["slenderness"] + random_effects_lme4[1, "slenderness"] +
# 	if (select_tp == 2) fixed_effects_lme4["feuil.resconifer:slenderness"] else 0
```



