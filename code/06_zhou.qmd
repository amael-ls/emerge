---
title: "Simple tests of bole volume models"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
  warning: false
  message: false
bibliography: /home/ALe-Squin/work/library/bib_file/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\Vtot}{V_{\text{tot}}}
\newcommand{\Vzh}{V_{\text{Zhou}}}
\newcommand{\hdec}{h_{\text{dec}}}
\newcommand{\fmax}{f_{\text{max}}}

<!-- Math operators -->
<!-- \DeclareMathOperator{\ln}{ln} -->

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   LOADING DATA, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(inventR)
library(stringi)
library(interp)
library(DHARMa)
library(shape)
library(loo)

## Tool function
source("./toolFunctions.R")

plot_sp = function(fit, sp, count, stanData, fun, args, forest = forest_dt[.(sp)],
	pred = FALSE, n_subsample = 10, folder = NULL, add = TRUE)
{
	# Get parameters
	start = stanData[["start"]][count]
	end = stanData[["end"]][count]
	n_sampling = fit$metadata()$iter_sampling
	n_chains = fit$num_chains()

	if (n_chains != nrow(fit$metadata()$time))
	{
		warning("Some chains are missing probably because they could not start! Using the number of successful chains")
		n_chains = nrow(fit$metadata()$time)
	}

	# Plot figure
	if (!is.null(folder))
		png(paste0("./", folder, "/", sp, ".png"))
	plot(forest[, bole_volume_m3], forest[, total_ratio], pch = 19, col = "#3355AA33", axes = FALSE,
		xlab = "Bole volume", ylab = "Ratio bole/tot volumes", main = sp)
	axis(1)
	axis(2, las = 1)

	# Plot prediction
	if (pred)
	{
		sim = fit$draws("r_gen")[sample(x = 1:n_sampling, size = n_subsample, replace = FALSE), , start:end]
		for (i in 1:forest[, .N])
			points(rep(forest[i, bole_volume_m3], n_chains*n_subsample),
				as.numeric(sim[, , i]), col = "#335577AA", pch = ".")
	}

	# Plot fitted curve
	if (length(args) == 2 && all(c("k", "lambda") == args))
	{
		selected_params = c(paste0("k[", count, "]"), paste0("lambda[", count, "]"))
		params = apply(X = fit$draws(args)[, , selected_params], MARGIN = 3, FUN = mean)

		curve(fun(x, params[1], params[2]), col = "#CD212A", lwd = 2, add = add, n = 501)
	}
	
	if (length(args) == 3 && all(c("beta_", "gamma", "b") == args))
	{
		selected_params = c(paste0("beta_[", count, "]"),
			paste0("gamma[", count, "]"), paste0("b[", count, "]"))
		params = apply(X = fit$draws(args)[, , selected_params], MARGIN = 3, FUN = mean)

		curve(fun(x, 1, params[1], params[2], params[3]), col = "#CD212A", lwd = 2, n = 501, add = add)
	}

	if (length(args) == 3 && all(c("m", "k", "d") == args))
	{
		selected_params = c(paste0("m[", count, "]"), paste0("k[", count, "]"), paste0("d[", count, "]"))
		params = apply(X = fit$draws(args)[, , selected_params], MARGIN = 3, FUN = mean)

		curve(fun(x, params[1], params[2], params[3]), col = "#CD212A", lwd = 2, n = 501, add = add)
	}

	if (length(args) == 4 && all(c("alpha", "beta_", "gamma", "b") == args))
	{
		selected_params = c(paste0("alpha[", count, "]"), paste0("beta_[", count, "]"),
			paste0("gamma[", count, "]"), paste0("b[", count, "]"))
		params = apply(X = fit$draws(args)[, , selected_params], MARGIN = 3, FUN = mean)

		curve(fun(x, params[1], params[2], params[3], params[4]), col = "#CD212A", lwd = 2, add = add, n = 501)
	}
	if (!is.null(folder))
		dev.off()
}
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra", opt, ".rds"))
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra", opt, ".rds"))
check_data = readRDS(paste0(path_data, "emerge_2009-2010.rds"))

colours = paste0(met.brewer("Egypt")[1:4])
names(colours) = c("conifer", "broadleaf", "inra", "nfi")

forest_dt[fct_type == "broadleaf", fct_colour := colours["broadleaf"]]
forest_dt[fct_type == "conifer", fct_colour := colours["conifer"]]
forest_dt[origin_data == "inra", origin_colour := colours["inra"]]
forest_dt[origin_data == "nfi", origin_colour := colours["nfi"]]

## Add vernacular english names
# vernacularNames = sci2comm(sci = forest_dt[, unique(speciesName_sci)], db = "itis")
```

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   MAIN CONTENT, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

## Introduction
Florence Gohon a travaillé sur des modèles de volume bois-fort tige, $\Vbft$ qui sont consultables (en local) dans le document `~/work/FairCarbon/gohon/rapport_tarifs.pdf`:
$$
	\Vbft = \frac{c^2h}{4\pi \left( 1 - \frac{1.3}{h} \right)^2} \left[ \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec} + \delta_i \frac{\sqrt{\hdec}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec}{h} \right) \right]
$$

Pour l'instant, les tarifs utilisés par l'inventaire sont (facteurs de forme):

- $\Fbft = \left[ \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \frac{\hdec}{\hdec + k} + \frac{\delta}{c^{\epsilon}} \right] \left[ 1 - \left(\frac{0.07 \pi}{c}\right)^3 \left(1 - \frac{1.3}{h}\right)^3 \right]$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \left( \frac{\hdec}{\hdec + k} \right)^{1 + \rho} + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \eta \hdec + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln \left(\frac{\hdec}{h} \right) + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln(\hdec) + \frac{\delta}{c^{\epsilon}}$

Cependant, ces modèles sont peu interprétables physiquement et ressemble plus à un 'fit polynomial'. Ils ont aussi pour défaut de faire des prédictions peu fiable dès lors que la circonférence, $c$, se rapproche des bornes de l'intervalle de calibration. Il y a donc des rustines dans les scripts SQL. Cependant, je conserve ces tarifs de bois-fort tige pour l'instant, car il est très difficile de les modifier (problème complexe avec grande variabilité, inertie de l'historique des tarifs, rupture de série) et je n'ai aucune idée de modèle pour $\Vbft$!

Dans les prochaines sections, je vais explorer des modèles simples et compréhensibles physiquement pour le volume total en me basant sur la littérature. Le volume bois-fort tige sera la variable d'entrée, donc il faudra qu'elle soit fiable... Les modèles explorés (en cours d'exploration...) sont les suivants:

1. Ratio $\Vbft$ sur $\Vtot$ [@Zhou2021, @Longuetaud2013]
2. Relation bizzare avec le volume $\Vzh$ (voir @sec-vzh)
3. Un modèle conjoint (genre loi multi-lognormal??)

## First model: ratio of $\Vbft$ over $\Vtot$

In @Longuetaud2013, the authors model the Volume Expansion Factor, $\text{VEF} = \Vtot/\Vbft$, in function of the bole volume. By definition, VEF is above 1. For large trees, it is common to see VEF decreasing around 1. They use a Gaussian distribution, which is problematic as it can go below 1 for large trees, which does not make sense physically (total volume smaller than bole volume!). Therefore it must be done differently.

### A test model
I model the opposite of the VEF, \ie $r = \Vbft/\Vtot$, which is by construction between 0 and 1. It represents the percentage of volume represented by the bole. A Beta-distribution seems perfect for that, it respects the bounds and accounts for heteroskedasticity. However, its parameters $\text{shape}_1$ and $\text{shape}_2$ are not intuitive. Fortunately, it is possible to reparametrise the Beta-distrib in function of mean and precision, $\phi$:

- $\text{shape}_1 = \phi \mu$
- $\text{shape}_2 = \phi (1 - \mu)$

Using the mean and variance is of no good idea: it adds an interacting constraint $\sigma^2 < \mu (1 - \mu)$.

I do a first test with:
$$
	\mu = x^k \exp[-x/\lambda],
$$
where $x$ is the bole volume, $\Vbft$, and $k$, $\lambda$ parameters to be estimated, with the constraint $0 < k < e^1/\lambda$ and $\lambda > 0$ ($x > 0$, but this is more a fact than a constraint).

```{r}
## Subset data
forest_dt = forest_dt[origin_data == "inra"]
forest_dt[, nb_indiv := .N, by = speciesName_sci]
forest_dt = forest_dt[nb_indiv > 50]

setkey(forest_dt, speciesName_sci)
ls_species = forest_dt[, unique(speciesName_sci)]

## Compute ratio
forest_dt[, total_ratio := bole_volume_m3/total_volume_m3]
```


```{stan output.var = "betareg_simple", cache = TRUE}
functions {
	vector r_zhou(vector x, real k, real lambda)
	{
		return x.^k .* exp(-x / lambda);
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1, upper = N> G; // Number of genus
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] SB;

	// Data
	vector[N] AGB;
}

transformed data {
	vector[N] ratio = SB ./ AGB;
}

parameters {
	// Parameters of the 'simple' function r_zhou (simple compared to the flexibility I want)
	vector <lower = 0> [G] lambda;
	vector <lower = 0, upper = exp(1) ./ lambda> [G] k;

	real <lower = 0> phi; // Precision (well kind of...)
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi*r_zhou(SB[start[i]:end[i]], k[i], lambda[i]);
		shape2[start[i]:end[i]] = phi*(1 - r_zhou(SB[start[i]:end[i]], k[i], lambda[i]));
	}
}

model{
	// Priors
	target += normal_lpdf(k | 0, 10);
	target += normal_lpdf(lambda | 0, 10);
	target += normal_lpdf(phi | 0, 10);
	
	// Likelihood
	target += beta_lpdf(ratio | shape1, shape2);
}

generated quantities {
	array[N] real r_gen = beta_rng(shape1, shape2);
}

```

```{r}
#### Test simple beta regression model on the forest data
## Run model
# Common variables
n_chains = 4

stanData = list(
	N = forest_dt[, .N],
	G = forest_dt[, length(unique(speciesName_sci))],
	start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
	end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

	# Predictors
	SB = forest_dt[, bole_volume_m3], # Same as reconstruct one

	# Data
	AGB = forest_dt[, total_volume_m3]
)

# Run
if (!file.exists("./fit_zhou_beta.rds"))
{
	fit = betareg_simple$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fit_zhou_beta"), random = FALSE)
	saveRDS(fit, "./fit_zhou_beta.rds")
} else {
	fit = readRDS("./fit_zhou_beta.rds")
}
```

### Results
```{r}
#| label: fig-results_simple
#| fig-cap: Correlation between the bole volume and the total volume
#| fig-subcap:
#|   - "Abies alba"
#|   - "Carpinus betulus"     
#|   - "Cedrus atlantica"
#|   - "Fagus sylvatica"      
#|   - "Fraxinus excelsior"
#|   - "Larix decidua"        
#|   - "Picea abies"
#|   - "Pinus halepensis"     
#|   - "Pinus laricio"
#|   - "Pinus nigra"          
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"     
#|   - "Pinus uncinata"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#|   - "Quercus rubra"        
#|   - "Quercus sp."
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

# Plot output
r_zhou = function(x, k, lambda)
	return (x^k*exp(-x/lambda))

count = 0

for (sp in ls_species)
{
	count = count + 1
	plot_sp(fit, sp, count, stanData, fun = r_zhou, args = c("k", "lambda"), pred = TRUE, n_subsample = 1)
}
```

It seems that this function is not flexible enough (see results in @fig-results_simple)... I switch to a more flexible function (see @fig-flexible_fct) with four parameters:
$$
\mu(x; \alpha, \beta, \gamma, b) = \alpha \exp[-\beta x] (x - b/\alpha) + \gamma x + b.
$$ {#eq-flexible}
However, 4 parameters seems to be impossible to fit (too many degrees of freedom I think). Indeed, this parameter is involved in the maximum height of the $\mu$, reached for:
$$
x^{*} = \frac{b}{\alpha} + \frac{1}{\beta} \left( 1 - W_p \left[ -\frac{\gamma}{\alpha} e^{\beta b/\alpha + 1} \right] \right),
$$
where $W_p$ is the positive branch of the Lambert function, and is then also involved in the curvature. Thus, I fix $\alpha = 1$.

::: {.callout-note }

This value of $x^{*}$ assumes $\gamma < 0$ which is the case (I set that constraint in the model). The condition to use $W_p$ is also always satisfied: $-\gamma/\alpha e^{\beta b/\alpha + 1} > -e^{-1}$ as $\gamma < 0$ and $\alpha > 0$. For the constraints and the calculus, see notebook 2, p. 64 (entry 2025.05.12).

:::

```{r}
#| label: fig-flexible_fct
#| fig-cap: Different shape of the flexible function $\mu$ for 7 values of $\alpha$ while the other parameters kept fixed
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

#### Should I keep alpha in the following ff function?
ff = function(x, alpha, beta = 0.8, gamma = -0.04, b = 0.8)
	return (alpha*exp(-beta*x) * (x - b/alpha) + gamma*x + b)

curve(ff(x, 0.1), from = 0, to = 11, lwd = 3, col = met.brewer("Homer1")[1], ylim = c(0, 1), axes = FALSE, xlab = "x", ylab = "f")
for (i in 2:7)
	curve(ff(x, i/10), from = 0, to = 11, lwd = 3, col = met.brewer("Homer1")[i], add = TRUE)
axis(1)
axis(2, las = 1)
legend(x = "topright", fill = met.brewer("Homer1"), legend = (1:7)/10, bty = "n")

## ANSWER: I DO NOT KNOW, BUT I FOUND SOME CONSTRAINTS THAT COULD HELP THE MODEL
```

### Results with a more flexible function {#sec-flexible}

```{stan output.var = "betareg_flexible", cache = TRUE}
functions {
	vector r_zhou(vector x, real beta_, real gamma, real b)
	{
		return exp(-beta_*x) .* (x - b) + gamma*x + b;
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1, upper = N> G; // Number of genus
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] SB;

	// Data
	vector[N] AGB;
}

transformed data {
	vector[N] ratio = SB ./ AGB;

	vector[G] SB_max;
	for (i in 1:G)
		SB_max[i] = max(SB[start[i]:end[i]]);
}

parameters {
	// Parameters of the 'bumpy' function r_zhou
	vector <lower = 0> [G] beta_;
	vector <lower = 0, upper = 1> [G]  b;
	vector <lower = -b ./ SB_max, upper = 0> [G] gamma; // I expect d to be negative

	real <lower = 0> phi; // Precision (well kind of...)
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi*r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]);
		shape2[start[i]:end[i]] = phi*(1 - r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]));
	}
}

model{
	// Prior linear regression
	target += normal_lpdf(beta_ | 0, 10);
	target += normal_lpdf(b | 0.5, 0.15);
	target += normal_lpdf(gamma | 0, 10);
	
	// Likelihood
	target += beta_lpdf(ratio | shape1, shape2);
}

generated quantities {
	array[N] real r_gen = beta_rng(shape1, shape2);
	array[N] real v_gen;
	for (i in 1:N)
		v_gen[i] = SB[i] / r_gen[i];
}

```

```{r}
## Run model
# Common variables
n_chains = 4

stanData = list(
	N = forest_dt[, .N],
	G = forest_dt[, length(unique(speciesName_sci))],
	start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
	end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

	# Predictors
	SB = forest_dt[, bole_volume_m3], # Same as reconstruct one

	# Data
	AGB = forest_dt[, total_volume_m3]
)

if (!file.exists("./fit_zhou_beta_flexible.rds"))
{
	fit = betareg_flexible$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fit_zhou_beta_flexible"), random = FALSE)
	saveRDS(fit, "./fit_zhou_beta_flexible.rds")
} else {
	fit = readRDS("./fit_zhou_beta_flexible.rds")
}
```

```{r}
#| label: fig-results_flexible
#| fig-cap: Results with the flexible function
#| fig-subcap:
#|   - "Abies alba"
#|   - "Carpinus betulus"     
#|   - "Cedrus atlantica"
#|   - "Fagus sylvatica"      
#|   - "Fraxinus excelsior"
#|   - "Larix decidua"        
#|   - "Picea abies"
#|   - "Pinus halepensis"     
#|   - "Pinus laricio"
#|   - "Pinus nigra"          
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"     
#|   - "Pinus uncinata"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#|   - "Quercus rubra"        
#|   - "Quercus sp."
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

count = 0

for (sp in ls_species)
{
	count = count + 1
	plot_sp(fit, sp, count, stanData, fun = ff, args = c("beta_", "gamma","b"), pred = TRUE, n_subsample = 1)
}
```

### Residuals flexible model

```{r}
#| label: fig-residuals_flexible
#| fig-cap: Residuals
#| fig-subcap:
#|   - "Abies alba"
#|   - "Abies alba"
#|   - "Carpinus betulus"
#|   - "Carpinus betulus"
#|   - "Cedrus atlantica"
#|   - "Cedrus atlantica"
#|   - "Fagus sylvatica" 
#|   - "Fagus sylvatica" 
#|   - "Fraxinus excelsior"
#|   - "Fraxinus excelsior"
#|   - "Larix decidua"
#|   - "Larix decidua"
#|   - "Picea abies"
#|   - "Picea abies"
#|   - "Pinus halepensis"
#|   - "Pinus halepensis"
#|   - "Pinus laricio"
#|   - "Pinus laricio"
#|   - "Pinus nigra"
#|   - "Pinus nigra"
#|   - "Pinus pinaster"
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"
#|   - "Pinus sylvestris"
#|   - "Pinus uncinata"
#|   - "Pinus uncinata"
#|   - "Pseudotsuga menziesii"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#|   - "Quercus petraea"
#|   - "Quercus rubra"
#|   - "Quercus rubra"
#|   - "Quercus sp."
#|   - "Quercus sp."
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8
#| layout-ncol: 1

n_sampling = fit$metadata()$iter_sampling

simResp = fit$draws("r_gen")
dim(simResp)
n_chains = dim(simResp)[2] # Number of successful chains

# Reshape simResp as a matrix nobs x n_repetition
simResp_matrix = matrix(data = 0, nrow = forest_dt[, .N], ncol = n_sampling*n_chains)
for (obs in seq_len(forest_dt[, .N]))
	for (chain in 1:n_chains)
		simResp_matrix[obs, ] = simResp[, chain, obs] # One line of n_sampling*n_chains simulations per observation

## Simulated residuals
for (i in seq_along(stanData[["start"]]))
{
	start = stanData[["start"]][i]
	end = stanData[["end"]][i]
	sim_dharma = createDHARMa(simulatedResponse = simResp_matrix[start:end, ],
		observedResponse = forest_dt[start:end, total_ratio],
		fittedPredictedResponse = apply(simResp[, , start:end], MARGIN = 3, median),
		integerResponse = FALSE)

	plot(sim_dharma, quantreg = TRUE)
	plotResiduals(sim_dharma, forest_dt[start:end, bole_volume_m3], quantreg = TRUE)
}
```

## Second model: relation between $\Vzh$ and $\Vtot$ {#sec-vzh}

This idea is based on the allometric scaling of tree biomass and size [@Zhou2021].

::: {.callout-note}

## Allometry 101

The hypothesis of allometry is that a biological variable $Y$ is related to the mass $M$ of an organism by power-law:
$$
Y = Y_0 M^b,
$$
where $Y_0$ is a constant, and $b$ is the *scaling exponent* or *allometric exponent*. Physics uses *scaling equation*, while biology uses *allometric* [@daSilva2006].

:::

The equation of interest is the 6th from @Zhou2021 as everything derives from it. Starts from the following equation which is *mutatis mutandis* the allometric equation:
$$
y = a x^{\psi}.
$$ {#eq-allometric}

If I log-differentiate @eq-allometric, I get:
\begin{align*}
	\log(y) &= \log(a) + \psi \log(x) \\
	\frac{d\log(y)}{dx} &= \frac{\psi}{x} \\
	\frac{1}{y}\frac{dy}{dx} &= \frac{\psi}{x} \\
	\psi &= \frac{dy/y}{dx/x},
\end{align*}
which is exactly equation 6 from @Zhou2021. In other words, the relative change in $y$, $dy/y$ is proportional to the relative change in $x$, $dx/x$, with a factor $\psi$. Maybe there is a finite difference method approx in @Zhou2021, to replace $dy$ by $\Delta y$, or maybe it is just a notation difference... I suspect that the authors kept it analytic and $\Delta$ is just a notation.

Then, they assume that:
$$
\psi = 1 - \frac{kx}{p(\exp[kx] - 1)}.
$$
Starting from $\psi = \frac{dy/y}{dx/x}$, we get:
\begin{align*}
	\int \frac{dy}{y} &= \int \psi(x) \frac{dx}{x} \\
	\ln(y) &= \ln(x) - \int \frac{k}{p \exp[kx] - 1} \, dx \\
	&= \ln(x) - \ln(p - \exp[-kx]) + c,
\end{align*}
where $c$ is an integration constant. Now use exponetial to get:
$$
y = \omega x^{1 - \ln(p - \exp[-kx])/\ln(x)}
$$
which is the equation 1 of @Zhou2021, with $\Omega = \ln(p - \exp[-kx])/\ln(x)$. Then, to get the second equation of @Zhou2021, just (see his appendices) set $p = m/d$, compute many stuff, and you will reach:
$$
y = \frac{x}{m - d\exp[-kx]},
$$
that is to say,
$$
	m - d\exp[-kx]
$$ {#eq-zhou_fct}
is the ratio $y/x$ (see notebook 2, 25.03.2025, p. 45--47 for more details). In `98_read_zhou.qmd`, I succeeded to reparametrise the model of @Zhou2021, using a beta distribution. I found similar parameters to what the authors reported.

### Exploration of the data

I checked out the data and it worth trying a fit of the ratio of bole volume over total volume by the function of Zhou (see @fig-zhouRatio, although the function @eq-zhou_fct will lack flexibility compared to @eq-flexible). However, a ratio of total volume over a cylindre volume seems difficult to fit (see @fig-ratio_vallet)! Note that this ratio is exactly what was done in @Vallet2006 (see `05_formFactor.qmd`).

```{r}
forest_dt[, cyl_volume := circumference_m^2*height/(4 * pi)]
forest_dt[, cyl_ratio := bole_volume_m3/cyl_volume]
forest_dt[, vallet_ratio := total_volume_m3/cyl_volume]

# Set species colours within functional type (broadleaf/conifer)
broad_cols = MetBrewer::met.brewer(name = "Redon", forest_dt[fct_type == "broadleaf", length(unique(speciesName_sci))])
names(broad_cols) = forest_dt[fct_type == "broadleaf", unique(speciesName_sci)]
conif_cols = MetBrewer::met.brewer(name = "Redon", forest_dt[fct_type == "conifer", length(unique(speciesName_sci))])
names(conif_cols) = forest_dt[fct_type == "conifer", unique(speciesName_sci)]

speciesCols = c(broad_cols, conif_cols)

forest_dt[, sp_colour := speciesCols[speciesName_sci], by = speciesName_sci]
```

```{r}
#| label: fig-zhouRatio
#| fig-cap: "Ratio of bole volume on total volume"
#| fig-subcap:
#|   - "Broadleaves"
#|   - "Conifers"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8
#| layout-ncol: 1

# Broadleaves
plot(forest_dt[fct_type == "broadleaf", bole_volume_m3], forest_dt[fct_type == "broadleaf", total_ratio], pch = 19,
	xlab = "Bole volume", ylab = "ratio BFT/tot", axes = FALSE, col = forest_dt[fct_type == "broadleaf", sp_colour])
axis(1)
axis(2, las = 1)
legend(x = "bottomright", legend = forest_dt[fct_type == "broadleaf", unique(speciesName_sci)],
	fill = broad_cols, bty = "n")

# Conifers
plot(forest_dt[fct_type == "conifer", bole_volume_m3], forest_dt[fct_type == "conifer", total_ratio], pch = 19,
	xlab = "Bole volume", ylab = "ratio BFT/tot", axes = FALSE, col = forest_dt[fct_type == "conifer", sp_colour],
	ylim = range(forest_dt[fct_type == "broadleaf", total_ratio]))
axis(1)
axis(2, las = 1)
legend(x = "bottomright", legend = forest_dt[fct_type == "conifer", unique(speciesName_sci)],
	fill = conif_cols, bty = "n")
```

```{r}
#| label: fig-ratio_vallet
#| fig-cap: "Ratio of total volume on a cylindre volume"
#| fig-subcap:
#|   - "Broadleaves"
#|   - "Conifers"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8
#| layout-ncol: 1

# Broadleaves
plot(forest_dt[fct_type == "broadleaf", circumference_m], forest_dt[fct_type == "broadleaf", vallet_ratio], pch = 19,
	xlab = "Circumference", ylab = "ratio tot/cyl", axes = FALSE, col = forest_dt[fct_type == "broadleaf", sp_colour])
axis(1)
axis(2, las = 1)
legend(x = "topright", legend = forest_dt[fct_type == "broadleaf", unique(speciesName_sci)],
	fill = broad_cols, bty = "n")

# Conifers
plot(forest_dt[fct_type == "conifer", circumference_m], forest_dt[fct_type == "conifer", vallet_ratio], pch = 19,
	xlab = "Circumference", ylab = "ratio tot/cyl", axes = FALSE, col = forest_dt[fct_type == "conifer", sp_colour],
	ylim = range(forest_dt[fct_type == "broadleaf", vallet_ratio]))
axis(1)
axis(2, las = 1)
legend(x = "topright", legend = forest_dt[fct_type == "conifer", unique(speciesName_sci)],
	fill = conif_cols, bty = "n")
```

### Results

I present the results only for the ratio of bole volume over total volume (see @fig-zhouRatio), I did not try for the ratio from @Vallet2006 (see @fig-ratio_vallet) as it is unpromising.

```{stan output.var = "zhou", cache = TRUE}
functions {
	vector r_zhou(vector x, real m, real k, real d)
	{
		return m - d * exp(-k * x); // Ratio from zhou 2021
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1, upper = N> G; // Number of genus
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] Vbft;

	// Data
	vector[N] Vtot;
}

transformed data {
	vector[N] ratio = Vbft ./ Vtot;
}

parameters {
	// Parameters m, d, and k from Zhou2021 (Dynamic allometric scaling of tree biomass and size)
	array[G] real <lower = 0.7, upper = 1> m;
	array[G] real <lower = 0.05, upper = m> d;
	array[G] real <lower = 0, upper = 0.3> k;

	// Precision beta-regression Zhou
	real <lower = 0> phi;
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi * r_zhou(Vbft[start[i]:end[i]], m[i], k[i], d[i]);
		shape2[start[i]:end[i]] = phi * (1 - r_zhou(Vbft[start[i]:end[i]], m[i], k[i], d[i]));
	}
}

model{
	// Prior Zhou formula
	target += normal_lpdf(k | 0, 0.1);
	target += normal_lpdf(m | 0.85, 0.05);
	target += normal_lpdf(d | 0.5, 0.15);
	target += gamma_lpdf(phi | 0.01, 0.01);

	// Likelihood
	target += beta_lpdf(ratio | shape1, shape2);
}


generated quantities {
	array[N] real r_gen = beta_rng(shape1, shape2);
}

```

```{r}
## Run model
# Common variables
n_chains = 4

stanData = list(
	N = forest_dt[, .N],
	G = forest_dt[, length(unique(speciesName_sci))],
	start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
	end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

	# Predictors
	Vbft = forest_dt[, bole_volume_m3],

	# Data
	Vtot = forest_dt[, total_volume_m3]
)

if (!file.exists("./fit_zhou.rds"))
{
	fit = zhou$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fit_zhou"), random = FALSE)
	saveRDS(fit, "./fit_zhou.rds")
} else {
	fit = readRDS("./fit_zhou.rds")
}
```

```{r}
#| label: fig-results_zhou
#| fig-cap: Results with Zhou's function (see zhou_fct)
#| fig-subcap:
#|   - "Abies alba"
#|   - "Carpinus betulus"     
#|   - "Cedrus atlantica"
#|   - "Fagus sylvatica"      
#|   - "Fraxinus excelsior"
#|   - "Larix decidua"        
#|   - "Picea abies"
#|   - "Pinus halepensis"     
#|   - "Pinus laricio"
#|   - "Pinus nigra"          
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"     
#|   - "Pinus uncinata"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#|   - "Quercus rubra"        
#|   - "Quercus sp."
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

r_zhou = function(x, m, k, d)
	return (m - d * exp(-k * x));
	
count = 0

for (sp in ls_species)
{
	count = count + 1
	plot_sp(fit, sp, count, stanData, fun = r_zhou, args = c("m", "k","d"), pred = FALSE, n_subsample = 1)
}
```

### Posteriors of the parameter $m$, $d$, and $k$ for *Abies alba* and *Fagus sylvatica*

```{r}
#| label: fig-posterior_m
#| fig-cap: Posterior of $m$ for the four groups
#| fig-subcap:
#|   - "Posterior of $m$ for Abies alba"
#|   - "Posterior of $m$ for Fagus sylvatica"
#|   - "Posterior of $d$ for Abies alba"
#|   - "Posterior of $d$ for Fagus sylvatica"
#|   - "Posterior of $k$ for Abies alba"
#|   - "Posterior of $k$ for Fagus sylvatica"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| output: false

lazyPosterior(draws = fit$draws("m[1]"), fun = dnorm, mean = 0.85, sd = 0.05)
lazyPosterior(draws = fit$draws("m[4]"), fun = dnorm, mean = 0.85, sd = 0.05)
lazyPosterior(draws = fit$draws("d[1]"), fun = dnorm, mean = 0.5, sd = 0.15)
lazyPosterior(draws = fit$draws("d[4]"), fun = dnorm, mean = 0.5, sd = 0.15)
lazyPosterior(draws = fit$draws("k[1]"), fun = dnorm, mean = 0.0, sd = 0.1)
lazyPosterior(draws = fit$draws("k[4]"), fun = dnorm, mean = 0.0, sd = 0.1)
```

### Residuals for *Abies alba* and *Fagus sylvatica*

```{r}
#| label: fig-residuals_zhou
#| fig-cap: Residuals
#| fig-subcap:
#|   - "Abies alba"
#|   - "Abies alba"
#|   - "Fagus sylvatica" 
#|   - "Fagus sylvatica" 
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8
#| layout-ncol: 1

n_sampling = fit$metadata()$iter_sampling

simResp = fit$draws("r_gen")
dim(simResp)

# Reshape simResp as a matrix nobs x n_repetition
simResp_matrix = matrix(data = 0, nrow = forest_dt[, .N], ncol = n_sampling*n_chains)
for (obs in seq_len(forest_dt[, .N]))
	for (chain in 1:n_chains)
		simResp_matrix[obs, ] = simResp[, chain, obs] # One line of n_sampling*n_chains simulations per observation

## Simulated residuals
for (i in c(1, 4))
{
	start = stanData[["start"]][i]
	end = stanData[["end"]][i]
	sim_dharma = createDHARMa(simulatedResponse = simResp_matrix[start:end, ],
		observedResponse = forest_dt[start:end, total_ratio],
		fittedPredictedResponse = apply(simResp[, , start:end], MARGIN = 3, median),
		integerResponse = FALSE)

	plot(sim_dharma, quantreg = TRUE)
	plotResiduals(sim_dharma, forest_dt[start:end, bole_volume_m3], quantreg = TRUE)
}
```

It seems that the best model so far, in terms of parameters uncertainty and residuals, is the the flexible model in @sec-flexible. Of course, properly selectioning a model requires PSIS-Leave-One-Out [@Vehtari2017]. I will now check the differences of prediction for our model (see @eq-flexible) and @Vallet2006 for the 7 species that are in common.

## Difference between @Vallet2006 and the newly developed allometries

In this section, I check the differences of prediction for the 7 species used in @Vallet2006: *Abies alba* (silver fir), *Fagus sylvatica* (common beech), *Picea abies* (Norway spruce), *Pinus pinaster* (maritime pine), *Pinus sylvestris* (scots pine), *Pseudotsuga menziesii* (douglas fir), and *Quercus petraea* (sessile oak). I check the predictions on three different datasets:

- The Emerge dataset that was used for @eq-flexible, which was also partially used (subset) by @Vallet2006.
- The French NFI data for the six aformentionned species
- An independent dataset from the Emerge project, collected in 2009-2010, that was not used to fit the models.

### Comparison on the Emerge dataset

```{r}
## Reload the good fit object
fit = readRDS("./fit_zhou_beta_flexible.rds")

## Compute average pred volume
forest_dt[, my_predVolume := apply(X = fit$draws("v_gen"), MARGIN = 3, FUN = mean)]

## Compute Vallet 2006 volume 6 species available (listed in sp_dt)
sp_dt = data.table(emerge = c("61", "09", "62", "51", "52", "64", "03"),
	vallet = c("sapin", "hetre", "epicea", "pin.maritime", "pin.sylvestre", "douglas", "chene"),
	speciesName_sci = c("Abies alba", "Fagus sylvatica", "Picea abies", "Pinus pinaster",
		"Pinus sylvestris", "Pseudotsuga menziesii", "Quercus petraea"))

setkey(sp_dt, speciesName_sci)

for (current_sp in sp_dt[, speciesName_sci])
	forest_dt[current_sp, vallet_predVolume := TarVallet(circumference_m*100, height, sp_dt[current_sp, vallet])]

## Fitting range
sp_dt[, c("min_c", "max_c") := forest_dt[.SD, .(min(circumference_m), max(circumference_m)),
	on = .(speciesName_sci), by = .EACHI][, .(V1, V2)]]
sp_dt[, c("min_h", "max_h") := forest_dt[.SD, .(min(height), max(height)),
	on = .(speciesName_sci), by = .EACHI][, .(V1, V2)]]
sp_dt[, c("min_v", "max_v") := forest_dt[.SD, .(min(bole_volume_m3), max(bole_volume_m3)),
	on = .(speciesName_sci), by = .EACHI][, .(V1, V2)]]
```

```{r}
#| label: fig-obs_vs_me-vallet
#| fig-cap: Total volume predicted by my model and @Vallet2006 *vs* observed
#| fig-subcap:
#|   - "Abies alba"
#|   - "Fagus sylvatica"
#|   - "Picea abies"
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

## Plots
# Pred vs obs
for (current_sp in sp_dt[, speciesName_sci])
{
	plot(forest_dt[current_sp, total_volume_m3], forest_dt[current_sp, my_predVolume], pch = 19,
		axes = FALSE, xlab = "Observed", ylab = "Predicted", col = "#FAB255",
		ylim = c(0, max(forest_dt[current_sp, .(my_predVolume, vallet_predVolume)])))
	points(forest_dt[current_sp, total_volume_m3], forest_dt[current_sp, vallet_predVolume], pch = 19,
		col = "#0F7BA244")
	axis(1)
	axis(2, las = 1)
	abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
	# Arrows(x0 = sp_dt[current_sp, min_v], y0 = 0.1, x1 = sp_dt[current_sp, max_v], y1 = 0.1,
	# 	arr.type = "triangle", code = 3, arr.adj = 1) # A bit useless given pred vs obs!
	legend(x = "topleft", legend = c("Mine", "Vallet"), fill = c("#FAB255", "#0F7BA2"), bty = "n")
}
```

```{r}
#| label: fig-me_vs_vallet
#| fig-cap: My model *vs* @Vallet2006
#| fig-subcap:
#|   - "Abies alba"
#|   - "Fagus sylvatica"
#|   - "Picea abies"
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

# Mine vs Vallet
for (current_sp in sp_dt[, speciesName_sci])
{
	plot(forest_dt[current_sp, vallet_predVolume], forest_dt[current_sp, my_predVolume], pch = 19,
		axes = FALSE, xlab = "Vallet", ylab = "Mine")
	axis(1)
	axis(2, las = 1)
	abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
}
```

### Comparison on the French NFI data

I now check the differences of prediction on the French NFI. This is just done out of curiosity, it is impossible here to check which model predicts the best as there is no total volume available for the NFI data.

```{stan output.var = "betareg_pred", cache = TRUE}
// Predicting model
functions {
	vector r_zhou(vector x, real beta_, real gamma, real b)
	{
		return exp(-beta_*x) .* (x - b) + gamma*x + b;
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1> N_new; // Number of trees (new data)
	int <lower = 1, upper = N> G; // Number of genus
	int <lower = 1, upper = G> sp_ind; // Selected_species
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] SB;
	vector[N_new] bole_volume_m3_new;

	// Data
	vector[N] AGB;
}

transformed data {
	vector[N] ratio = SB ./ AGB;

	vector[G] SB_max;
	for (i in 1:G)
		SB_max[i] = max(SB[start[i]:end[i]]);
}

parameters {
	// Parameters of the 'bumpy' function r_zhou
	vector <lower = 0> [G] beta_;
	vector <lower = 0, upper = 1> [G]  b;
	vector <lower = -b ./ SB_max, upper = 0> [G] gamma; // I expect d to be negative

	real <lower = 0> phi; // Precision (well kind of...)
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi*r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]);
		shape2[start[i]:end[i]] = phi*(1 - r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]));
	}
}

generated quantities {
	vector [N_new] shape1_new = phi*r_zhou(bole_volume_m3_new, beta_[sp_ind], gamma[sp_ind], b[sp_ind]);
	vector [N_new] shape2_new = phi*(1 - r_zhou(bole_volume_m3_new, beta_[sp_ind], gamma[sp_ind], b[sp_ind]));
	array[N_new] real r_gen = beta_rng(shape1_new, shape2_new);
	array[N_new] real v_gen;
	for (i in 1:N_new)
		v_gen[i] = bole_volume_m3_new[i] / r_gen[i];
}

```

```{r}
## Extract data from french NFI
db = connect_db()

data_trees = exec_req(conn = db,
	req = "
	SELECT DISTINCT
		tree_dt.NPP AS plot_id, tree_dt.A AS tree_id, tree_dt.ESPAR as sp_code,
		tree_dt.C13 AS circumference_m, tree_dt.htot AS height, tree_dt.V AS bole_volume_m3,
		tree_dt_u.U_V0 AS total_volume_m3,
		EXTRACT(YEAR FROM coords.DATEPOINT) AS year

	FROM
		inv_exp_nm.g3arbre AS tree_dt

		LEFT JOIN inv_exp_nm.u_g3arbre AS tree_dt_u
		ON tree_dt.NPP = tree_dt_u.NPP AND tree_dt.A = tree_dt_u.A

		LEFT JOIN inv_exp_nm.e2point AS coords
		ON coords.NPP = tree_dt.NPP

	WHERE
		tree_dt.ESPAR IN ('61', '09', '62', '51', '52', '64', '03') AND
		tree_dt.VEGET = '0' AND -- Living standing trees
		tree_dt.V > 0 AND -- I found some that are 0!
		(EXTRACT(YEAR FROM coords.DATEPOINT) BETWEEN 2018 AND 2023)

	ORDER BY
		tree_dt.NPP, tree_dt.A;",
	DT = TRUE)

disconnect_db(db)
```

```{r}
## Get an approximation of the max bole volume before model collapse
sp_dt[, sp_index := which(ls_species %in% sp_dt[, speciesName_sci])] # Species index from forest_dt (species is the key)

params = getParams(model_cmdstan = fit, params_names = c(paste0("beta_[", sp_dt[, sp_index], "]"),
	paste0("b[", sp_dt[, sp_index], "]"), paste0("gamma[", sp_dt[, sp_index], "]")))

sp_dt[, beta_ := params[paste0("beta_[", sp_index, "]")]]
sp_dt[, b := params[paste0("b[", sp_index, "]")]]
sp_dt[, gamma := params[paste0("gamma[", sp_index, "]")]]

sp_dt[, collapse_at := -b/gamma]
sp_dt[, value_neglected := exp(beta_*b/gamma)]

## Simulate posterior total volume on new data
# Remove volumes that are beyond the computed limit
data_trees[, limit := sp_dt[emerge == unique(sp_code), floor(collapse_at)], by = sp_code]
data_trees = data_trees[bole_volume_m3 < limit][, limit := NULL]
setkey(data_trees, sp_code)
```

```{r}
#| label: fig-comparions
#| fig-cap: Comparison of my model, @Vallet2006, and Emerge from `inventR`
#| fig-subcap:
#|   - "Abies alba, Emerge and mine vs @Vallet2006"
#|   - "Abies alba"
#|   - "Fagus sylvatica, Emerge and mine vs @Vallet2006"
#|   - "Fagus sylvatica"
#|   - "Picea abies, Emerge and mine vs @Vallet2006"
#|   - "Picea abies"
#|   - "Pinus pinaster, Emerge and mine vs @Vallet2006"
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris, Emerge and mine vs @Vallet2006"
#|   - "Pinus sylvestris"
#|   - "Pseudotsuga menziesii, Emerge and mine vs @Vallet2006"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea, Emerge and mine vs @Vallet2006"
#|   - "Quercus petraea"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

## Species-specific plots
# betareg_pred = cmdstan_model("./temp.stan")
for (sp_ind in sp_dt[, sp_index])
{
	stanData_new = list(
		N = forest_dt[, .N],
		N_new = data_trees[sp_dt[sp_index == sp_ind, emerge], .N],
		G = forest_dt[, length(unique(speciesName_sci))],
		sp_ind = sp_ind,
		start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
		end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

		# Predictors
		SB = forest_dt[, bole_volume_m3], # Same as reconstruct one
		bole_volume_m3_new = data_trees[sp_dt[sp_index == sp_ind, emerge], bole_volume_m3],

		# Data
		AGB = forest_dt[, total_volume_m3]
	)

	posteriorVol = betareg_pred$generate_quantities(fitted_params = fit$draws(inc_warmup = FALSE), data = stanData_new,
		parallel_chains = min(n_chains, 4))

	## Compute average pred volume
	posteriorVol = apply(X = posteriorVol$draws("v_gen"), MARGIN = 3, FUN = mean)
	data_trees[sp_dt[sp_index == sp_ind, emerge], my_predVolume := posteriorVol]

	rm(posteriorVol)

	## Add Emerge volumes
	data_trees[sp_dt[sp_index == sp_ind, emerge], emerge_predVolume := TarEmerge(c130 = circumference_m*100,
		htot = height, espar = sp_dt[sp_index == sp_ind, emerge], typevol = "total")]

	## Plot
	# Comparison Emerge (inventR::TarEmerge) and mine vs Vallet 2006
	plot(data_trees[sp_dt[sp_index == sp_ind, emerge], total_volume_m3],
		data_trees[sp_dt[sp_index == sp_ind, emerge], my_predVolume],
		pch = 19, axes = FALSE, col = "#FAB25544", xlab = "Vallet", ylab = "Others")
	points(data_trees[sp_dt[sp_index == sp_ind, emerge], total_volume_m3],
		data_trees[sp_dt[sp_index == sp_ind, emerge], emerge_predVolume],
		pch = 19, col = "#0F7BA244")
	axis(1)
	axis(2, las = 1)
	abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
	legend(x = "topleft", legend = c("Mine", "Emerge"), fill = c("#FAB255", "#0F7BA2"), bty = "n")

	# Comparison Emerge (inventR::TarEmerge), mine and Vallet 2006 vs bole volume (volume bois-fort tige)
	plot(data_trees[sp_dt[sp_index == sp_ind, emerge], bole_volume_m3],
		data_trees[sp_dt[sp_index == sp_ind, emerge], total_volume_m3],
		pch = 19, axes = FALSE, col = "#43B28444", xlab = "Bole volume", ylab = "Total volume",
		ylim = c(0, max(data_trees[sp_dt[sp_index == sp_ind, emerge],
			.(total_volume_m3, emerge_predVolume, my_predVolume)], na.rm = TRUE)))
	points(data_trees[sp_dt[sp_index == sp_ind, emerge], bole_volume_m3],
		data_trees[sp_dt[sp_index == sp_ind, emerge], emerge_predVolume],
		pch = 19, col = "#0F7BA244")
	points(data_trees[sp_dt[sp_index == sp_ind, emerge], bole_volume_m3],
		data_trees[sp_dt[sp_index == sp_ind, emerge], my_predVolume],
		pch = 19, col = "#FAB25544")
	axis(1)
	axis(2, las = 1)
	abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
	legend(x = "topleft", legend = c("Mine", "Emerge", "Vallet"), fill = c("#FAB255", "#0F7BA2", "#43B284"), bty = "n")
}
```

## Heatmap

```{r}
#| label: fig-heatmaps
#| fig-cap: Heatmaps in the circumference/height space of my model, @Vallet2006, and Emerge from `inventR`
#| fig-subcap:
#|   - "Abies alba, my model"
#|   - "Abies alba, @Vallet2006"
#|   - "Abies alba, Emerge"
#|   - "Fagus sylvatica, my model"
#|   - "Fagus sylvatica, @Vallet2006"
#|   - "Fagus sylvatica, Emerge"
#|   - "Picea abies, my model"
#|   - "Picea abies, @Vallet2006"
#|   - "Picea abies, Emerge"
#|   - "Pinus pinaster, my model"
#|   - "Pinus pinaster, @Vallet2006"
#|   - "Pinus pinaster, Emerge"
#|   - "Pinus sylvestris, my model"
#|   - "Pinus sylvestris, @Vallet2006"
#|   - "Pinus sylvestris, Emerge"
#|   - "Pseudotsuga menziesii, my model"
#|   - "Pseudotsuga menziesii, @Vallet2006"
#|   - "Pseudotsuga menziesii, Emerge"
#|   - "Quercus petraea, my model"
#|   - "Quercus petraea, @Vallet2006"
#|   - "Quercus petraea, Emerge"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 3

## Species-specific heatmaps
for (sp_ind in sp_dt[, sp_index])
{
	aa = data_trees[sp_dt[sp_index == sp_ind, emerge]][!is.na(emerge_predVolume)][
		sample(x = seq_len(.N), size = min(4000, .N), replace = FALSE)]

	# Heatmap of my model
	si = interp(x = aa[, circumference_m], y = aa[, height], z = aa[, my_predVolume],
		method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Circumference", ylab = "Height", frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)

	# Heatmap of Vallet 2006
	si = interp(x = aa[, circumference_m], y = aa[, height], z = aa[, total_volume_m3],
		method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Circumference", ylab = "Height", frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)

	# Heatmap of Emerge
	si = interp(x = aa[, circumference_m], y = aa[, height], z = aa[, emerge_predVolume],
		method = "linear", duplicate = "mean")

	filled.contour(si,
		plot.axes = {
			axis(1)
			axis(2, las = 1)
			contour(si, add = TRUE, lwd = 2, axes = NULL)
		}, xlab = "Circumference", ylab = "Height", frame.plot = FALSE,
		color.palette = colorRampPalette(met.brewer("Hiroshige", direction = -1))
	)
}
```

Range of parameterisation:

::: {#tbl-table_1 .borderless .hover}

| species           | max circumference (m) | max height (m) | max $V_{\text{BFT}}$ |
|------------------:|:------------------|:-----------|:-----------------|
| *Abies alba* | `{r} forest_dt["Abies alba", max(circumference_m)]` |  `{r} forest_dt["Abies alba", max(height)]` | `{r} forest_dt["Abies alba", format(max(bole_volume_m3), 2)]` |
| *Fagus sylvatica* | `{r} forest_dt["Fagus sylvatica", max(circumference_m)]` |  `{r} forest_dt["Fagus sylvatica", max(height)]` | `{r} forest_dt["Fagus sylvatica", format(max(bole_volume_m3), 2)]` |
| *Picea abies* | `{r} forest_dt["Picea abies", max(circumference_m)]` |  `{r} forest_dt["Picea abies", max(height)]` | `{r} forest_dt["Picea abies", format(max(bole_volume_m3), 2)]` |
| *Pinus pinaster* | `{r} forest_dt["Pinus pinaster", max(circumference_m)]` |  `{r} forest_dt["Pinus pinaster", max(height)]` | `{r} forest_dt["Pinus pinaster", format(max(bole_volume_m3), 2)]` |
| *Pinus sylvestris* | `{r} forest_dt["Pinus sylvestris", max(circumference_m)]` |  `{r} forest_dt["Pinus sylvestris", max(height)]` | `{r} forest_dt["Pinus sylvestris", format(max(bole_volume_m3), 2)]` |
| *Pseudotsuga menziesii* | `{r} forest_dt["Pseudotsuga menziesii", max(circumference_m)]` |  `{r} forest_dt["Pseudotsuga menziesii", max(height)]` | `{r} forest_dt["Pseudotsuga menziesii", format(max(bole_volume_m3), 2)]` |
| *Quercus petraea* | `{r} forest_dt["Quercus petraea", max(circumference_m)]` |  `{r} forest_dt["Quercus petraea", max(height)]` | `{r} forest_dt["Quercus petraea", format(max(bole_volume_m3), 2)]` |

Species-specific range of parameterisation

:::

### Comparison on the independent dataset
I use data collected in 2009 in Bure (France), and in 2010 (unknown location). The preparation of the data is detailed in the document `01_prepare_data.qmd`. I want to compare my model with @Vallet2006 using PSIS-LOO [@Vehtari2017]. However, that requires to refit @Vallet2006 in a Bayesian framework. His dataset was a subsample of Emerge which I cannot recreate. Therefore, I am going to use the same dataset as my model.

#### Recreate the study of @Vallet2006

```{stan output.var = "vallet_bayesian", cache = TRUE}
functions {
	vector vallet(vector circumference, vector hdn, vector params, int N_params)
	{
		if (N_params == 4)
			return (params[1] + params[2]*circumference + params[3]*hdn).*(1 + params[4]./circumference.^2);
		
		return params[1] + params[2]*circumference + params[3]*hdn;
	}
}

data{
	// Dimensions
	int <lower = 1> N; // Number of trees // In m, while in cm in Vallet2006
	int <lower = 3, upper = 4> N_params; // Number of parameters

	// Predictors
	vector[N] circumference_cm;
	vector[N] height;

	// Observations
	vector[N] total_volume_m3;
}

transformed data {
	vector[N] hdn = sqrt(circumference_cm) ./ height;
}

parameters {
	vector[N_params] vec_params;
	real<lower = 0> sigma;
}

model {
	target += normal_lpdf(vec_params[1] | 0, 1);
	target += normal_lpdf(vec_params[2] | 0, 0.01);
	target += normal_lpdf(vec_params[3] | 0, 1);

	if (N_params == 4)
		target += normal_lpdf(vec_params[4] | 45, 10);
	
	target += gamma_lpdf(sigma | 0.06^2/0.01, 0.06/0.01);
	
	target += normal_lpdf(total_volume_m3 |
		vallet(circumference_cm, hdn, vec_params, N_params) ./ (40000*pi()) .* circumference_cm.^2 .* height, sigma);
}

```

```{r}
#### Run Vallet 2006, Bayesian version and with our dataset (which contains Vallet's dataset)
## Compute some useful variables and store Vallet's results in a data table
forest_dt[, circumference_cm := 100*circumference_m]
n_chains = 4

## Table 5 from Vallet2006
vallet_dt = data.table(speciesName_sci = c("Fagus sylvatica", "Quercus petraea"),
	alpha = c(0.395, 0.471),
	sd_alpha = c(0.01, 0.014),
	beta = c(2.66e-4, -3.45e-4),
	sd_beta = c(4.9e-5, 1.3e-5),
	gamma = c(0.421, 0.377),
	sd_gamma = c(0.025, 0.031),
	delta = c(45.4, NA),
	sd_delta = c(4, NA),
	var_res = c(0.0036, 0.004), key = "speciesName_sci")

form_vallet = function(circumference_cm, height, alpha, beta, gamma, delta)
{
	res = alpha + beta*circumference_cm + gamma*sqrt(circumference_cm)/height
	if (!is.na(delta))
		res = res*(1 + delta/circumference_cm^2)
	return (res)
}

for (current_sp in c("Fagus sylvatica", "Quercus petraea")) # The only two species in common
{
	stanData = list(
		N = forest_dt[current_sp, .N],
		N_params = if (is.na(vallet_dt[current_sp, delta])) 3 else 4,

		circumference_cm = forest_dt[current_sp, circumference_cm],
		height = forest_dt[current_sp, height],

		total_volume_m3 = forest_dt[current_sp, total_volume_m3]
	)
	
	filename = paste0("./fit_vallet_bayesian_", stri_replace(str = current_sp, replacement = "-", regex = " "), ".rds")
	
	if (!file.exists(filename))
	{
		results = vallet_bayesian$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
			max_treedepth = 12)
		saveRDS(results, filename)
	} else {
		results = readRDS(filename)
	}

	## Predict with Vallet
	# Vallet
	forest_dt[current_sp, form_vallet := form_vallet(circumference_cm, height, vallet_dt[current_sp, alpha],
		vallet_dt[current_sp, beta], vallet_dt[current_sp, gamma], vallet_dt[current_sp, delta])]
	forest_dt[current_sp, vallet_pred := form_vallet/(4*pi) * circumference_m^2*height]

	# Bayesian Vallet
	params_vallet = apply(X = results$draws("vec_params"), MARGIN = 3, FUN = mean)
	
	if (stanData$N_params == 3)
		params_vallet = c(params_vallet, NA)
	
	names(params_vallet) = c("alpha", "beta","gamma", "delta")
	
	forest_dt[current_sp, my_form := form_vallet(circumference_cm, height, params_vallet["alpha"],
		params_vallet["beta"], params_vallet["gamma"], params_vallet["delta"])]
	forest_dt[current_sp, my_vallet_pred := my_form/(4*pi) * circumference_m^2*height]

	## Plot Vallet and Bayesian vallet vs observed
	plot(forest_dt[current_sp, total_volume_m3], forest_dt[current_sp, vallet_pred],
		pch = 19, xlab = "Obs", ylab = "Pred", axes = FALSE, col = "#0F7BA255", cex = 0.75)
	points(forest_dt[current_sp, total_volume_m3], forest_dt[current_sp, my_vallet_pred],
		pch = 19, cex = 0.25, col = "#FAB255")
	axis(1)
	axis(2, las = 1)
	abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
	legend(x = "topleft", legend = c("Vallet", "Vallet Bayes"), fill = c("#0F7BA2", "#FAB255"), bty = "n")
}
```

#### Compute the PSIS-LOO and compare both models

```{stan output.var = "betareg_loglik", cache = TRUE}
// Log-likelihood model
functions {
	vector r_zhou(vector x, real beta_, real gamma, real b)
	{
		return exp(-beta_*x) .* (x - b) + gamma*x + b;
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1> N_new; // Number of trees (new data)
	int <lower = 1, upper = N> G; // Number of genus
	int <lower = 1, upper = G> sp_ind; // Selected_species
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] SB;
	vector[N_new] bole_volume_m3_new;

	// Data
	vector[N] AGB;
	vector[N_new] total_volume_m3_new;
}

transformed data {
	vector[N] ratio = SB ./ AGB;

	vector[G] SB_max;
	for (i in 1:G)
		SB_max[i] = max(SB[start[i]:end[i]]);
}

parameters {
	// Parameters of the 'bumpy' function r_zhou
	vector <lower = 0> [G] beta_;
	vector <lower = 0, upper = 1> [G]  b;
	vector <lower = -b ./ SB_max, upper = 0> [G] gamma; // I expect d to be negative

	real <lower = 0> phi; // Precision (well kind of...)
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi*r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]);
		shape2[start[i]:end[i]] = phi*(1 - r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]));
	}
}

generated quantities {
	array[N_new] real log_lik;
	array[N_new] real sim_tot_vol;
	{
		// Variables declared insided will not be exported
		vector [N_new] shape1_new = phi*r_zhou(bole_volume_m3_new, beta_[sp_ind], gamma[sp_ind], b[sp_ind]);
		vector [N_new] shape2_new = phi*(1 - r_zhou(bole_volume_m3_new, beta_[sp_ind], gamma[sp_ind], b[sp_ind]));
		real current_ratio;

		for (i in 1:N_new)
		{
			current_ratio = bole_volume_m3_new[i]/total_volume_m3_new[i];
			log_lik[i] = beta_lpdf(current_ratio | shape1_new[i], shape2_new[i]);
			sim_tot_vol[i] = bole_volume_m3_new[i] ./ beta_rng(shape1_new[i], shape2_new[i]);
		}
	}
}

```

```{stan output.var = "vallet_loglik", cache = TRUE}
functions {
	vector vallet(vector circumference, vector hdn, vector params, int N_params)
	{
		if (N_params == 4)
			return (params[1] + params[2]*circumference + params[3]*hdn).*(1 + params[4]./circumference.^2);
		
		return params[1] + params[2]*circumference + params[3]*hdn;
	}

	real vallet_real(real circumference, real hdn, vector params, int N_params)
	{
		if (N_params == 4)
			return (params[1] + params[2]*circumference + params[3]*hdn).*(1 + params[4]./circumference.^2);
		
		return params[1] + params[2]*circumference + params[3]*hdn;
	}
}

data{
	// Dimensions
	int <lower = 1> N; // Number of trees // In m, while in cm in Vallet2006
	int <lower = 3, upper = 4> N_params; // Number of parameters

	// Predictors
	vector[N] circumference_cm;
	vector[N] height;

	// New data
	int <lower = 1> N_new; // Number of trees // In m, while in cm in Vallet2006
	vector[N_new] circumference_cm_new;
	vector[N_new] height_new;
	vector[N_new] total_volume_m3_new;

	// Observations
	vector[N] total_volume_m3;
}

transformed data {
	vector[N] hdn = sqrt(circumference_cm) ./ height;
}

parameters {
	vector[N_params] vec_params;
	real<lower = 0> sigma;
}

generated quantities {
	array[N_new] real log_lik;
	array[N_new] real sim_tot_vol;
	{
		// Variables declared here are local and not exported
		vector[N_new] hdn_new = sqrt(circumference_cm_new) ./ height_new;
		for (i in 1:N_new)
		{
			log_lik[i] = normal_lpdf(total_volume_m3_new[i] |
				vallet_real(circumference_cm_new[i], hdn_new[i], vec_params, N_params) ./ (40000*pi()) .*
				circumference_cm_new[i].^2 .* height_new[i], sigma);
		}

		sim_tot_vol = normal_rng(vallet(circumference_cm_new, hdn_new, vec_params, N_params) ./ (40000*pi()) .*
			circumference_cm_new.^2 .* height_new, sigma);
	}
}

```

```{r}
ls_params = c("beta_", "b", "gamma", "phi", "shape1", "shape2")
# betareg_loglik = cmdstan_model("./temp.stan")

for (current_sp in c("Fagus sylvatica", "Quercus petraea")) # The only two species in common
{
	## PSIS-LOO for my model
	stanData_new = list(
		N = forest_dt[, .N],
		N_new = check_data[current_sp, .N],
		G = forest_dt[, length(unique(speciesName_sci))],
		sp_ind = sp_dt[current_sp, sp_index],
		start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
		end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

		# Predictors
		SB = forest_dt[, bole_volume_m3], # Same as reconstruct one
		bole_volume_m3_new = check_data[current_sp, bole_volume_conic_m3],

		# Data
		AGB = forest_dt[, total_volume_m3],
		total_volume_m3_new = check_data[current_sp, total_volume_m3]
	)

	loglik_beta = betareg_loglik$generate_quantities(fitted_params = fit$draws(ls_params, inc_warmup = FALSE),
		data = stanData_new, parallel_chains = min(n_chains, 4))

	sim_vol_beta = apply(loglik_beta$draws("sim_tot_vol"), 3, mean)

	r_eff_beta = loo::relative_eff(loglik_beta$draws("log_lik"), cores = 8)
	loo_beta = loo::loo(x = loglik_beta$draws("log_lik"), r_eff = r_eff_beta, cores = 8, save_psis = TRUE)

	ls_problems_beta = pareto_k_ids(loo_beta)

	## PSIS-LOO for my Vallet Bayesian
	stanData_new = list(
		N = forest_dt[current_sp, .N],
		N_params = if (is.na(vallet_dt[current_sp, delta])) 3 else 4,

		circumference_cm = forest_dt[current_sp, circumference_cm],
		height = forest_dt[current_sp, height],

		N_new = check_data[current_sp, .N],
		circumference_cm_new = 100*check_data[current_sp, circumference_m],
		height_new = check_data[current_sp, height],
		total_volume_m3_new = check_data[current_sp, total_volume_m3],

		total_volume_m3 = forest_dt[current_sp, total_volume_m3]
	)

	filename = paste0("./fit_vallet_bayesian_", stri_replace(str = current_sp, replacement = "-", regex = " "), ".rds")
	results = readRDS(filename)
	# vallet_loglik = cmdstan_model("./temp.stan")
	loglik_vallet = vallet_loglik$generate_quantities(fitted_params = results$draws(inc_warmup = FALSE),
		data = stanData_new, parallel_chains = min(n_chains, 4))

	sim_vol_vallet = apply(loglik_vallet$draws("sim_tot_vol"), 3, mean)

	r_eff_vallet = loo::relative_eff(loglik_vallet$draws("log_lik"), cores = 8)
	loo_vallet = loo::loo(x = loglik_vallet$draws("log_lik"), r_eff = r_eff_vallet, cores = 8, save_psis = TRUE)
	
	ls_problems_vallet = pareto_k_ids(loo_vallet)

	plot(stanData_new$total_volume_m3_new, sim_vol_beta, pch = 19, xlab = "Obs", ylab = "Pred",
		axes = FALSE, col = "#0F7BA255", cex = 0.75, ylim = c(0, max(sim_vol_beta, sim_vol_vallet)))
	points(stanData_new$total_volume_m3_new, sim_vol_vallet, pch = 19,col = "#FAB255", cex = 0.25)
	if (length(ls_problems_vallet) != 0)
		text(x = stanData_new$total_volume_m3_new[ls_problems_vallet], y = sim_vol_vallet[ls_problems_vallet],
			labels = as.character(ls_problems_vallet), pos = 4, offset = 0.5)
	axis(1)
	axis(2, las = 1)
	abline(a = 0, b = 1, col = "#CD212A", lwd = 2)
	legend(x = "topleft", legend = c("Mine", "Vallet Bayes"), fill = c("#0F7BA2", "#FAB255"), bty = "n")

	loo::loo_compare(list(beta = loo_beta, vallet = loo_vallet))
}
```

## Conclusion

It seems that the best model so far, in terms of parameters uncertainty and residuals, is the the flexible model in @sec-flexible. Of course, properly selectioning a model requires PSIS-Leave-One-Out [@Vehtari2017].

So now it is time to try a multivariate model, with both $\Vbft$ and $\Vtot$ as output variables. Indeed, with the above method, $\Vtot$ completely relies on $\Vbft$, which therefore must be as 'clean' as possible. Therefore it worth trying some models on $\Vbft$. I already started investigating multivariate models on simple examples in `04_test_multivariate.qmd`.
