---
title: "Simple tests of bole volume models"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
bibliography: /home/ALe-Squin/work/library/bib_file/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\Vtot}{V_{\text{tot}}}
\newcommand{\hdec}{h_{\text{dec}}}
\newcommand{\fmax}{f_{\text{max}}}

<!-- Math operators -->
<!-- \DeclareMathOperator{\ln}{ln} -->

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   LOADING DATA, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
library(DHARMa)

## Tool function
source("./toolFunctions.R")

plot_sp = function(fit, sp, count, stanData, fun, args, forest = forest_dt[.(sp)],
	pred = FALSE, n_subsample = 10, folder = NULL)
{
	# Get parameters
	start = stanData[["start"]][count]
	end = stanData[["end"]][count]
	n_sampling = fit$metadata()$iter_sampling

	# Plot figure
	if (!is.null(folder))
		png(paste0("./", folder, "/", sp, ".png"))
	plot(forest[, bole_volume_m3], forest[, total_ratio], pch = 20, col = "#3355AA33", axes = FALSE,
		xlab = "Bole volume", ylab = "Ratio bole/tot volumes", main = sp)
	axis(1)
	axis(2, las = 1)

	# Plot prediction
	if (pred)
	{
		sim = fit$draws("r_gen")[sample(x = 1:n_sampling, size = n_subsample, replace = FALSE), , start:end]
		for (i in 1:forest[, .N])
			points(rep(forest[i, bole_volume_m3], n_chains*n_subsample),
				as.numeric(sim[, , i]), col = "#335577AA", pch = ".")
	}

	# Plot fitted curve
	if (length(args) == 2 && all(c("k", "lambda") == args))
	{
		selected_params = c(paste0("k[", count, "]"), paste0("lambda[", count, "]"))
		params = apply(X = fit$draws(args)[, , selected_params], MARGIN = 3, FUN = mean)

		curve(fun(x, params[1], params[2]), col = "#CD212A", lwd = 2, add = TRUE, n = 501)
	}
	
	if (length(args) == 3 && all(c("beta_", "gamma", "b") == args))
	{
		selected_params = c(paste0("beta_[", count, "]"),
			paste0("gamma[", count, "]"), paste0("b[", count, "]"))
		params = apply(X = fit$draws(args)[, , selected_params], MARGIN = 3, FUN = mean)

		curve(fun(x, 1, params[1], params[2], params[3]), col = "#CD212A", lwd = 2, n = 501, add = TRUE)
	}

	if (length(args) == 4 && all(c("alpha", "beta_", "gamma", "b") == args))
	{
		selected_params = c(paste0("alpha[", count, "]"), paste0("beta_[", count, "]"),
			paste0("gamma[", count, "]"), paste0("b[", count, "]"))
		params = apply(X = fit$draws(args)[, , selected_params], MARGIN = 3, FUN = mean)

		curve(fun(x, params[1], params[2], params[3], params[4]), col = "#CD212A", lwd = 2, add = TRUE, n = 501)
	}
	if (!is.null(folder))
		dev.off()
}
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra", opt, ".rds"))
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra", opt, ".rds"))

colours = paste0(met.brewer("Egypt")[1:4])
names(colours) = c("conifer", "broadleaf", "inra", "nfi")

forest_dt[fct_type == "broadleaf", fct_colour := colours["broadleaf"]]
forest_dt[fct_type == "conifer", fct_colour := colours["conifer"]]
forest_dt[origin_data == "inra", origin_colour := colours["inra"]]
forest_dt[origin_data == "nfi", origin_colour := colours["nfi"]]

## Add vernacular english names
# vernacularNames = sci2comm(sci = forest_dt[, unique(speciesName_sci)], db = "itis")
```

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   MAIN CONTENT, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

## Introduction
Florence Gohon a travaillé sur des modèles de volume bois-fort tige, $\Vbft$ qui sont consultables (en local) dans le document `~/work/FairCarbon/gohon/rapport_tarifs.pdf`:
$$
	\Vbft = \frac{c^2h}{4\pi \left( 1 - \frac{1.3}{h} \right)^2} \left[ \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec} + \delta_i \frac{\sqrt{\hdec}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec}{h} \right) \right]
$$

Pour l'instant, les tarifs utilisés par l'inventaire sont (facteurs de forme):

- $\Fbft = \left[ \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \frac{\hdec}{\hdec + k} + \frac{\delta}{c^{\epsilon}} \right] \left[ 1 - \left(\frac{0.07 \pi}{c}\right)^3 \left(1 - \frac{1.3}{h}\right)^3 \right]$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \left( \frac{\hdec}{\hdec + k} \right)^{1 + \rho} + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \eta \hdec + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln \left(\frac{\hdec}{h} \right) + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln(\hdec) + \frac{\delta}{c^{\epsilon}}$

Cependant, ces modèles sont peu interprétables physiquement et ressemble plus à un 'fit polynomial'. Dans les prochaines sections, je vais explorer des modèles plus simples plus compréhensibles physiquement en me basant sur la littérature. A voir si ça marche...

## Modèle 1: @Zhou2021

### Quelques notes explicatives

L'idée de base de l'allométrie est qu'une variable biologique $Y$ est reliée à la masse $M$ d'un organisme par une power-law:

$$
Y = Y_0 M^b,
$$
où $Y_0$ est une constante, et $b$ le *scaling exponent* ou *allometric exponent*. En physique, on parle de *scaling equation*, tandis que la bio utilise *allometric* [@daSilva2006].

Partons maintenant de l'équation suivante qui est *mutatis mutandis* celle d'avant:
$$
y = a x^{\psi}
$$ {#eq-allometric}

Le but est de retrouver l'équation 6 de @Zhou2021. Pour ça, il suffit de log-dériver @eq-allometric:

\begin{align*}
	\log(y) &= \log(a) + \psi \log(x) \\
	\frac{d\log(y)}{dx} &= \frac{\psi}{x} \\
	\frac{1}{y}\frac{dy}{dx} &= \frac{\psi}{x} \\
	\psi &= \frac{dy/y}{dx/x}
\end{align*}

The relative change in $y$, $dy/y$ is proportional to the relative change in $x$, $dx/x$, with a factor $\psi$. Then, maybe there is a finite difference method approx, to replace $dy$ by $\Delta y$, or maybe it is just a notation difference... I suspect that the authors kept it analytic and $\Delta$ is just a notation.

Then, they assume that:
$$
\psi = 1 - \frac{kx}{p(\exp[kx] - 1)}
$$

I checked all the other equations, see notebook 2, 25.03.2025, p. 39--47. If I understood well, I should process as follow:

1. Define $x$ as $\Vbft$
2. Define $y$ as $\Vtot - \Vbft$, which is the crown volume, or define $y$ as $\Vtot$ directly?
3. Define $m = \max(x/y)$
4. Define $d = \max(x/y) - \min(x/y)$
5. Check a graph of $\frac{\Delta y/y}{\Delta x/x}$, where I need to sort by $x$ the data table I think... What does it do?

TO FINISH, SUM-UP THE DISCUSSION WITH THE AUTHORS

## Modèle 2: @Longuetaud2013

### Quelques notes explicatives

In this paper, the authors model the Volume Expansion Factor, $\text{VEF} = \Vtot/\Vbft$, in function of the bole volume. By definition, VEF is above 1. For large trees, it is common to see VEF decreasing around 1. They use a Gaussian, which is problematic as it can go below 1 for large trees, which does not make sense physically (total volume smaller than bole volume!). Therefore it must be done differently.

### A test model
I model the opposite of the VEF, \ie $r = \Vbft/\Vtot$, which is by construction between 0 and 1. It represents the percentage of volume represented by the bole. A Beta-distribution seems perfect for that, it respects the bounds and accounts for heteroskedasticity. However, its parameters $\text{shape}_1$ and $\text{shape}_2$ are not intuitive. Fortunately, it is possible to reparametrise the Beta-distrib in function of mean and precision, $\phi$:

- $\text{shape}_1 = \phi \mu$
- $\text{shape}_2 = \phi (1 - \mu)$

Using the mean and variance is of no good idea: it adds an interacting constraint $\sigma^2 < \mu (1 - \mu)$.

I do a first test with:
$$
	\mu = x^k \exp[-x/\lambda],
$$
where $x$ is the bole volume, $\Vbft$, and $k$, $\lambda$ parameters to be estimated, with the constraint $0 < k < e^1/\lambda$ and $\lambda > 0$ ($x > 0$, but this is more a fact than a constraint).

```{r}
## Subset data
forest_dt = forest_dt[origin_data == "inra"]
forest_dt[, nb_indiv := .N, by = speciesName_sci]
forest_dt = forest_dt[nb_indiv > 50]

setkey(forest_dt, speciesName_sci)
ls_species = forest_dt[, unique(speciesName_sci)]
```


```{stan output.var = "betareg_simple", cache = TRUE}
functions {
	vector r_zhou(vector x, real k, real lambda)
	{
		return x.^k .* exp(-x / lambda);
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1, upper = N> G; // Number of genus
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] SB;

	// Data
	vector[N] AGB;
}

transformed data {
	vector[N] ratio = SB ./ AGB;
}

parameters {
	// Parameters of the 'simple' function r_zhou (simple compared to the flexibility I want)
	vector <lower = 0> [G] lambda;
	vector <lower = 0, upper = exp(1) ./ lambda> [G] k;

	real <lower = 0> phi; // Precision (well kind of...)
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi*r_zhou(SB[start[i]:end[i]], k[i], lambda[i]);
		shape2[start[i]:end[i]] = phi*(1 - r_zhou(SB[start[i]:end[i]], k[i], lambda[i]));
	}
}

model{
	// Priors
	target += normal_lpdf(k | 0, 10);
	target += normal_lpdf(lambda | 0, 10);
	target += normal_lpdf(phi | 0, 10);
	
	// Likelihood
	target += beta_lpdf(ratio | shape1, shape2);
}

generated quantities {
	array[N] real r_gen = beta_rng(shape1, shape2);
}

```

```{r}
#### Test of the temp.stan model on the forest data
## Compute ratio
forest_dt[, total_ratio := bole_volume_m3/total_volume_m3]

## Run model
# Common variables
n_chains = 4

stanData = list(
	N = forest_dt[, .N],
	G = forest_dt[, length(unique(speciesName_sci))],
	start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
	end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

	# Predictors
	SB = forest_dt[, bole_volume_m3], # Same as reconstruct one

	# Data
	AGB = forest_dt[, total_volume_m3]
)

# Run
if (!file.exists("./fit_zhou_beta.rds"))
{
	fit = betareg_simple$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fit_zhou_beta"), random = FALSE)
	saveRDS(fit, "./fit_zhou_beta.rds")
} else {
	fit = readRDS("./fit_zhou_beta.rds")
}
```

### Results
```{r}
#| label: fig-results_simple
#| fig-cap: Correlation between the bole volume and the total volume
#| fig-subcap:
#|   - "Abies alba"
#|   - "Carpinus betulus"     
#|   - "Cedrus atlantica"
#|   - "Fagus sylvatica"      
#|   - "Fraxinus excelsior"
#|   - "Larix decidua"        
#|   - "Picea abies"
#|   - "Pinus halepensis"     
#|   - "Pinus laricio"
#|   - "Pinus nigra"          
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"     
#|   - "Pinus uncinata"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#|   - "Quercus rubra"        
#|   - "Quercus sp."
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

# Plot output
r_zhou = function(x, k, lambda)
	return (x^k*exp(-x/lambda))

count = 0

for (sp in forest_dt[, unique(speciesName_sci)])
{
	count = count + 1
	sp = ls_species[count]

	plot_sp(fit, sp, count, stanData, fun = r_zhou, args = c("k", "lambda"), pred = TRUE, n_subsample = 1)
}
```

It seems that this function is not flexible enough (see results in @fig-results_simple)... I switch to a more flexible function (see @fig-flexible_fct) with four parameters:
$$
\mu(x; \alpha, \beta, \gamma, b) = \alpha \exp[-\beta x] (x - b/\alpha) + \gamma x + b.
$$
However, 4 parameters seems to be impossible to fit (too many degrees of freedom I think) and so I fix $\alpha = 1$. Indeed, this parameter is involved in the maximum height of the $\mu$, reached for:
$$
x^{*} = \frac{b}{\alpha} + \frac{1}{\beta} \left( 1 - W_p \left[ -\frac{\gamma}{\alpha} e^{\beta b/\alpha + 1} \right] \right),
$$
where $W_p$ is the positive branch of the Lambert function.

::: {.callout-note }

This value of $x^{*}$ assumes $\gamma < 0$ which is the case (I set that constraint in the model). The condition to use $W_p$ is also always satisfied: $-\gamma/\alpha e^{\beta b/\alpha + 1} > -e^{-1}$ as $\gamma < 0$ and $\alpha > 0$. For the constraitns and the calculus, see notebook 2, p. 64 (entry 2025.05.12).

:::

```{r}
#| label: fig-flexible_fct
#| fig-cap: Different shape of the flexible function $\mu$ for 7 values of $\alpha$ while the other parameters kept fixed
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

#### Should I keep alpha in the following ff function?
ff = function(x, alpha, beta = 0.8, gamma = -0.04, b = 0.8)
	return (alpha*exp(-beta*x) * (x - b/alpha) + gamma*x + b)

curve(ff(x, 0.1), from = 0, to = 11, lwd = 3, col = met.brewer("Homer1")[1], ylim = c(0, 1), axes = FALSE, xlab = "x", ylab = "f")
for (i in 2:7)
	curve(ff(x, i/10), from = 0, to = 11, lwd = 3, col = met.brewer("Homer1")[i], add = TRUE)
axis(1)
axis(2, las = 1)
legend(x = "topright", fill = met.brewer("Homer1"), legend = (1:7)/10, bty = "n")

## ANSWER: I DO NOT KNOW, BUT I FOUND SOME CONSTRAINTS THAT COULD HELP THE MODEL
```

### Results with a more flexible function

```{stan output.var = "betareg_flexible", cache = TRUE}
functions {
	vector r_zhou(vector x, real beta_, real gamma, real b)
	{
		return exp(-beta_*x) .* (x - b) + gamma*x + b; // Third version, linear trend, intercept = 0
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1, upper = N> G; // Number of genus
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] SB;

	// Data
	vector[N] AGB;
}

transformed data {
	vector[N] ratio = SB ./ AGB;

	vector[G] SB_max;
	for (i in 1:G)
		SB_max[i] = max(SB[start[i]:end[i]]);
}

parameters {
	// Parameters of the 'bumpy' function r_zhou
	vector <lower = 0> [G] beta_;
	vector <lower = 0, upper = 1> [G]  b;
	vector <lower = -b ./ SB_max, upper = 0> [G] gamma; // I expect d to be negative

	real <lower = 0> phi; // Precision (well kind of...)
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi*r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]);
		shape2[start[i]:end[i]] = phi*(1 - r_zhou(SB[start[i]:end[i]], beta_[i], gamma[i], b[i]));
	}
}

model{
	// Prior linear regression
	target += normal_lpdf(beta_ | 0, 10);
	target += normal_lpdf(b | 0.5, 0.15);
	target += normal_lpdf(gamma | 0, 10);
	
	// Likelihood
	target += beta_lpdf(ratio | shape1, shape2);
}

generated quantities {
	array[N] real r_gen = beta_rng(shape1, shape2);
}

```

```{r}
## Run model
# Common variables
n_chains = 4

stanData = list(
	N = forest_dt[, .N],
	G = forest_dt[, length(unique(speciesName_sci))],
	start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
	end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

	# Predictors
	SB = forest_dt[, bole_volume_m3], # Same as reconstruct one

	# Data
	AGB = forest_dt[, total_volume_m3]
)

if (!file.exists("./fit_zhou_beta_flexible.rds"))
{
	fit = betareg_flexible$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fit_zhou_beta_flexible"), random = FALSE)
	saveRDS(fit, "./fit_zhou_beta_flexible.rds")
} else {
	fit = readRDS("./fit_zhou_beta_flexible.rds")
}
```

```{r}
#| label: fig-results_flexible
#| fig-cap: Results with the flexible function
#| fig-subcap:
#|   - "Abies alba"
#|   - "Carpinus betulus"     
#|   - "Cedrus atlantica"
#|   - "Fagus sylvatica"      
#|   - "Fraxinus excelsior"
#|   - "Larix decidua"        
#|   - "Picea abies"
#|   - "Pinus halepensis"     
#|   - "Pinus laricio"
#|   - "Pinus nigra"          
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"     
#|   - "Pinus uncinata"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#|   - "Quercus rubra"        
#|   - "Quercus sp."
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 4
#| layout-ncol: 2

count = 0

for (sp in forest_dt[, unique(speciesName_sci)])
{
	count = count + 1
	sp = ls_species[count]

	plot_sp(fit, sp, count, stanData, fun = ff, args = c("beta_", "gamma","b"), pred = TRUE, n_subsample = 1)
}
```

### Residuals flexible model

```{r}
#| label: fig-residuals_flexible
#| fig-cap: Residuals
#| fig-subcap:
#|   - "Abies alba"
#|   - "Abies alba"
#|   - "Carpinus betulus"
#|   - "Carpinus betulus"
#|   - "Cedrus atlantica"
#|   - "Cedrus atlantica"
#|   - "Fagus sylvatica" 
#|   - "Fagus sylvatica" 
#|   - "Fraxinus excelsior"
#|   - "Fraxinus excelsior"
#|   - "Larix decidua"
#|   - "Larix decidua"
#|   - "Picea abies"
#|   - "Picea abies"
#|   - "Pinus halepensis"
#|   - "Pinus halepensis"
#|   - "Pinus laricio"
#|   - "Pinus laricio"
#|   - "Pinus nigra"
#|   - "Pinus nigra"
#|   - "Pinus pinaster"
#|   - "Pinus pinaster"
#|   - "Pinus sylvestris"
#|   - "Pinus sylvestris"
#|   - "Pinus uncinata"
#|   - "Pinus uncinata"
#|   - "Pseudotsuga menziesii"
#|   - "Pseudotsuga menziesii"
#|   - "Quercus petraea"
#|   - "Quercus petraea"
#|   - "Quercus rubra"
#|   - "Quercus rubra"
#|   - "Quercus sp."
#|   - "Quercus sp."
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8
#| layout-ncol: 1

n_sampling = fit$metadata()$iter_sampling

simResp = fit$draws("r_gen")
dim(simResp)

# Reshape simResp as a matrix nobs x n_repetition
simResp_matrix = matrix(data = 0, nrow = forest_dt[, .N], ncol = n_sampling*n_chains)
for (obs in seq_len(forest_dt[, .N]))
	for (chain in 1:n_chains)
		simResp_matrix[obs, ] = simResp[, chain, obs] # One line of n_sampling*n_chains simulations per observation

## Simulated residuals
for (i in seq_along(stanData[["start"]]))
{
	start = stanData[["start"]][i]
	end = stanData[["end"]][i]
	sim_dharma = createDHARMa(simulatedResponse = simResp_matrix[start:end, ],
		observedResponse = forest_dt[start:end, total_ratio],
		fittedPredictedResponse = apply(simResp[, , start:end], MARGIN = 3, median),
		integerResponse = FALSE)

	testDispersion(sim_dharma)

	plot(sim_dharma, quantreg = TRUE)
	plotResiduals(sim_dharma, forest_dt[start:end, bole_volume_m3], quantreg = TRUE)
}
```