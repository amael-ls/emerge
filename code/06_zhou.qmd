---
title: "Simple tests of bole volume models"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
bibliography: /home/ALe-Squin/work/library/bib_file/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\Vtot}{V_{\text{tot}}}
\newcommand{\hdec}{h_{\text{dec}}}
\newcommand{\fmax}{f_{\text{max}}}

<!-- Math operators -->
<!-- \DeclareMathOperator{\ln}{ln} -->

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   LOADING DATA, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)

## Tool function
source("./toolFunctions.R")

plot_sp = function(fit, sp, count, stanData, forest = forest_dt[.(sp)], pred = FALSE, n_subsample = 10)
{
	# Get parameters
	selected_params = c(paste0("k[", count, "]"), paste0("lambda[", count, "]"))
	params = apply(X = fit$draws(c("k", "lambda"))[, , selected_params], MARGIN = 3, FUN = mean)

	start = stanData[["start"]][count]
	end = stanData[["end"]][count]
	n_sampling = fit$metadata()$iter_sampling

	# Plot figure
	# png(paste0("./fig/", sp, ".png"))
	plot(forest[, bole_volume_m3], forest[, total_ratio], pch = 20, col = "#3355AA33", axes = FALSE,
		xlab = "Bole volume", ylab = "Ratio bole/tot volumes", main = sp)
	axis(1)
	axis(2, las = 1)

	curve(r_zhou(x, params[1], params[2]), col = "#CD212A", lwd = 2, add = TRUE, n = 501)

	if (pred)
	{
		sim = fit$draws("r_gen")[sample(x = 1:n_sampling, size = n_subsample, replace = FALSE), , start:end]
		for (i in 1:forest[, .N])
			points(rep(forest[i, bole_volume_m3], n_chains*n_subsample),
				as.numeric(sim[, , i]), col = "#335577AA", pch = ".")
	}
	# dev.off()
}
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra", opt, ".rds"))
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra", opt, ".rds"))

colours = paste0(met.brewer("Egypt")[1:4])
names(colours) = c("conifer", "broadleaf", "inra", "nfi")

forest_dt[fct_type == "broadleaf", fct_colour := colours["broadleaf"]]
forest_dt[fct_type == "conifer", fct_colour := colours["conifer"]]
forest_dt[origin_data == "inra", origin_colour := colours["inra"]]
forest_dt[origin_data == "nfi", origin_colour := colours["nfi"]]

## Add vernacular english names
# vernacularNames = sci2comm(sci = forest_dt[, unique(speciesName_sci)], db = "itis")
```

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   MAIN CONTENT, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

## Introduction
Florence Gohon a travaillé sur des modèles de volume bois-fort tige, $\Vbft$ qui sont consultables (en local) dans le document `~/work/FairCarbon/gohon/rapport_tarifs.pdf`:
$$
	\Vbft = \frac{c^2h}{4\pi \left( 1 - \frac{1.3}{h} \right)^2} \left[ \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec} + \delta_i \frac{\sqrt{\hdec}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec}{h} \right) \right]
$$

Pour l'instant, les tarifs utilisés par l'inventaire sont (facteurs de forme):

- $\Fbft = \left[ \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \frac{\hdec}{\hdec + k} + \frac{\delta}{c^{\epsilon}} \right] \left[ 1 - \left(\frac{0.07 \pi}{c}\right)^3 \left(1 - \frac{1.3}{h}\right)^3 \right]$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \left( \frac{\hdec}{\hdec + k} \right)^{1 + \rho} + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \eta \hdec + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln \left(\frac{\hdec}{h} \right) + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln(\hdec) + \frac{\delta}{c^{\epsilon}}$

Cependant, ces modèles sont peu interprétables physiquement et ressemble plus à un 'fit polynomial'. Dans les prochaines sections, je vais explorer des modèles plus simples plus compréhensibles physiquement en me basant sur la littérature. A voir si ça marche...

## Modèle 1: @Zhou2021

### Quelques notes explicatives

L'idée de base de l'allométrie est qu'une variable biologique $Y$ est reliée à la masse $M$ d'un organisme par une power-law:

$$
Y = Y_0 M^b,
$$
où $Y_0$ est une constante, et $b$ le *scaling exponent* ou *allometric exponent*. En physique, on parle de *scaling equation*, tandis que la bio utilise *allometric* [@daSilva2006].

Partons maintenant de l'équation suivante qui est *mutatis mutandis* celle d'avant:
$$
y = a x^{\psi}
$$ {#eq-allometric}

Le but est de retrouver l'équation 6 de @Zhou2021. Pour ça, il suffit de log-dériver @eq-allometric:

\begin{align*}
	\log(y) &= \log(a) + \psi \log(x) \\
	\frac{d\log(y)}{dx} &= \frac{\psi}{x} \\
	\frac{1}{y}\frac{dy}{dx} &= \frac{\psi}{x} \\
	\psi &= \frac{dy/y}{dx/x}
\end{align*}

The relative change in $y$, $dy/y$ is proportional to the relative change in $x$, $dx/x$, with a factor $\psi$. Then, maybe there is a finite difference method approx, to replace $dy$ by $\Delta y$, or maybe it is just a notation difference... I suspect that the authors kept it analytic and $\Delta$ is just a notation.

Then, they assume that:
$$
\psi = 1 - \frac{kx}{p(\exp[kx] - 1)}
$$

I checked all the other equations, see notebook 2, 25.03.2025, p. 39--47. If I understood well, I should process as follow:

1. Define $x$ as $\Vbft$
2. Define $y$ as $\Vtot - \Vbft$, which is the crown volume, or define $y$ as $\Vtot$ directly?
3. Define $m = \max(x/y)$
4. Define $d = \max(x/y) - \min(x/y)$
5. Check a graph of $\frac{\Delta y/y}{\Delta x/x}$, where I need to sort by $x$ the data table I think... What does it do?

TO FINISH, SUM-UP THE DISCUSSION WITH THE AUTHORS

## Modèle 2: @Longuetaud2013

### Quelques notes explicatives

In this paper, the authors model the Volume Expansion Factor, $\text{VEF} = \Vtot/\Vbft$, in function of the bole volume. By definition, VEF is above 1. For large trees, it is common to see VEF decreasing around 1. They use a Gaussian, which is problematic as it can go below 1 for large trees, which does not make sense physically (total volume smaller than bole volume!). Therefore it must be done differently.

### A test model
I model the opposite of the VEF, \ie $r = \Vbft/\Vtot$, which is by construction between 0 and 1. It represents the percentage of volume represented by the bole. A Beta-distribution seems perfect for that, it respects the bounds and accounts for heteroskedasticity. However, its parameters $\text{shape}_1$ and $\text{shape}_2$ are not intuitive. Fortunately, it is possible to reparametrise the Beta-distrib in function of mean and precision, $\phi$:

- $\text{shape}_1 = \phi \mu$
- $\text{shape}_2 = \phi (1 - \mu)$

Using the mean and variance is of no good idea: it adds an interacting constraint $\sigma^2 < \mu (1 - \mu)$.

I do a first test with:
$$
	\mu = x^k \exp[-x/\lambda],
$$
where $x$ is the bole volume, $\Vbft$, and $k$, $\lambda$ parameters to be estimated, with the constraint $0 < k < e^1/\lambda$ and $\lambda > 0$ ($x > 0$, but this is more a fact than a constraint).

```{r}
## Subset data
forest_dt = forest_dt[origin_data == "inra"]
forest_dt[, nb_indiv := .N, by = speciesName_sci]
forest_dt = forest_dt[nb_indiv > 50]

setkey(forest_dt, speciesName_sci)
ls_species = forest_dt[, unique(speciesName_sci)]
```


```{stan output.var = "betareg_simple", cache = TRUE}
functions {
	vector r_zhou(vector x, real k, real lambda)
	{
		return x.^k .* exp(-x / lambda);
	}
}

data {
	// Dimensions
	int <lower = 1> N; // Number of trees
	int <lower = 1, upper = N> G; // Number of genus
	array[G] int <lower = 1, upper = N> start; // Genus index start
	array[G] int <lower = 1, upper = N> end; // Genus index end

	// Predictors
	vector[N] SB;

	// Data
	vector[N] AGB;
}

transformed data {
	vector[N] ratio = SB ./ AGB;
}

parameters {
	// Parameters of the 'simple' function r_zhou (simple compared to the flexibility I want)
	vector <lower = 0> [G] lambda;
	vector <lower = 0, upper = exp(1) ./ lambda> [G] k;

	real <lower = 0> phi; // Precision (well kind of...)
}

transformed parameters {
	vector [N] shape1;
	vector [N] shape2;

	for (i in 1:G)
	{
		shape1[start[i]:end[i]] = phi*r_zhou(SB[start[i]:end[i]], k[i], lambda[i]);
		shape2[start[i]:end[i]] = phi*(1 - r_zhou(SB[start[i]:end[i]], k[i], lambda[i]));
	}
}

model{
	// Priors
	target += normal_lpdf(k | 0, 10);
	target += normal_lpdf(lambda | 0, 10);
	target += normal_lpdf(phi | 0, 10);
	
	// Likelihood
	target += beta_lpdf(ratio | shape1, shape2);
}

generated quantities {
	array[N] real r_gen = beta_rng(shape1, shape2);
}



```

```{r}
#### Test of the temp.stan model on the forest data
## Compute ratio
forest_dt[, total_ratio := bole_volume_m3/total_volume_m3]

## Run model
# Common variables
n_chains = 4

stanData = list(
	N = forest_dt[, .N],
	G = forest_dt[, length(unique(speciesName_sci))],
	start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
	end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

	# Predictors
	SB = forest_dt[, bole_volume_m3], # Same as reconstruct one

	# Data
	AGB = forest_dt[, total_volume_m3]
)

# Run
if (!file.exists("./fit_zhou_beta.rds"))
{
	fit = betareg_simple$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fit_zhou_beta"), random = FALSE)
	saveRDS(fit, "./fit_zhou_beta.rds")
} else {
	fit = readRDS("./fit_zhou_beta.rds")
}
```

### Results
```{r}
# Plot output
r_zhou = function(x, k, lambda)
	return (x^k*exp(-x/lambda))

count = 0

for (sp in forest_dt[, unique(speciesName_sci)])
{
	count = count + 1
	sp = ls_species[count]
	forest_sub = forest_dt[.(sp)]

	plot_sp(fit, sp, count, stanData, forest = forest_dt[.(sp)], pred = FALSE, n_subsample = 10)
}
```

