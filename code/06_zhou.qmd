---
title: "Simple tests of bole volume models"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
bibliography: ~/work/library/bib_file/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\hdec}{h_{\text{dec}}}
\newcommand{\fmax}{f_{\text{max}}}

<!-- Math operators -->
<!-- \DeclareMathOperator{\ln}{ln} -->

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   LOADING DATA, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
# library(pracma)
# library(mgcv)

source("./toolFunctions.R")
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra", opt, ".rds"))
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra", opt, ".rds"))

colours = paste0(met.brewer("Egypt")[1:4])
names(colours) = c("conifer", "broadleaf", "inra", "nfi")

forest_dt[fct_type == "broadleaf", fct_colour := colours["broadleaf"]]
forest_dt[fct_type == "conifer", fct_colour := colours["conifer"]]
forest_dt[origin_data == "inra", origin_colour := colours["inra"]]
forest_dt[origin_data == "nfi", origin_colour := colours["nfi"]]

## Add vernacular english names
# vernacularNames = sci2comm(sci = forest_dt[, unique(speciesName_sci)], db = "itis")
```

<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->
<!-- ---------------------------   MAIN CONTENT, R CODE   --------------------------- -->
<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= -->

## Introduction
Florence Gohon a travaillé sur des modèles de volume bois-fort tige, $\Vbft$ qui sont consultables dans le document `~/work/FairCarbon/gohon/rapport_tarifs.pdf`:
$$
	\Vbft = \frac{c^2h}{4\pi \left( 1 - \frac{1.3}{h} \right)^2} \left[ \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec} + \delta_i \frac{\sqrt{\hdec}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec}{h} \right) \right]
$$

Pour l'instant, les tarifs utilisés par l'inventaire sont (facteurs de forme):

- $\Fbft = \left[ \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \frac{\hdec}{\hdec + k} + \frac{\delta}{c^{\epsilon}} \right] \left[ 1 - \left(\frac{0.07 \pi}{c}\right)^3 \left(1 - \frac{1.3}{h}\right)^3 \right]$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \left( \frac{\hdec}{\hdec + k} \right)^{1 + \rho} + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \eta \hdec + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln \left(\frac{\hdec}{h} \right) + \frac{\delta}{c^{\epsilon}}$
- $\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln(\hdec) + \frac{\delta}{c^{\epsilon}}$

Cependant, ces modèles sont peu interprétables physiquement et ressemble plus à un 'fit polynomial'. Dans les prochaines sections, je vais explorer des modèles plus simples plus compréhensibles physiquement en me basant sur la littérature. A voir si ça marche...

## Modèle 1: @Zhou2021

### Quelques notes explicatives

L'idée de base de l'allométrie est qu'une variable biologique $Y$ est reliée à la masse $M$ d'un organisme par une power-law:

$$
Y = Y_0 M^b,
$$
où $Y_0$ est une constante, et $b$ le *scaling exponent* ou *allometric exponent*. En physique, on parle de *scaling equation*, tandis que la bio utilise *allometric* [@daSilva2006].

Partons maintenant de l'équation suivante qui est *mutatis mutandis* celle d'avant:
$$
y = a x^{\psi}
$$ {#eq-allometric}

Le but est de retrouver l'équation 6 de @Zhou2021. Pour ça, il suffit de log-dériver @eq-allometric:

\begin{align*}
	\log(y) &= \log(a) + \psi \log(x) \\
	\frac{d\log(y)}{dx} &= \frac{\psi}{x} \\
	\frac{1}{y}\frac{dy}{dx} &= \frac{\psi}{x} \\
	\psi &= \frac{dy/y}{dx/x}
\end{align*}

The relative change in $y$, $dy/y$ is proportional to the relative change in $x$, $dx/x$, with a factor $\psi$. Then, maybe there is a finite difference method approx, to replace $dy$ by $\Delta y$, or maybe it is just a notation difference... I suspect that the authors kept it analytic and $\Delta$ is just a notation.

Then, they assume that:
$$
\psi = 1 - \frac{kx}{p(\exp[kx] - 1)}
$$

I checked all the other equations, see notebook 2, 25.03.2025, p. 39--47. If I understood well, I should process as follow:

1. Define $x$ as $\Vbft$
2. Define $y$ as $\Vtot - \Vbft$, which is the crown volume, or define $y$ as $\Vtot$ directly?
3. Define $m = \max(x/y)$
4. Define $d = \max(x/y) - \min(x/y)$
5. Check a graph of $\frac{\Delta y/y}{\Delta x/x}$, where I need to sort by $x$ the data table I think... What does it do?

### Crash test zone
```{r}
## Subset data
forest_dt = forest_dt[origin_data == "inra"]
forest_dt[, nb_indiv := .N, by = speciesName_sci]
forest_dt = forest_dt[nb_indiv > 50]

setkey(forest_dt, speciesName_sci)
ls_species = forest_dt[, unique(speciesName_sci)]
```


```{r}
#### Test of the temp.stan model on the forest data
## Compute ratio
forest_dt[, total_ratio := bole_volume_m3/total_volume_m3]

## Run model
# Common variables
n_chains = 4

stanData = list(
	N = forest_dt[, .N],
	G = forest_dt[, length(unique(speciesName_sci))],
	start = forest_dt[, .(start = .I[1]), by = speciesName_sci][, start],
	end = forest_dt[, .(end = .I[.N]), by = speciesName_sci][, end],

	# Predictors
	SB = forest_dt[, bole_volume_m3], # Same as reconstruct one

	# Data
	AGB = forest_dt[, total_volume_m3]
)

# Compile model
model = cmdstan_model("./temp.stan")

# ff = function(x, s)
# 	return (x*(1 - x)/s^2 - 1)

# curve(ff(x), from = 0, to = 1, lwd = 2)
# abline(h = 0.14, lwd = 2, col = "#CD212A")


# Run
if (!file.exists("./fit_zhou_beta.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fit_zhou_beta"), random = FALSE)
	saveRDS(fit, "./fit_zhou_beta.rds")
} else {
	fit = readRDS("./fit_zhou_beta.rds")
}
```

```{r}
# Plot output
r_zhou = function(x, k, lambda)
	return (x^k*exp(-x/lambda))

# r_zhou = function(x, alpha, beta_, b, gamma)
# 	return (alpha*exp(-beta_*x) * (x - b/alpha) + gamma*x + b)

# r_zhou_max = function(alpha, beta_, b, gamma)
# {
# 	x_star = b/alpha + 1/beta_*(1 - pracma::lambertWp(-gamma/alpha * exp(beta_*b/alpha + 1)))
# 	return (list(x_star = x_star, value = r_zhou(x_star, alpha, beta_, b, gamma)))
# }

## On test
# curve(r_zhou(x, 0.35, 3.48, 0.79, -0.05), from = 0, to = 12, lwd = 2, col = "#CD212A")

# test = r_zhou_max(0.35, 3.48, 0.79, -0.05)

# abline(v = test[["x_star"]], lwd = 0.8, lty = 2, col = "#798789")
# abline(h = test[["value"]], lwd = 0.8, lty = 2, col = "#798789")

# ## Second test
# curve(r_zhou(x, 0.969, 1.683, 0.129, -0.00388), from = 0, to = 12, lwd = 2, col = "#CD212A")

# test = r_zhou_max(0.969, 1.683, 0.129, -0.00388)

# abline(v = test[["x_star"]], lwd = 0.8, lty = 2, col = "#798789")
# abline(h = test[["value"]], lwd = 0.8, lty = 2, col = "#798789")

count = 0

## --------------------------- START TEST
plot_sp = function(fit, sp, count, stanData, forest = forest_dt[.(sp)], pred = FALSE, n_subsample = 10)
{
	# Get parameters
	# selected_params = c(paste0("alpha[", count, "]"), paste0("beta_[", count, "]"),
	# 	paste0("b[", count, "]"), paste0("gamma[", count, "]"))

	# params = apply(X = fit$draws(c("alpha", "beta_", "b", "gamma"))[, , selected_params], MARGIN = 3, FUN = mean)

	selected_params = c(paste0("k[", count, "]"), paste0("lambda[", count, "]"))

	# params = apply(X = fit$draws(c("alpha", "beta_", "b", "gamma"))[, , selected_params], MARGIN = 3, FUN = mean)
	params = apply(X = fit$draws(c("k", "lambda"))[, , selected_params], MARGIN = 3, FUN = mean)

	start = stanData[["start"]][count]
	end = stanData[["end"]][count]
	n_sampling = fit$metadata()$iter_sampling

	png(paste0("./fig/", sp, ".png"))
	plot(forest[, bole_volume_m3], forest[, total_ratio], pch = 20, col = "#3355AA33", axes = FALSE,
		xlab = "Bole volume", ylab = "Ratio bole/tot volumes", main = sp)
	axis(1)
	axis(2, las = 1)

	curve(r_zhou(x, params[1], params[2]), col = "#CD212A", lwd = 2, add = TRUE, n = 501)
	# curve(r_zhou(x, params[1], params[2], params[3], params[4]), col = "#CD212A", lwd = 2, add = TRUE, n = 501)

	if (pred)
	{
		sim = fit$draws("r_gen")[sample(x = 1:n_sampling, size = n_subsample, replace = FALSE), , start:end]
		for (i in 1:forest[, .N])
			points(rep(forest[i, bole_volume_m3], n_chains*n_subsample),
				as.numeric(sim[, , i]), col = "#335577AA", pch = ".")
	}
	dev.off()
}

## ---------------------------- END TEST

for (sp in forest_dt[, unique(speciesName_sci)])
{
	count = count + 1
	sp = ls_species[count]
	forest_sub = forest_dt[.(sp)]

	plot_sp(fit, sp, count, stanData, forest = forest_dt[.(sp)], pred = FALSE, n_subsample = 10)
}
```

```{r}
## Running a GAM model

# fag_syl = gam(total_ratio ~ s(bole_volume_reconstruct_m3, bs = "cs"), nethod = "REML", data = forest_dt["Fagus sylvatica"])
# x_seq = seq(min(tt$bole_volume_m3), max(tt$bole_volume_m3), length.out = 200)
# y_pred = predict(fag_syl, newdata = data.frame(bole_volume_reconstruct_m3 = x_seq))

# plot(tt[, bole_volume_m3], tt[, total_ratio], pch = 20, col = "#3355AA33", axes = FALSE,
# 		xlab = "Bole volume", ylab = "Ratio bole/tot volumes", main = sp)
# axis(1)
# axis(2, las = 1)

# lines(x_seq, y_pred, lwd = 2, col = "#CD212A")

```


## HEATMAP
```{r}
library(interp)

# Function alpha + beta params from BETA distrib:
f_apb = function(m, v) # mean and variance
	return(m*(1 - m)/v - 1)

N = 2000
aa = data.table(m = runif(n = N, 0, 1), v = runif(n = N, 0, 0.25),
	m2 = seq(0.01, 0.99, length.out = N), v2 = seq(0.01, 0.25, length.out = N))
aa[, f := f_apb(m, v)]
aa[, f2 := f_apb(m2, v2)]

si = interp(x = aa[, m], y = aa[, v], z = aa[, f],
	method = "linear", duplicate = "mean")

si2 = interp(x = aa[, m2], y = aa[, v2], z = aa[, f2],
	method = "linear", duplicate = "mean")

filled.contour(si,
	plot.axes = {
		axis(1)
		axis(2, las = 1)
		contour(si, add = TRUE, lwd = 2, axes = NULL)
	}, xlab = "m", ylab = "v"
)
```


## COMPUTE Y/(1- Y) FROM GEISSINGER ADN PLOT IT

```{r}
plot(forest_dt[, bole_volume_m3], forest_dt[, crown_volume_m3], pch = 20, col = "#87898588")
```

### Data
I have about \num{10000} felled trees, on which the bole volume, $V_b$, and crown volume, $V_c$, have been measured. The two volumes have a correlation of `{r} round(cor(forest_dt["broadleaf"][origin_data == "inra", bole_volume_m3], forest_dt["broadleaf"][origin_data == "inra", crown_volume_m3]), 3)` for broadleaves and of `{r} round(cor(forest_dt["conifer"][origin_data == "inra", bole_volume_m3], forest_dt["conifer"][origin_data == "inra", crown_volume_m3]), 3)` for conifers(see @fig-correl):

```{r}
#| label: fig-correl
#| fig-cap: Correlation between the bole volume and the crown volume
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

# forest_dt[origin_data == "inra", all.equal(bole_volume_m3, bole_volume_reconstruct_m3)]
plot(forest_dt[origin_data == "inra", bole_volume_m3], forest_dt[origin_data == "inra", crown_volume_m3],
	xlab = "Bole volume (m³)", ylab = "Crown volume (m³)", axes = FALSE, pch = 20, lwd = 0,
	col = paste0(forest_dt[origin_data == "inra", fct_colour], "66"))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Conifer", "Broadleaf"), fill = colours[c("conifer", "broadleaf")], bty = "n")
```

However, is it truly the case, or is it a correlation coming from a confounder controlling both volumes, such as diameter (see @fig-correl_scheme for a graphical representation)? The solution is to test for conditional independencies on $\phi$: $[V_b | \phi]$ and $[V_c | \phi]$. In other words, does all the information that $V_b$ brings to $V_c$ come from $\phi$? For this, I do a linear regression (see @McElreath2020, chapters 5 and 6, especially section 6.4).

![Possibility of spurious correlations](img/spurious.tex){#fig-correl_scheme}

```{r}
forest_dt["broadleaf"][origin_data == "inra", cor(height, circumference_m)]
forest_dt["conifer"][origin_data == "inra", cor(height, circumference_m)]

temp_br = as.data.table(scale(forest_dt["broadleaf"][origin_data == "inra",
	.(crown_volume_m3, bole_volume_m3, circumference_m, height)]))

temp_co = as.data.table(scale(forest_dt["conifer"][origin_data == "inra",
	.(crown_volume_m3, bole_volume_m3, circumference_m, height)]))

lm_broadleaf = lm(crown_volume_m3 ~ bole_volume_m3 + circumference_m + height,
	temp_br)
lm_conifer = lm(crown_volume_m3 ~ bole_volume_m3 + circumference_m + height,
	temp_co)

jtools::plot_summs(lm_broadleaf)
jtools::plot_summs(lm_conifer)

## Small example that shows it works to detect spurious
# dt = data.table(c = runif(1e3, 0, 100))
# dt[, x := rnorm(.N, 2*c + 5, 1.3)]
# dt[, y := rnorm(.N, 1.2*c - 4, 0.12)]

# cor(dt[, x], dt[, y])

# l1 = lm(y ~ x, dt) # Spurious, the slope should be near 0
# l3 = lm(y ~ x + c, dt)

# jtools::plot_summs(l1)
# jtools::plot_summs(l2)
# jtools::plot_summs(l3)
```

This is a very rough test as there is clearly no homoscedasticity, however, the bole volume is actually much more important than expected! I suspect that the negative response to height is due to the colinearity between the three variables... A recent [@Zhou2021] relates the above-ground biomass (defined as branches, bark, leaves, and fruits), AGB, to the stem biomass (main trunk, from ground to tip I think), SB. They developed the following formula for indvidual trees (equation 4 in @Zhou2021) and could work to $\Vbft$ to $\Vtot$:
\begin{align*}
	y &= \frac{L \phi^2 h}{m - d \exp[-k x]} \\
	L &= \frac{\pi}{4}w f,
\end{align*}
where $y$ is the AGB, $\phi$ and $h$ are the dbh and height, $m$, $d$, and $k$ are estimated parameters, $w$ is the wood density, and $f$ the form factor defined as:
$$
f = \frac{4V}{\pi \phi^2 h},
$$
with $V$ the total volume of the stem. Then, we get another expression of $y$:
\begin{align*}
	y &= \frac{4 V}{\pi(m - d \exp[-k x])} \\
		&= \frac{V}{m' - d' \exp[-k x]}
\end{align*}
where $m' = \pi m/4$ and $d' = \pi d/4$. Let us try this on the Emerge data!

### Test of the formula from @Zhou2021 on Emerge data

```{r}
#| output: false

## Subset
forest_dt = forest_dt[origin_data == "inra"]
species_vallet = c("Abies alba", "Fagus sylvatica", "Picea abies", "Pinus pinaster", "Pinus sylvestris",
	"Pseudotsuga menziesii", "Quercus petraea")
forest_dt = forest_dt[speciesName_sci %in% species_vallet]

## New variables
forest_dt[, hdn := sqrt(circumference_m)/height]
forest_dt[, slenderness := pi*height/circumference_m] # height/diameter
forest_dt[, formBFT := 4*pi*bole_volume_m3/(height*circumference_m^2)*(1 - 1.3/height)^2]
forest_dt[, formTot_vallet := 4*pi*total_volume_m3/(height*circumference_m^2)]
forest_dt[, form_zhou := 4*pi*bole_volume_m3/(height*circumference_m^2)]

## Add wood density
wood_dens = fread("../data/xylo-dens-map/xdm_species_density_data.csv")[, .(Species, Mean)]
setnames(wood_dens, new = c("speciesName_sci", "w"))
forest_dt = merge.data.table(forest_dt, wood_dens, by = "speciesName_sci")

## Set keys
setkey(forest_dt, speciesName_sci)
n_sp = length(forest_dt[, unique(speciesName_sci)])

## Picea and abies
m = 0.893
d = 0.378
k = -0.0027 # Use the version for equation 4 and not 5

forest_dt[genus %in% c("Picea", "Abies"), zhou_vol := bole_volume_m3/(m - d*exp(-k*circumference_m^2*height/pi^2))]

## In Zhou2021, most form factor are between 0.3 and 0.5. This is a simple check:
# range(forest_dt[genus %in% c("Picea", "Abies"), form_zhou])
# plot(density(forest_dt[genus %in% c("Picea", "Abies"), form_zhou]), lwd = 3, main = "", xlab = "Form factor (Zhou)", axes = FALSE)
# axis(1)
# axis(2, las = 1)
```

```{r}
## Log, degree 4
forest_dt[genus == "Picea", col_sp := "#FAB255"]
forest_dt[genus == "Abies", col_sp := "#43B284"]
plot(forest_dt[genus %in% c("Picea", "Abies"), log(zhou_vol)],
	forest_dt[genus %in% c("Picea", "Abies"), log(total_volume_m3)], pch = 19, cex = 0.5,
	xlab = "Est. total volume (Zhou)", ylab = "Measured total volume",
	col = forest_dt[genus %in% c("Picea", "Abies"), col_sp])

abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
tt2 = lm(formula = log(total_volume_m3) ~ speciesName_sci + (log(zhou_vol) + I(log(zhou_vol)^2) +
	I(log(zhou_vol)^3) + I(log(zhou_vol)^4)):speciesName_sci,
	data = forest_dt[genus %in% c("Picea", "Abies")])
cof_abies = coef(tt2)[seq(1, 9, 2)]
cof_picea = c(sum(coef(tt2)[1:2]), coef(tt2)[seq(4, 10, 2)])
ff = function(x, cof) {return(cof[1] + cof[2]*x + cof[3]*x^2 + cof[4]*x^3 + cof[5]*x^4)}
curve(ff(x, cof_abies), lwd = 3, col = "#3355AA", add = TRUE)
curve(ff(x, cof_picea), lwd = 3, col = "#AA5533", add = TRUE)

sim = simulateResiduals(fittedModel = tt2, plot = FALSE)
plotResiduals(sim, quantreg = TRUE)

## From a + b*log(x) + c*log(x^2) to exp of that = exp(a)*x^(b + 2*c)
# aa_log = 0.8 + 1.2*log(3) + 2.8*log(9)
# exp(aa_log) - (exp(0.8)*3^1.2*3^5.6)
# exp(aa_log) - (exp(0.8)*3^(1.2 + 2*2.8))
```

### Create the model
#### Prior check
```{r}
set.seed(1969 - 08 - 18) # Woodstock seed

n_draws = 200
n_trees = 1e3

dt = forest_dt[sample(x = 1:.N, size = n_trees, replace = FALSE),
	.(circumference_m, height, bole_volume_m3, total_volume_m3)]
ll = vector(mode = "list", length = n_draws)
params = vector(mode = "list", length = n_draws)

for (i in seq_len(n_draws))
{
	m = rnorm(1, mean = 0.9, sd = 0.05);
	d = rnorm(1, mean = 0.3, sd = 0.05);
	k = rnorm(1, mean = 0,  sd =0.01);

	sigma = rgamma(1, shape = 2.5, rate = 7);

	ll[[i]] = rnorm(n_trees, mean = dt[, log(bole_volume_m3)]/(m - d*exp(k*dt[, circumference_m]^2*dt[, height])), sigma);
	params[[i]] = data.table(m = m, d = d, k = k, sigma = sigma)
}

params = rbindlist(params)
# tt = rbindlist(ll)

params[k < 0][which.max(sigma)]
qq = params[, which((-0.01044 < k) & (k < -0.01043))]

plot(dt[, bole_volume_m3], exp(ll[[qq]]), pch = 19, cex = 0.5, xlab = "bole volume", ylab = "pred tot volume") # Show that sigma should be small

plot(dt[, bole_volume_m3], exp(ll[[198]]), pch = 19, cex = 0.5, xlab = "bole volume", ylab = "pred tot volume") # Shos that  k > 0 lead to big values

plot(dt[, log(bole_volume_m3)], ll[[200]], pch = 19, cex = 0.5, xlab = "log(bole volume)", ylab = "log(pred tot volume)") # Show a coherent result

plot(dt[, bole_volume_m3], dt[, total_volume_m3], col = "#CD212A", pch = 19, cex = 0.3)
abline(a = 0, b = 1, lwd = 2)
plot(dt[, log(bole_volume_m3)], dt[, log(total_volume_m3)], col = "#CD212A", pch = 19, cex = 0.3)
abline(a = 0, b = 1, lwd = 2)
```

#### model
```{r}
#### Fit the model
## Compile model
model = cmdstan_model("./04_zhou.stan")

## Stan data
stanData = list(
	N = forest_dt[genus %in% c("Picea", "Abies"), .N],
	S = forest_dt[genus %in% c("Picea", "Abies"), length(unique(speciesName_sci))],
	start = forest_dt[genus %in% c("Picea", "Abies")][, .(start = .I[1]), by = .(speciesName_sci)][, start],
	end = forest_dt[genus %in% c("Picea", "Abies")][, .(end = .I[.N]), by = .(speciesName_sci)][, end],

	circumference = forest_dt[genus %in% c("Picea", "Abies"), circumference_m],
	height = forest_dt[genus %in% c("Picea", "Abies"), height],
	bole_volume = forest_dt[genus %in% c("Picea", "Abies"), bole_volume_m3],

	tot_volume = forest_dt[genus %in% c("Picea", "Abies"), total_volume_m3]
)

## Common variables
n_chains = 4

iter_warmup = 250
iter_sampling = 250
```

### Run the model
```{r}
#| output: false
#| fold: false
## Run
fit = model$sample(data = stanData, chains = n_chains, parallel_chains = ifelse(n_chains < 4, n_chains, 4),
	seed = NULL, refresh = 50, max_treedepth = 12, save_warmup = TRUE,
	iter_sampling = iter_sampling, iter_warmup = iter_warmup, adapt_delta = 0.8)

fit$save_output_files(dir = "./", basename = paste0("fit_zhou"), random = FALSE)
saveRDS(fit, "./fit_zhou.rds")
```

### Posterior check
#### Check some values
```{r}
apply(X = fit$draws("beta0"), MARGIN = 3, FUN = mean)
apply(X = fit$draws("beta1"), MARGIN = 3, FUN = mean)

round(apply(X = fit$draws("m"), MARGIN = 3, FUN = mean), 3)
round(apply(X = fit$draws("k"), MARGIN = 3, FUN = mean), 3)
round(apply(X = fit$draws("d"), MARGIN = 3, FUN = mean), 3)

round(apply(X = fit$draws("sigma"), MARGIN = 3, FUN = mean), 3)
```

#### Generate posterior simulations
```{r}
genQ = cmdstan_model("./04_zhou_gq.stan")

stanData_new = stanData

stanData_new[["selected_species"]] = seq_along(species_vallet)
selected_species = species_vallet[stanData_new[["selected_species"]]]
new_forest = forest_dt[.(selected_species)]

stanData_new[["S_new"]] = length(stanData_new[["selected_species"]])
stanData_new[["N_new"]] = new_forest[, .N]
stanData_new[["start_new"]] = new_forest[, .(start = .I[1]), by = .(speciesName_sci)][, start]
stanData_new[["end_new"]] = new_forest[, .(end = .I[.N]), by = .(speciesName_sci)][, end]

stanData_new[["circumference_new"]] = new_forest[, circumference_m]
stanData_new[["height_new"]] = new_forest[, height]
stanData_new[["bole_volume_new"]] = new_forest[, bole_volume_m3]

sim = genQ$generate_quantities(fit$draws(inc_warmup = FALSE), data = stanData_new)
```

```{r}
mean_pred = apply(X = sim$draws("mean_pred"), MARGIN = 3, FUN = mean)
ratio = apply(X = sim$draws("ratio"), MARGIN = 3, FUN = mean)
rm(sim)

plot(new_forest[, total_volume_m3], ratio, pch = 19, cex = 0.5)

## Plot prediction vs measured
plot(new_forest[, total_volume_m3], exp(mean_pred), pch = 19, cex = 0.5,
	xlab = "Measured tot. vol.", ylab = "Pred. tot. vol.")
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")

## Plot prediction vs measured in log space
plot(new_forest[, log(total_volume_m3)], mean_pred, pch = 19, cex = 0.5,
	xlab = "log(measured tot. vol.)", ylab = "log(pred. tot. vol.)")
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")

# ## Plot simple residuals
# plot(new_forest[, total_volume_m3] - exp(mean_pred), ylab = "Residuals (real space)", pch = 19, cex = 0.5)

# ## Plot simple residuals in log space
# plot(new_forest[, log(total_volume_m3)] - mean_pred, ylab = "Residuals (log space)", pch = 19, cex = 0.5)

## Standardised residuals
plot(mean_pred, sqrt(abs(new_forest[, log(total_volume_m3)] - mean_pred)), pch = 19, cex = 0.5,
	ylab = "sqrt(std. res.)")

## Residuals vs observations
plot(new_forest[, total_volume_m3], new_forest[, total_volume_m3] - exp(mean_pred), pch = 19, cex = 0.5,
	xlab = "Obs. tot. vol", ylab = "Residuals")
```

#### Residuals using DHARMa
```{r}
library(DHARMa)

n_sampling = fit$metadata()$iter_sampling

simResp = sim$draws("pred_tot_volume")
dim(simResp)

# Reshape simResp as a matrix nobs x n_repetition
simResp_matrix = matrix(data = 0, nrow = new_forest[, .N], ncol = n_sampling*n_chains)
for (obs in seq_len(new_forest[, .N]))
{
	col_start = 1
	for (chain in 1:n_chains)
	{
		col_end = chain*n_sampling
		simResp_matrix[obs, col_start:col_end] = simResp[, chain, obs]
		col_start = col_end + 1
	}
}

## Simulated residuals
sim_dharma = createDHARMa(simulatedResponse = simResp_matrix,
	observedResponse = new_forest[, total_volume_m3],
	fittedPredictedResponse = apply(sim$draws("mean_pred"), MARGIN = 3, median),
	integerResponse = FALSE)

plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, new_forest[, bole_volume_m3], quantreg = TRUE)

ind_min = which.min(new_forest[, bole_volume_m3])
ind_max = which.max(new_forest[, bole_volume_m3])

dd = density(simResp[, , ind_min])
plot(dd, xlab = "Simulated volume (min predictor)", xlim = c(0, max(dd$x, new_forest[ind_min, total_volume_m3])),
	main = paste("Real value:", round(new_forest[ind_min, total_volume_m3], 3)))
abline(v = new_forest[ind_min, total_volume_m3], lwd = 3, col = "#CD212A")

dd = density(simResp[, , 9])
plot(dd, xlab = "Simulated volume (min predictor)", xlim = c(0, max(dd$x, new_forest[9, total_volume_m3])),
	main = paste("Real value:", round(new_forest[9, total_volume_m3], 3)))
abline(v = new_forest[9, total_volume_m3], lwd = 3, col = "#CD212A")

zz = (new_forest[, bole_volume_m3] - new_forest[, min(bole_volume_m3)])/diff(range(new_forest[, bole_volume_m3]))
zz[5630]
```


```{r}
aa = forest_dt[genus %in% c("Picea", "Abies")]

plot(aa[, circumference_m], aa[, total_volume_m3], pch = 19, cex = 0.5)
plot(aa[, circumference_m], aa[, bole_volume_m3], pch = 19, cex = 0.5)
plot(aa[, height], aa[, bole_volume_m3], pch = 19, cex = 0.5)
plot(aa[, hdn], aa[, bole_volume_m3], pch = 19, cex = 0.5)
plot(aa[, circumference_m^2*height/(4*pi)], aa[, total_volume_m3], pch = 19, cex = 0.5)
plot(aa[, circumference_m^2*height/(4*pi)], aa[, total_volume_m3], pch = 19, cex = 0.5)



library(interp)

aa = aa[!duplicated(cbind(aa$circumference_m, aa$height))]
aa = aa[sample(x = seq_len(.N), size = 500, replace = FALSE)]


si = interp(x = aa[, circumference_m], y = aa[, height], z = aa[, bole_volume_m3],
	method = "linear", duplicate = "mean")

filled.contour(si,
	plot.axes = {
		axis(1)
		axis(2, las = 1)
		contour(si, add = TRUE, lwd = 2, axes = NULL)
	}
)




si = interp(x = aa[, circumference_m], y = aa[, height], z = aa[, bole_volume_m3],
	method = "linear", duplicate = "mean")

filled.contour(si,
	plot.axes = {
		axis(1)
		axis(2, las = 1)
		contour(si, add = TRUE, lwd = 2, axes = NULL)
	}
)
```



```{r}
#### Zhou equation 7
eq_7_zhou = function(x, k, p)
	return (1 - k*x/(p*exp(k*x) - 1))

k = 0.23
p = 1.2

curve(eq_7_zhou(x, k, p), from = 0, to = 30, lwd = 2, col = "#CD212A")
```

## EXAMPLE BETA REG
```{r}
library(betareg)

n = 5e2
set.seed(1969 - 08 - 18)
dt = data.table(x1 = rnorm(n = n, mean = 0, sd = 1), x2 = rgamma(n = n, shape = 1^2/2.54, rate = 1/2.54))

# Coeff lin reg
b0 = 0.139
b1 = 0.358
b2 = -0.07

# Precision
phi = 4

# Simulate data
dt[, m := 1/(1 + exp(-(b0 + b1*x1 + b2*x2)))] # Logistic function

dt[, y := rbeta(n = n, shape1 = phi*m, shape2 = phi*(1 - m))]

range(dt$y)
hist(dt$y)
hist(dt$m)

test = betareg(y ~ 1 + x1 + x2, data = dt, link = "logit")

momo = cmdstan_model("betareg.stan")

stanData = list(
	N = dt[, .N],
	x1 = dt[, x1],
	x2 = dt[, x2],
	Y = dt[, y]
)

tt = momo$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4))

lazyPosterior(tt$draws("b0"), fun = dnorm, mean = 0, sd = 1)
lazyPosterior(tt$draws("b1"), fun = dnorm, mean = 0, sd = 1)
lazyPosterior(tt$draws("b2"), fun = dnorm, mean = 0, sd = 1)
```

## Study of the mean function 4th trial

$$
f(x; k, \lambda) = x^k \exp[-x/\lambda]
$$

