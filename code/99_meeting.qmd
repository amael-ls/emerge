---
title: "Document de synthèse pour la réunion du 21 mars 2025"
date: today
author: Amaël Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - diagram
diagram:
  engine:
    tikz:
      execpath: lualatex
      header-includes:
        \usepackage{pgfplots}
        \pgfplotsset{compat=1.18}
        \usepgfplotslibrary{fillbetween}
        \usetikzlibrary{arrows.meta}
        \usetikzlibrary{positioning}
        \usetikzlibrary{calc}
        \definecolor{trunkCol}{HTML}{FFAF37}
        \makeatletter
          \tikzset{
          database/.style={
          path picture={
          \draw[fill = trunkCol] (0, 1.5*\database@segmentheight) circle [x radius=\database@radius,
          y radius=\database@aspectratio*\database@radius];
          \draw (-\database@radius, 0.5*\database@segmentheight) arc [start angle=180,end angle=360,x radius=\database@radius,
          y radius=\database@aspectratio*\database@radius];
          \draw (-\database@radius,-0.5*\database@segmentheight) arc [start angle=180,end angle=360,x radius=\database@radius,
          y radius=\database@aspectratio*\database@radius];
          \draw (-\database@radius,1.5*\database@segmentheight) -- ++(0,-3*\database@segmentheight) arc [start angle=180,end angle=360,
          x radius=\database@radius, y radius=\database@aspectratio*\database@radius] -- ++(0,3*\database@segmentheight);
          },
          minimum width=2*\database@radius + \pgflinewidth,
          minimum height=3*\database@segmentheight + 2*\database@aspectratio*\database@radius + \pgflinewidth,
          },
          database segment height/.store in=\database@segmentheight,
          database radius/.store in=\database@radius,
          database aspect ratio/.store in=\database@aspectratio,
          database segment height=0.1cm,
          database radius=0.25cm,
          database aspect ratio=0.35,
          }
        \makeatother
        \tikzset{arrow/.style = {> = {Latex[length = 1.2mm]}}}
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
  cache: true
bibliography: references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
          \usepackage{siunitx}
      - macros.tex
    number-sections: true
    link-citations: true
    fig-pos: "H"
---

## Info réunion:
21.03.2025 à 10h00: [{{< fa solid at title="Réunion teams" >}} Lien Teams](https://teams.microsoft.com/l/meetup-join/19%3ameeting_MzNiZDA3ZmMtMDNjNy00NzE5LWFjNzMtNjcxZjcxZjBkNjhh%40thread.v2/0?context=%7b%22Tid%22%3a%223876b373-7e2c-4857-b024-53326b5b4bb2%22%2c%22Oid%22%3a%228ea3b1a4-f284-4393-957d-b97b8cc75dc7%22%7d)

## Contexte

Le projet Alamod, financé par le pepr FairCarboN, a pour objectif de faire une nouvelle estimation du volume aérien total, $\Vtot$, des arbres sur les placettes IFN et de croiser ces données avec les estimations de densité (projet XyloDensMap, XDM) afin d'en déduire la biomasse puis le stockage de carbone des forêts françaises. Dans un même temps, l'IGN a proposé de revoir ses tarifs de volume bois-fort tige, $\Vbft$, afin de s'assurer que $\Vbft \leqslant \Vtot$. Autrement dit, il est proposé de revoir la chaîne de calcul volume, biomasse, carbone:

```tikz
\begin{tikzpicture}
	\node (vol) at (0, 0) {Volume};
	\node[below = of vol.mid east, anchor = mid east] (dens) {Densité};

	\path (vol.mid east) -- (dens.mid east) node[midway, right = 0.8cm, anchor = mid west] (bio) {Biomasse};
	\draw[->, arrow, out = 0, in = 180] (vol.mid east) to (bio.mid west);
	\draw[->, arrow, out = 0, in = 180] (dens.mid east) to (bio.mid west);

	\node[right = 0.8cm of bio.mid east, anchor = mid west] (C) {Carbone};
	\draw[->, arrow] (bio.mid east) to (C.mid west);

	\node[database, above left = 0.3cm of vol, label = above:Emerge, database radius = 0.3cm,
		database segment height = 0.15cm] (emerge) {};

	\node[database, below left = 0.3cm of dens, label = below:XyloDensMap, database radius = 0.3cm,
		database segment height = 0.15cm] (xdm) {};

	\draw[->, arrow, dashed, out = -90, in = 180] (emerge.south) to (vol.mid west);
	\draw[->, arrow, dashed, out = 90, in = 180] (xdm.north) to (dens.mid west);
\end{tikzpicture}
```

Dans ce document, je présente les données (@sec-data) et les tarifs existants (@sec-hist), puis les pistes explorées/explorables pour le volume total et bois-fort tige (@sec-pistes).

## Données {#sec-data}
Afin de comprendre les données, je définis d'abords ce qu'est un arbre dans la @sec-treePart puis je montre les distributions des données dans la @sec-dataDistrib.

### Définition d'un arbre IGN {#sec-treePart}

Les arbres sont partitionnés en éléments hiérarchiques par les inventaires forestiers nationaux (\eg @fig-partition). Les définitions des éléments peuvent varier entre inventaires, et ne contaignent pas forcément les mêmes données. Dans notre cas, les données proviennent de différents instituts et différentes périodes:

1.  Protocole Oudin, données préservées par l'INRA, entre 1930 and 1980 (<span class="egypt_red"></span> sur la @fig-map).

2.  Inventaire forestier (<span class="egypt_blue"></span> on the @fig-map), entre 1988 to 2007.

3.  L'Office National des Forêts (ONF), avec un protocole de 1972 et de 1983. Données non-utilisées pour l'instant car coordonées absentes et j'aimerais peut-être inclure des prédicteurs climatiques.

4.  Institut Technologique Forêt, Cellulose, Bois-construction, Ameublement (FCBA), non explorées pour l'instant.

5.  L'Institut pour le développement forestier (IDF), R&D du Centre National de la Propriété Forestière et de l'Institut national de recherche en sciences et technologies pour l'environnement et l'agriculture (IRSTEA, maintenant INRAE), non explorées pour l'instant.

```{mermaid}
%%| label: fig-partition
%%| fig-cap: Partition d'un arbre (inspiré de @Gschwantner2009)
%%| fig-width: 7
flowchart LR
subgraph SUB0 [Level 0]
	W(Arbre complet)
end

subgraph SUB1 [Level 1]
	W --> A(Aérien)
	W --> B(Souterain)
end

subgraph SUB2 [Level 2]
	A --> M(Tronc)
	A --> L(Latéral)
	A --> F(Feuilles)

	B --> E(...)
end

subgraph SUB3 [Level 3]
	M --> S(Top tronc)
	M --> MB(Grume)
	M --> MS(Souche)
	L --> LB(Grosse branches)
	L --> SB(Petites branches)
end

style SUB0 fill: #CCCCCC, color: #112233
style SUB1 fill: #CCCCCC, color: #112233
style SUB2 fill: #CCCCCC, color: #112233
style SUB3 fill: #CCCCCC, color: #112233

style W fill: #99DDFF, color: #030303

style A fill: #99DDFF, color: #030303
style B fill: #99DDFF, color: #030303

style M fill: #99DDFF, color: #030303
style L fill: #99DDFF, color: #030303
style F fill: #99DDFF, color: #030303
style E fill: #99DDFF, color: #030303

style S fill: #99DDFF, color: #030303
style MB fill: #99DDFF, color: #030303
style MS fill: #99DDFF, color: #030303
style LB fill: #99DDFF, color: #030303
style SB fill: #99DDFF, color: #030303

```

J'utilise les définitions (inspirées de @Gschwantner2009, voir @fig-partition et @fig-treeDef) pour les différentes parties d'un arbre:

- Tronc: Tige principale avec dominance apicale
	- Top tronc: La partie du tronc au dessus du diamètre de découpe \qty{7}{\centi\metre}
	- Grume: Partie du tronc entre la souche et le top
	- Souche: Partie qui resterait après une coupe suivant des pratiques normales d'abattage.
- Latéral:
	- Grosses branches: Portions latérales avec diamètre supérieur ou égal à \qty{7}{\centi\metre}
	- Petites branches: Portions latérales avec diamètre inférieur à \qty{7}{\centi\metre}

![Partitionnement, avec le tronc (vert), le top (jaune), grosses branches (bleues), et petites branches (rouges)](img/tree_ign.png){#fig-treeDef}

### Distribution des données {#sec-dataDistrib}
```{r}
#| output: false
#### Clear space and load packages
rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(inventR)
library(stringi)
library(terra)
library(mgcv)
library(gt)

#### Tool function
angle2dec = function(angle)
{
	x = stri_match(angle, regex = "([+-]?\\d+)°(\\d+)'(\\d+)") # To split the degree from minute and second
	x = apply(x[, 2:4], 1L, function(y) {
		y = as.numeric(y)
		y[1] + y[2]/60 + y[3]/3600
	})
	return(x)
}

#### Read data
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (!dir.exists(mnt_point))
	stop(paste0("The mounting point <", mnt_point, "> does not exist"))
path_data = paste0(mnt_point, "data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Check mounting point and mounted folder"))

forest_dt = readRDS(paste0(path_data, "nfi-inra_dt_full.rds"))
ind_species = readRDS(paste0(path_data, "ind_species_nfi-inra_full.rds"))
swiss_dt = readRDS(paste0(path_data, "switzerland.rds"))

coords_nfi = vect(paste0(path_data, "coords_nfi_full"))
coords_inra = vect(paste0(path_data, "coords_inra_full"))
coords_swiss = vect(paste0(path_data, "coords_switzerland"))
```

Le jeu de données est constitué principalement de *Quercus*, *Pinus*, et *Fagus* (voir @fig-data) et les parcelles couvrent la majeur partie du territoire français pour l'IFN tandis que les données du protocole Oudin sont beaucoup moins bien réparties (voir @fig-map).

```{r}
#| label: fig-data
#| fig-cap: Nombre d'individus par genre, avec les conifères en bleu et les feuillus en. Attention, échelle en $\\log_{10}$
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
species_nb = unique(ind_species[["ind_species"]][, .(n_indiv = sum(n_indiv), colour), by = genus])[order(n_indiv)]

par(mar = c(5, 12, 2, 2))
# Use barplot f or horizontal bars
barplot(
	species_nb[, n_indiv],
	names.arg = species_nb[, genus],
	horiz = TRUE, # Horizontal bars
	xlab = "Number of individuals",
	ylab = "",
	main = "",
	las = 1,
	log = "x",
	col = species_nb[, colour]
)
```

```{r}
#| label: fig-map
#| fig-cap: "Location of the plots, with NFI for the Naional Forest Invetory of France, and EFM the Experimental Forest Monitoring of Switzerland [@Didion2024]"
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

#### Coordinates
## Read shapefiles
switzerland = project(vect(paste0(path_data, "shapefiles/switzerland/CHE_adm0.shp")), coords_inra)
france = project(vect(paste0(path_data, "shapefiles/france/FRA_adm0.shp")), coords_inra)
belgium = project(vect(paste0(path_data, "shapefiles/belgium/gadm41_BEL_0.shp")), coords_inra)
italy = project(vect(paste0(path_data, "shapefiles/italy/gadm41_ITA_0.shp")), coords_inra)
luxembourg = project(vect(paste0(path_data, "shapefiles/luxembourg/gadm41_LUX_0.shp")), coords_inra)
germany = project(vect(paste0(path_data, "shapefiles/germany/gadm41_DEU_0.shp")), coords_inra)

fr_ch = project(rbind(france, switzerland), coords_inra)

## Projections
colours = met.brewer(name = "Lakota", n = 3)
names(colours) = c("nfi", "swiss", "inra")

## Plot
plot(fr_ch, lwd = 2, axes = FALSE)
points(coords_nfi, col = colours["nfi"], pch = 20, cex = 0.35)
points(coords_inra, col = colours["inra"], pch = 20, cex = 1.15)
points(project(coords_swiss, coords_inra), col = colours["swiss"], pch = 20, cex = 0.55)
plot(fr_ch, lwd = 2, add = TRUE, bg = "transparent")
plot(luxembourg, lwd = 2, add = TRUE)
plot(germany, lwd = 2, add = TRUE)
plot(belgium, lwd = 2, add = TRUE)
plot(italy, lwd = 2, add = TRUE)

legend(x = "bottomleft", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n", inset = c(0, 0.1))
```

Il y a aussi un biais dans la sélection des arbres en sus du biais géographique, comme le montre les figures de distribution des diamètres, des hauteurs, et des volumes (voir @fig-responses et @fig-responses2). Enfin, les données Emerge (C. Deleuze, *discussion*), comme les données suisse (Anne Herold-Bonardi, *discussion*), sont aussi biaisées sur la structure des arbres (principalement prélevés en futaies et taillis sous futaies) et ne sont pas représentatives des différents formes d'arbre sur le territoire. Les @fig-responses et @fig-responses2 montrent aussi clairement l'hétéroscédasticité (variance augmente avec la circonférence).

```{r}
#| label: fig-distrib_circumferences
#| fig-cap: Distribution of circumferences
#| layout-nrow: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
#| dev: tikz

# --- Circumferences
dd_fr = density(forest_dt[origin_data == "nfi", circumference_m]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", circumference_m]) # Inra/Emerge data
dd_ch = density(swiss_dt[, circumference_m]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Circumference (m)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")
```

```{r}
#| label: fig-distrib_heights
#| fig-cap: Distribution of heights
#| layout-nrow: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
#| dev: tikz

# --- Heights
dd_fr = density(forest_dt[origin_data == "nfi", height]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", height]) # Inra/Emerge data
dd_ch = density(swiss_dt[, height]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Height (m)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")
```

```{r}
#| label: fig-distrib_mySlenderness
#| fig-cap: "Distribution of slenderness ($h/\\sqrt{x}$)"
#| layout-nrow: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9
#| dev: tikz

# --- Slenderness
dd_fr = density(forest_dt[origin_data == "nfi", height/sqrt(circumference_m)]) # French NFI
dd_in = density(forest_dt[origin_data == "inra", height/sqrt(circumference_m)]) # Inra/Emerge data
dd_ch = density(swiss_dt[, height/sqrt(circumference_m)]) # swiss data

plot(dd_fr, col = colours["nfi"], axes = FALSE, lwd = 3, xlab = "Slenderness ($h/\\sqrt{x}$)", main = "",
	ylim = c(0, max(dd_fr$y, dd_in$y, dd_ch$y)))
polygon(dd_fr, col = paste0(colours["nfi"], 44))

lines(dd_in, col = colours["inra"], lwd = 3)
polygon(dd_in, col = paste0(colours["inra"], 44))

lines(dd_ch, col = colours["swiss"], lwd = 3)
polygon(dd_ch, col = paste0(colours["swiss"], 44))

axis(1)
axis(2, las = 1)
legend(x = "topright", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n")
```

```{r}
#### Binding both forest_dt and swiss_dt
## Temporary data
temp = rbind(forest_dt[, .(plot_id, tree_id, genus, circumference_m,
		bole_volume_m3 = bole_volume_reconstruct_m3, crown_volume_m3, origin_data)],
	swiss_dt[, .(plot_id, tree_id, genus, circumference_m,
		bole_volume_m3 = bole_volume_cyl_m3, crown_volume_m3)], fill = TRUE)

## Origin data and colours
temp[is.na(origin_data), origin_data := "swiss"]
temp[, colour := colours[origin_data], by = origin_data]

## Remove genus that 
select_genus = temp[, .N, by = .(genus, origin_data)][, .N, by = genus][N > 1, genus]

## List genus and set keys
temp = temp[genus %in% select_genus]

setkey(temp, genus, origin_data)
ls_genus = unique(temp[, genus]) # Insured that it is sorter by alphabetical order
```

```{r}
#| label: fig-responses
#| fig-cap: "Relation volume *v.s.* circonférence pour les 17 genres présent dans au moins deux jeux de données parmis l'IFN, Emerge, et EFM (Experimental Forest Management, @Didion2024)"
#| fig-subcap:
#|   - "Abies"
#|   - "Acer"
#|   - "Betula"
#|   - "Carpinus"
#|   - "Castanea"
#|   - "Cedrus"
#|   - "Fagus"
#|   - "Fraxinus"
#|   - "Juglans"
#| 
#|   - "Larix"
#|   - "Picea"
#|   - "Pinus"      
#|   - "Populus"
#|   - "Prunus"
#|   - "Pseudotsuga"
#|   - "Quercus"
#|   - "Ulmus" 
#| layout-nrow: 3
#| layout-col: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

for (current_gen in ls_genus[1:9])
{
	pres_inra = FALSE
	pres_swiss = FALSE

	plot(temp[.(current_gen, "nfi"), circumference_m], temp[.(current_gen, "nfi"), bole_volume_m3], cex = 0.45,
		xlab = "Circumference (m)", ylab = "Bole volume (m³)", main = "", axes = FALSE, pch = 19, lwd = 0,
		col = colours["nfi"], xlim = c(0, max(temp[.(current_gen), circumference_m])), cex.lab = 2)
	
	if (temp[.(current_gen, "inra"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "inra"), circumference_m], temp[.(current_gen, "inra"), bole_volume_m3],
			cex = 0.55, col = colours["inra"], pch = 19, lwd = 0)
		pres_inra = TRUE
	}
		
	if (temp[.(current_gen, "swiss"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "swiss"), circumference_m], temp[.(current_gen, "swiss"), bole_volume_m3],
			cex = 0.55, col = paste0(colours["swiss"], ifelse(pres_inra, "66", "FF")), pch = 19, lwd = 0)
		pres_swiss = TRUE
	}

	axis(1, cex.axis = 2)
	axis(2, las = 1, cex.axis = 2)

	if (pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n",
		cex = 2)
	if (pres_inra && !pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI"), fill = colours[c("inra", "nfi")], bty = "n", cex = 2)
	if (!pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("NFI", "EFM"), fill = colours[c("nfi", "swiss")], bty = "n", cex = 2)
}
```


```{r}
#| label: fig-responses2
#| fig-cap: "Relation volume *v.s.* circonférence pour les 17 genres présent dans au moins deux jeux de données parmis l'IFN, Emerge, et EFM (Experimental Forest Management, @Didion2024)"
#| fig-subcap:
#|   - "Larix"
#|   - "Picea"
#|   - "Pinus"      
#|   - "Populus"
#|   - "Prunus"
#|   - "Pseudotsuga"
#|   - "Quercus"
#|   - "Ulmus" 
#| layout-nrow: 3
#| layout-col: 3
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 9

for (current_gen in ls_genus[10:17])
{
	pres_inra = FALSE
	pres_swiss = FALSE

	plot(temp[.(current_gen, "nfi"), circumference_m], temp[.(current_gen, "nfi"), bole_volume_m3], cex = 0.45,
		xlab = "Circumference (m)", ylab = "Bole volume (m³)", main = "", axes = FALSE, pch = 19, lwd = 0,
		col = colours["nfi"], xlim = c(0, max(temp[.(current_gen), circumference_m])), cex.lab = 2)
	
	if (temp[.(current_gen, "inra"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "inra"), circumference_m], temp[.(current_gen, "inra"), bole_volume_m3],
			cex = 0.55, col = colours["inra"], pch = 19, lwd = 0)
		pres_inra = TRUE
	}
		
	if (temp[.(current_gen, "swiss"), .N, nomatch = NULL] > 0)
	{
		points(temp[.(current_gen, "swiss"), circumference_m], temp[.(current_gen, "swiss"), bole_volume_m3],
			cex = 0.55, col = paste0(colours["swiss"], ifelse(pres_inra, "66", "FF")), pch = 19, lwd = 0)
		pres_swiss = TRUE
	}

	axis(1, cex.axis = 2)
	axis(2, las = 1, cex.axis = 2)

	if (pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI", "EFM"), fill = colours[c("inra", "nfi", "swiss")], bty = "n",
		cex = 1.25)
	if (pres_inra && !pres_swiss)
		legend(x = "topleft", legend = c("Emerge", "NFI"), fill = colours[c("inra", "nfi")], bty = "n", cex = 2)
	if (!pres_inra && pres_swiss)
		legend(x = "topleft", legend = c("NFI", "EFM"), fill = colours[c("nfi", "swiss")], bty = "n", cex = 2)
}
```

## Historique des tarifs {#sec-hist}

### Facteur de forme et robustesse

Le facteur de forme, $\Ftot$, a été introduit par @Vallet2006 pour le volume aérien total, puis a été modifié lors du projet Emerge [@Deleuze2013_b] afin de corriger les problèmes survenant pour les petits arbres (explosion du facteur de forme pour compenser un dbh proche de 0). Ce nouveau facteur de forme, est défini ici pour le volume bois-fort (voir @nte-bft_tot) par:
$$
\Fbft = \frac{4\pi \Vbft}{c^2h} \left( 1 - \frac{1.3}{h} \right)^2
$$ {#eq-Fbft}
Il est notamment utilisé afin de limiter l'hétéroscédasticité du volume bois-fort tige, $\Vbft$, en fonction de la robustesse, $\hdn = \frac{\sqrt{c}}{h}$ (voir @sec-hdn). Il correspond à un taux de remplissage d'un cylindre de hauteur $h$ et de circonférence $c$ par l'arbre en question.

::: {#nte-bft_tot .callout-note}

## Facteur de forme pour $\Vbft$ et $\Vtot$

Dans @Vallet2006, le facteur de forme ne possède pas la correction $\left( 1 - \frac{1.3}{h} \right)^2$. Son facteur de forme est aussi défini pour le volume total, et pas pour le volume bois-for tige (BFT). Cependant, avec @Deleuze2013_b, la formulation du facteur de forme est la même, si on remplace le volume total par le volume BFT dans la formulation de @Vallet2006.

:::

Dans cet section, je regarde si le facteur de forme est vraiment plus adapté et plus facile à manipuler que le volume direct. Dans la @sec-hdn, je reviens sur la définition de la robustesse, puis dans la @sec-ff j'étudie le facteur de forme. J'utilise les données du protocole Oudin [@Deleuze2013], mais ne garde que les 7 espèces présentes dans @Vallet2006. La @fig-fagSyl tente de reproduire la figure 3 de @Vallet2006, mais il semble que les données ne soient pas tout à fait les mêmes. D'après [@Deleuze2013_b], les données de @Vallet2006 sont un sous-échantillon des données que nous avons à disposition, je suppose donc que ses deux jeux de données se ressemblent suffisament pour pouvoir discuter de la robustesse et du facteur de forme.

```{r}
#| label: fig-fagSyl
#| fig-cap: Facteur de forme en fonction de la circonférence pour *Fagus sylvatica*. Les données sont sensées être similaire à celle utilisées dans @Vallet2006
#| fig-asp: 1
#| out-width: 95%
#| fig-width: 8.142857

## New variables
forest_dt[, hdn := sqrt(circumference_m)/height]
forest_dt[, slenderness := pi*height/circumference_m] # height/diameter
forest_dt[, formBFT := 4*pi*bole_volume_m3/(height*circumference_m^2)*(1 - 1.3/height)^2]
forest_dt[, formBFT_reconstruct := 4*pi*bole_volume_reconstruct_m3/(height*circumference_m^2)*(1 - 1.3/height)^2]
forest_dt[, formTot_vallet := 4*pi*total_volume_m3/(height*circumference_m^2)]
forest_dt[, formBFT_vallet_reconstruct := 4*pi*bole_volume_reconstruct_m3/(height*circumference_m^2)]

## Copy of the whole dataset before subset
forest_dt_full = copy(forest_dt)

## Subset
forest_dt = forest_dt[origin_data == "inra"]
species_vallet = c("Abies alba", "Fagus sylvatica", "Picea abies", "Pinus pinaster", "Pinus sylvestris",
	"Pseudotsuga menziesii", "Quercus petraea")
forest_dt = forest_dt[speciesName_sci %in% species_vallet]

## Set keys
setkey(forest_dt, speciesName_sci)
n_sp = length(forest_dt[, unique(speciesName_sci)])

## Fit a simple GAM for Fagus sylvatica
fam_fagSyl = gam(formula = formTot_vallet ~ 1 + s(circumference_cm),
	data = list(formTot_vallet = forest_dt[.("Fagus sylvatica"), formTot_vallet],
	circumference_cm = 100*forest_dt[.("Fagus sylvatica"), circumference_m]), method = "REML")

pred = predict(fam_fagSyl, newdata = list(circumference_cm = sort(100*forest_dt[.("Fagus sylvatica"), circumference_m])))

## Plot
plot(100*forest_dt[.("Fagus sylvatica"), circumference_m], forest_dt[.("Fagus sylvatica"), formTot_vallet],
	xlab = "Circonférence en cm", ylab = "Facteur de forme tot Vallet", axes = FALSE, pch = 3, cex = 0.5)
abline(h = c(0.4, 0.6, 0.8, 1), lty = "dotted", col = "#2233FFAA")
axis(1)
axis(2, las = 1)
lines(x = sort(100*forest_dt[.("Fagus sylvatica"), circumference_m]), y = pred, lwd = 3, col = "#CD212A")
```

### Discussion sur la robustesse, hdn {#sec-hdn}

La robustesse est définie dans @Vallet2006 par:
$$
\hdn = \frac{\sqrt{c}}{h},
$$
avec $c$ la circonférence à \qty{1.3}{\metre} et $h$ la hauteur. Mais d'où vient cette formule? Pour ça, il faut aller voir l'équation 4 de @Vallet2006 (une régression linéaire de $h$ en fonction de $c$):
$$
\log(h) = a + b \log(c).
$$ {#eq-hdnRegLin}
Il a trouvé que $b = 0.5$ pour la plupart des espèces, et donc:
\begin{align*}
	h &= \exp[a + 0.5 \log(c)] \\
		&= \exp[a] \exp[0.5 \log(c)] \\
		&= \exp[a] \sqrt{c} \\
\end{align*}
d'où le ratio $\frac{\sqrt{c}}{h} = \exp[-a]$. Plus $a$ est petit, et plus le ratio est grand (arbre trapu). Vérifions maintenant que j'ai bien $b \approx 0.5$ pour la plupart des espèces, et que les hypothèses d'une régression linéaire sont bien satisfaites.

#### Régression linéaire
```{r}
## Run species-specific linear regressions
reg_lin = vector(mode = "list", length = n_sp)
names(reg_lin) = species_vallet
coeff_dt = data.table(speciesName_sci = species_vallet, a = -Inf, b = -Inf, corr_ch = -Inf, corr_chdn = -Inf, corr_cs = -Inf)
setkey(coeff_dt,speciesName_sci)

for (sp in species_vallet)
{
	reg_lin[[sp]] = lm(log(height) ~ 1 + log(circumference_m), forest_dt[sp])
	coeff_dt[sp, c("a", "b") := as.list(round(unname(coef(reg_lin[[sp]])), 3))]
	coeff_dt[sp, c("corr_ch", "corr_chdn", "corr_cs") := .(
		round(cor(forest_dt[sp, circumference_m], forest_dt[sp, height]), 2),
		round(cor(forest_dt[sp, circumference_m], forest_dt[sp, hdn]), 2),
		round(cor(forest_dt[sp, circumference_m], forest_dt[sp, slenderness]), 2)
	)]
}

forest_dt[, pred := predict(reg_lin[[speciesName_sci]], data.frame(circumference_m = circumference_m)),
	by = speciesName_sci]
forest_dt[, pred_05 := reg_lin[[speciesName_sci]]$coefficients["(Intercept)"] + 0.5*log(circumference_m),
	by = speciesName_sci]
```
Les régressions linéaires sont satisfaisantes et les hypothèses des modèles linéaires satisfaites (me croire sur parole, mais je peux montrer les résidus). En revanche, contrairement à ce qui est annoncé dans @Vallet2006, les valeurs de $b$ ne sont pas forcément proche 0.5 (voir @tbl-regLin), bien que ce soit une approximation acceptable (voir @fig-regLin_comp).

```{r}
#| label: tbl-regLin
#| tbl-cap: "Coefficients des régressions linéaires par espèce et corrélations de Pearsons $c$ *vs.* $h$, $c$ *vs.* hdn, et $c$ *v.s.* slenderness"

coeff_dt |>
	gt() |>
	cols_label(
		speciesName_sci = "Species",
		corr_ch = "Corr. c, h",
		corr_chdn = "Corr. c, hdn",
		corr_cs = "Corr. c, slend"
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(weight = "bold", align = "right")),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(align = "right")),
		locations = cells_body(columns = speciesName_sci)
	)
```

Utiliser la robustesse au lieu de la hauteur, $h$ permet en partie de briser la relation linéaire avec la circonférence, $c$. Cependant, ce ratio ne semble pas être utilisé dans la littérature sur les volumes, de plus son nom anglais *hardiness coefficient* porte a confusion avec *frost hardiness*, *tree hardiness*, et *cold hardiness* qui réfèrent tous aux *hardiness zones*, à savoir la température minimale acceptée par une espèce. Dans ce cas, il vaut mieux travailler avec un autre nom, tel que *robustness*. A noter que l'élancement, *slenderness*, déjà utilisée dans Emerge (un peu à tort car combiné avec hdn... donc corrélations! Voir @sec-emerge) reste très corrélé à la circonférence. L'élancement correspond à remplacer le coefficient de regression par 1. A titre indicatif, je montre l'influence de remplacer la valeur du coefficient de régression $b$ (@eq-hdnRegLin) par $0.5$ dans la @fig-regLin_comp.

```{r}
#| label: fig-regLin_comp
#| fig-cap: "Influence du remplacement du coefficient de regression par 0.5"
#| fig-subcap: 
#|   - "*Abies alba*"
#|   - "*Fagus sylvatica*"
#|   - "*Picea abies*"
#|   - "*Pinus pinaster*"
#|   - "*Pinus sylvestris*"
#|   - "*Pseudotsuga menziesii*"
#|   - "*Quercus petraea*"
#| lightbox: 
#|   group: linear_reg_comp
#| layout-ncol: 2

for (sp in species_vallet)
{
	plot(forest_dt[sp, circumference_m], forest_dt[sp, height], pch = 19, cex = 0.25,
		axes = FALSE, xlab = "Circonférence (m)", ylab = "Hauteur (m)", cex.lab = 1.5)
	curve(exp(coeff_dt[sp, a] + coeff_dt[sp, b]*log(x)), col = "#CD212A", lwd = 3, add = TRUE)
	curve(exp(coeff_dt[sp, a] + 0.5*log(x)), col = "#3355AA", lwd = 3, add = TRUE)
	curve(exp(coeff_dt[sp, a] + log(x)), col = "#33AA55", lwd = 3, add = TRUE)
	axis(1, cex.axis = 1.5)
	axis(2, las = 1, cex.axis = 1.5)
	legend(x = "topleft", legend = c(round(coeff_dt[sp, b], 2), "0.5", "1"), col = c("#CD212A", "#3355AA", "#33AA55"),
		lwd = 2, lty = 1, bty = "n", cex = 1.5)
}
```

### Discussion sur le facteur de forme {#sec-ff}
Le facteur de forme semble lui aussi peu utilisé dans la littérature sur les volumes (mais lire @Zhou2021). A titre d'exemple, les suisses [@Fischer2019, chap. 12] et les américains [@Westfall2023] utilisent directement le diamètre et la hauteur. L'avantage est que c'est simple, mais comme ces deux variables sont probablement corrélées, cela pose problème sur l'interprétation du modèle (les prédictions du modèle ne sont pas affectées en revanche). D'après la @fig-hdn, la robustesse semble une variable explicative prometteuse à utiliser en sus de la circonférence.

```{r}
#| label: fig-hdn
#| fig-cap: "Facteur de forme *vs.* robustesse"
#| fig-subcap: 
#|   - "*Abies alba*"
#|   - "*Fagus sylvatica*"
#|   - "*Picea abies*"
#|   - "*Pinus pinaster*"
#|   - "*Pinus sylvestris*"
#|   - "*Pseudotsuga menziesii*"
#|   - "*Quercus petraea*"
#| lightbox: 
#|   group: linear_reg_comp
#| layout-ncol: 2

## Fagus sylvatica
for (sp in species_vallet)
{
	plot(forest_dt[sp, hdn], forest_dt[sp, formTot_vallet], pch = 19, cex = 0.25,
		axes = FALSE, xlab = "hdn", ylab = "Form factor")
	axis(1)
	axis(2, las = 1)
}
```

D'après François Morneau, un second avantage du facteur de forme est qu'il permet d'enlever l'hétéroscédasticité [@Morneau2016]. Il est certain que l'hétéroscédasticité diminue (voir @fig-heterosced_1 et @fig-heterosced_2), cependant elle est suffisament présente pour faire échouer une méthode linéaire flexible telle qu'un GAM (Generalised Additive Model), comme le montre les résidus pour *Quercus robur* (voir @fig-heterosced_res). J'ai choisi cette espèce car elle est aussi dans @Morneau2010 et @Morneau2016. Les résidus ont été calculé via le package `DHARMa` qui fonctionne comme suit:

1. Simule $n$ nouvelles réponses du modèle pour chaque observation (par défaut $n = 250$)
2. Pour chaque observation, calcule la fonction de répartition (*cumulative density function, CDF*) des simulations correspondantes
3. Les résidus de l'observation $\text{obs}_i$ égalent la fonction de répartition évaluée à cette observation: $\text{res}(\text{obs}_i) = CDF(\text{obs}_i)$. Si tout va bien, ça vaut 0.5, autrement dit $\text{obs}_i$ est la médiane des simulations correspondantes. Si 0, alors les simulations surestiment toujours $\text{obs}_i$ et si 1, alors les simulation sous-estiment à 100% $\text{obs}_i$.

```{r}
#| output: false

#### Quercus robur data (because it is the species Francois Morneau used as an example)
## Subset data
setkey(forest_dt_full, speciesName_sci)
set.seed(1969 - 08 - 18)
quercus_rob = forest_dt_full[.("Quercus robur")][sample(x = 1:.N, size = 5000, replace = FALSE)]

## GAM
fam_queRob = gam(formula = formBFT_reconstruct ~ 1 + s(circumference_m),
	data = list(formBFT_reconstruct = forest_dt_full[.("Quercus robur"), formBFT_reconstruct],
	circumference_m = forest_dt_full[.("Quercus robur"), circumference_m]), method = "REML")

pred = predict(fam_queRob, newdata = list(circumference_m = sort(forest_dt_full[.("Quercus robur"), circumference_m])))

## Residuals
sim = DHARMa::simulateResiduals(fam_queRob, quantreg = TRUE)
```

```{r}
#| label: fig-heterosced_1
#| fig-cap: "Volume BFT *v.s.* circonférence pour 5000 *Quercus robur* sélectionnés aléatoirement"

## Volume vs c
plot(quercus_rob[, circumference_m], quercus_rob[, bole_volume_reconstruct_m3], pch = ".",
	xlab = "Circonférence", ylab = "Volume bois-fort tige", axes = FALSE)

axis(1)
axis(2, las = 1)
```

```{r}
#| label: fig-heterosced_2
#| fig-cap: "Coefficient de forme *v.s.* circonférence pour 5000 *Quercus robur* sélectionnés aléatoirement"

## Form factor vs c
plot(quercus_rob[, circumference_m], quercus_rob[, formBFT_reconstruct], pch = ".", xlab = "Circonférence",
	ylab = "Facteur de forme", axes = FALSE)
lines(x = sort(forest_dt_full[.("Quercus robur"), circumference_m]), y = pred, lwd = 3, col = "#CD212A")

axis(1)
axis(2, las = 1)
```

```{r}
#| label: fig-heterosced_res
#| fig-cap: "Résidus calculés avec `DHARMa`. Les régressions quantiles devraient suivrent les lignes horizontales"
DHARMa::plotResiduals(sim, quantreg = TRUE)
```

### Tarifs IFN et Emerge {#sec-tarifs_ifn}

Les volumes BFT sont calculés avec des formules à trois entrées pour les arbres à mesures complètes (circonférence, hauteur, et hauteur de découpe relevés, voir @tbl-units) avec différentes formules ([@eq-vol3_v1] -- [@eq-vol3_v5]) selon l'espèce cible, et à une entrée pour les arbres qui n'ont que la circonférence de mesurée.

| Variable | Définition | Unité |
|--:|:------|:--|
| $c$ | Circonférence à hauteur de poitrine (\qty{1.3}{\metre}) | \unit{m} |
| $\hdec$ | Hauteur de décrochement | \unit{m} |
| $h$ | Hauteur totale | \unit{m} |
| PDS | poids statistique de l'arbre par repli de placette | - |
| $S$ | Surface terrière à hauteur de poitrine | \unit{m^2} |
| $v$ | Volume bois-fort tige | \unit{m^3} |
| $\Vtot$ | Volume aérien total (tarif Vallet) | \unit{m^3} |
| W | Coefficient de pondération | - |
: Unités des variables impliquées dans le calcul des volumes {#tbl-units}{.borderless}

#### Equations (trois entrées)
Je réécris ci-dessous les équations des facteurs de formes à trois entrées avec l'abus de notation suivant:
$$
c = \min(c, 3).
$$ {#eq-c}
Autrement dit, dans les [@eq-vol3_v1] -- [@eq-vol3_v5], la circonférence maximale est de \qty{3}{\metre}. La seule exception est pour les conifères exotiques (ESS = 68), où cette limite supérieure ne s'applique pas. Les variables, $c$, $h$, et $\hdec$ sont définies dans @tbl-units.

::: {#wrn-lim_c .callout-warning}

## Limitation de la circonférence

Cette limite me parait un peu arbitraire et petite (un diamètre de \qty{95}{cm} maximum!). Voici l'e-mail du 25 Novembre 2024 de Laurent Haugomat à propos de l'arbre `npp = "18-2B-360-1-226T"` et `a = 7`:

> Bonjour Amaël,
> ce sont nos facteurs de forme qui divergent, dans ton calcul tu utilises le c13, qui vaut 8.696, nous on le ramène à 3 car , dixit Cédric : 
> > « pour les très gros arbres, comme le facteur de forme décroit avec l'augmentation de circonférence, on arrivait à une sous-estimation du volume, ce qui avait poussé François à limiter ce phénomène par un C13 max... »
> Ce qui explique nos différences de volumes.

**A noter que cette limite n'est utilisé que dans le calcul du facteur de forme! Elle n'est pas utilisée dans le calcul du volume du cylindre**

:::

**Version 1**:
$$
\Fbft = \left[ \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \frac{\hdec}{\hdec + k} + \frac{\delta}{c^{\epsilon}} \right] \left[ 1 - \left(\frac{0.07 \pi}{c}\right)^3 \left(1 - \frac{1.3}{h}\right)^3 \right]
$$ {#eq-vol3_v1}
**Version 2**:
$$
\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \fmax \left( \frac{\hdec}{\hdec + k} \right)^{1 + \rho} + \frac{\delta}{c^{\epsilon}}
$$ {#eq-vol3_v2}
**Version 3**:
$$
\Fbft = \alpha + \beta c + \eta \hdec + \frac{\delta}{c^{\epsilon}}
$$ {#eq-vol3_v3}
**Version 4**:
$$
\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln \left(\frac{\hdec}{h} \right) + \frac{\delta}{c^{\epsilon}}
$$ {#eq-vol3_v4}
**Version 5**:
$$
\Fbft = \alpha + \beta c + \gamma \frac{\sqrt{c}}{h} + \eta \ln(\hdec) + \frac{\delta}{c^{\epsilon}}
$$ {#eq-vol3_v5}

Comme indiqué dans @wrn-lim_c, il a fallu borner ces équations. Ce n'est pas une solution satisfaisante et il vaut mieux contraindre lors de l'estimation des paramètres plutôt qu'*a posteriori*. C'est aussi un signe qu'il est instable de prédire un volume en dehors de l'intervalle de circonférences utilisées pour paramétrer le modèle.

#### Equations (une entrée)

Les équations ci-dessous pour le volume $\Vbft$ à une entrée ne sont valables qu'à partir de 2014 et portent sur le volume BFT (et non sur le facteur de forme $\Fbft$). Elles prennent en compte la compétition (surface terrière):

**Version 1**:
$$
v = \exp\left[ \alpha + \beta \ln(c) + \gamma \ln(c)^2 + \delta \ln(c)^3 + \zeta \ln(c)^4 + \eta \ln(g) + \frac{\sigma^2}{2} \right]
$$ {#eq-vol1_v1}
**Version 2**:
$$
v = \exp\left[ \alpha + \beta \ln(c) + \gamma \ln(c)^2 + \delta \ln(c)^3 + \zeta \ln(c)^4 + \eta g + \frac{\sigma^2}{2} \right]
$$ {#eq-vol1_v2}
avec:
$$
g = \sum_{i \in \mathcal{V}} \frac{\text{W}_i}{\text{PDS}_i} S_i
$$
où $\mathcal{V}$ est l'ensemble des arbres vivants (veget = 0) sur la placette, et $S_i$ est la surface terrière à \qty{1.30}{\metre} de l'arbre $i$.

::: {.callout-warning}

Les formules sont différentes pour les peupleuraies et invoque l'âge du peuplement. Je ne les détaille pas ici.

:::

### Tarifs développés par Florence Gohon 'Renouveau des tarifs de cubage de l’Inventaire -- Ajustements 2023'

Florence a reformulé les tarifs comme suit [@Gohon2023]:
$$
\Fbft = \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hpdec} + \delta_i \frac{\sqrt{\hpdec}}{c^2h} +
	\eta_i \left( 1 - \frac{\hpdec}{h} \right),
$$
où $i$ est l'indice de l'espèce, et $\hpdec = \hdec$ s'il y a une découpe et $h$ sinon.

Ces nouveaux tarifs produisent des volumes bois-fort tige très similaires aux tarifs utilisés actuellement, avec en général une diminution de 0 à 3% pour les espèces les plus communes [@Gohon2023, Fig. 15] et ont l'avantage de n'utiliser qu'une formule pour toutes les espèces (contrairement aux cinq formules de la @sec-tarifs_ifn). Ces tarifs sont applicables tant que $\hdec$ est disponible (\ie depuis 2014).

## Pistes explorables {#sec-pistes}

### Modèle d'Emerge {#sec-emerge}

Je reprend ici le modèle d'Emerge [@Deleuze2014]:
\begin{equation} \label{eq::deleuze}
\begin{aligned}
	\Ftot &\sim \N(\mu, \sigma) \\
	\mu_{i, j} &= a_{i, j} + b_i \frac{\sqrt{c}}{h} + d_{i, j} \frac{h}{c} \\
	a_{i, j} &\sim \N(\alpha_i, \sigma_{\alpha}) \\
	d_{i, j} &\sim \N(\delta_i, \sigma_{\delta}),
\end{aligned}
\end{equation}
où $\alpha_i$ et $\delta_i$ sont les 'interceptes de groupes' (une valeur pour les conifères et une valeur feuillus). Je tente de reproduire leur modèle en version Bayésienne en utilisant le langage Stan qui communique avec R via le package `cmdstanr`.

La version bayésienne fonctionne bien, et est capable de prédire de nouvelles données (\eg prédiction sur des *Quercus robur/petraea*, @fig-bayesEmerge). En revanche, je trouve des valeurs de paramètres complètement différentes de @Deleuze2014 qui utilise le package `nlme`. Dans les 2 cas, les prédictions sur de nouvelles données sont bonnes, ce qui montre qu'il n'y a pas unicité du jeu de paramètre qui fonctionne. Cette intuition de corrélation entre paramètres est confirmée avec la heatmap du log likelihood posterieur dans l'espace de paramètre $b$ et $d$ (réponse à la robustesse et élancement, respectivement).

![Prédictions sur des *Quercus robur/petraea* cubés en 2010 lors du projet Emerge](./testEmerge_files/figure-pdf/fig-posteriorPred-1.png){#fig-bayesEmerge width=80%}

![Heatmap du log likelihood dans l'espace des paramètres suspectés d'être corrélés](./heatmap.pdf){#fig-heatmap}

## References

::: {#refs}
:::