---
title: "Hierachical models"
date: today
author: AmaÃ«l Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
  warning: false
  message: false
bibliography: ./centralised_bibliography/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\Fcrn}{F_{\text{CRN}}}

\newcommand{\Vcrn}{V_{\text{crown}}}

\newcommand{\Vtot}{V_{\text{tot}}}

\newcommand{\hdec}{h_{\text{tap}}}
\newcommand{\htot}{h_{\text{tot}}}
\newcommand{\ddec}{\phi_{\text{tap}}}

\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\E}{\mathds{E}}

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
library(DHARMa)
library(interp)
library(gt)

## Tool function
source("./toolFunctions.R")

## Regression formula for crown
linReg = function(x, p1, p2, p3, p4, p5)
	return(p1 + p2*x + p3*x^2 + p4*x^3 + p5*x^4)

## Regression formula for bole
powReg = function(x, p1, p2, p3, shift)
	return(p1 + p2*(x - shift)^p3)

## Get volume from Florence formula with bounds
florence_bft = function(c, h, hdec, params, bounds)
{
	fnew = params[1, alpha] + params[1, beta]*c + params[1, gamma]*sqrt(c)/hdec +
		params[1, delta]*sqrt(hdec)/(c^2*h) + params[1, eta]*(1 - hdec/h)

	fnew = max(fnew, bounds[1, bft_min])
	fnew = min(fnew, bounds[1, bft_max])

	# Remember that fnew_old is bounded by f_lim, and new = (1 - 1.3/h)^2 old
	return(c^2*h/(4*pi) * min(fnew/(1 - 1.3/h)^2, bounds[1, bft_lim]))
}

## To get volume from Bayesian form factor
getVol = function(nfi_sp, k, fit)
{
	str = paste0("pred_formFactor[", k, "]")
	convert = nfi_sp[k, circumference_m^2]*nfi_sp[k, height]/(4*pi*(1 - 1.3/nfi_sp[k, height])^2)
	return (fit$draws(str)*convert)
}

## Internal function from DHARMa package
rankTransform = function(x)
{
	pred = rank(x, ties.method = "average")
	pred = pred / max(pred)
	return(pred)
}
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"
# opt = "_inra"

## Loading
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))

## Subset data
inra = forest_dt[origin_data == "inra"] 
nfi = forest_dt[origin_data == "nfi"]
nfi = nfi[, n_indiv := .N, by = speciesName_sci]
nfi = nfi[n_indiv > 10000]

setkey(inra, speciesName_sci)
setkey(nfi, speciesName_sci)

rm(forest_dt)

## Load profiles
profiles = readRDS(paste0(mnt_point, "data/profiles_oudin.rds"))
```

Estimation of $\hdec$ from the profiles.
```{r}
## Rk: A decrease of 10% of circumference (i.e., C_{n + 1} = 0.9 C_n) implies 19% in volume (0.9^2 = 0.81)
profiles[, decrease_10pct := {prev = data.table::shift(log_volume_m3, type = "lag")
	(log_volume_m3 / prev) <= 0.81}, by = unique_id]

## Rk It is almost sure that the circumference decreases by 10% between 0.5 and 1.5 m height, because of
#		butt swell (empattement). Moreover, measures starts from 1.3 m at the french NFI
profiles = profiles[at_height > 1.5]

# For each unique_id, keep only the first TRUE as TRUE, which will indicate taper height (hdec)
profiles[, first_true := FALSE]

profiles[decrease_10pct == TRUE, 
	first_true := .I == .I[1],  # mark only the first TRUE row within each group
	by = unique_id]

# plot(profiles[1:16, at_height], profiles[1:16, log_volume_m3], pch = 19, cex = 0.75, col = "#CD212A")

profiles = profiles[(first_true), .(unique_id, hdec = at_height + 0.5)] # +0.5 because measured every metre
```

Add estimated taper height to `inra`
```{r}
inra[unique_id %in% profiles$unique_id]

inra = merge.data.table(inra, profiles, by = "unique_id", all.x = TRUE)
inra[!is.na(hdec), .N, by = speciesName_sci]
setkey(inra, speciesName_sci)
```

## Intro

The ratio model is dangerous! Check how steep is the curve for small value of $\Vbft$... That means a hypersensitive model for small trees!

Therefore, I need to change the paradigm! In the @sec-univariate_BFT I recreate the model of Florence to estimate $\Vbft$ from three variables: $c$, $h$, and, $\hdec'$ (which is either $\hdec$ or $\htot$).

## Apply the model of Florence to Emerge data

In this section, I apply the model of FLorence to the Emerge data. The parameters' value can be found in `rapport_tarifs.pdf`, p. 33 (annexe 2).

```{r}
#### Coeff data table
coeffs_3 = data.table(
	speciesName_sci = c("Quercus robur", "Quercus petraea", "Fagus sylvatica", "Pinus pinaster",
		"Pinus sylvestris", "Abies alba", "Picea abies"),
	tarif = c("02", "03", "09", "51", "52", "61", "62"),
	alpha = c(0.4139968, 0.4439589, 0.3962135, 0.3625385, 0.3826291, 0.4333959, 0.4468885),
	beta = c(-0.0069499, -0.0203087, 0.0004032, 0.0172278, 0.0057494, 0.0043911, -0.0315384),
	gamma = c(-0.3001131, -0.2944278, -0.2723268, -0.1878927, -0.2250570, -0.2955610, -0.3736340),
	delta = c(-0.0348160, -0.0390426, -0.0353373, -0.0238314, -0.0247413, -0.0305603, -0.0321009),
	eta = c(-0.0075658, -0.0140190, -0.0166928, -0.0183863, -0.0026865, -0.0089731, 0.0188160),
	bft_min = c(0.15, 0.15, 0.13, 0.17, 0.17, 0.17, 0.20),
	bft_max = c(0.44, 0.43, 0.43, 0.40, 0.42, 0.48, 0.43),
	bft_lim = c(0.8, 0.8, 0.9, 0.9, 1.0, 0.9, 0.9),
	key = "speciesName_sci"
)
```

```{r}
#### Check estimated hdec of Emerge vs measured hdec from nfi for Fagus sylvatica
inra_dec = inra["Fagus sylvatica"][!is.na(hdec) & !(presence_NA)]

plot(nfi["Fagus sylvatica", circumference_m], nfi["Fagus sylvatica", taper_height], pch = 19,
	cex = 0.75, xlab = "Circumference", ylab = "Taper height", axes = FALSE, col = "#0F7BA2")
points(inra_dec[, circumference_m], inra_dec[, hdec], col = "#FAB255", pch = 19, cex = 0.75)
axis(1)
axis(2, las = 1)

#### Compute the taper volume for 7 species
inra_dec[, bole_volume_m3_gohon := florence_bft(circumference_m, height, hdec,
		params = coeffs_3["Fagus sylvatica", .(alpha, beta, gamma, delta, eta)],
		bounds = coeffs_3["Fagus sylvatica", .(bft_min, bft_max, bft_lim)])]

plot(inra_dec[, bole_volume_m3_gohon], inra_dec[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")

inra_dec[, bole_volume_m3_gohon := NULL]
```

### Fit model Florence{#sec-univariate_BFT}

The model is described by @eq-flo_univariate:
$$
	\Fbft = \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec'} + \delta_i \frac{\sqrt{\hdec'}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec'}{h} \right)
$${#eq-flo_univariate}

For the code and equation, see `rapport_tarifs.Rmd`, line 638. I now fit a Bayesian version of Florence's model for *Fagus sylvatica*.

```{r}
model = cmdstan_model("./florence_univariate.stan")

stanData = list(
	N = nfi["Fagus sylvatica", .N],

	circumference_m = nfi["Fagus sylvatica", circumference_m],
	height = nfi["Fagus sylvatica", height],
	hdec = nfi["Fagus sylvatica", taper_height],

	bole_volume_m3 = nfi["Fagus sylvatica", bole_volume_m3]
)

n_chains = 4

if (!file.exists("florence-fagSyl.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)
	fit$save_output_files(dir = "./", basename = paste0("florence-fagSyl"), random = FALSE)
	saveRDS(fit, "florence-fagSyl.rds")
} else {
	fit = readRDS("./florence-fagSyl.rds")
}

fagSyl = rbindlist(list(florence = coeffs_3["Fagus sylvatica", .(alpha, beta, gamma, delta, eta)],
	amael = data.table(
		alpha = mean(fit$draws("alpha")),
		beta = mean(fit$draws("beta_")),
		gamma = mean(fit$draws("gamma")),
		delta = mean(fit$draws("delta")),
		eta = mean(fit$draws("eta")))
), idcol = "model")

#### Pred on Inra data
genQ = cmdstan_model("./florence_univariate_genQ.stan")
stanData_gen = list(
	N = inra_dec["Fagus sylvatica", .N],

	circumference_m = inra_dec["Fagus sylvatica", circumference_m],
	height = inra_dec["Fagus sylvatica", height],
	hdec = inra_dec["Fagus sylvatica", hdec],

	bole_volume_m3 = inra_dec["Fagus sylvatica", bole_volume_m3]
)

sim = genQ$generate_quantities(fit, data = stanData_gen, seed = 123, parallel_chains = min(n_chains, 4))

mean_pred = apply(X = sim$draws("pred_bole"), MARGIN = 3, FUN = mean)
plot(mean_pred, inra_dec["Fagus sylvatica", bole_volume_m3], pch = 19, cex = 0.3,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
```

### Try with heteroskedasticity

Based on the previous section, I add heteroskedasticity by modelling the variance with a power-law:
$$
	\sigma = a (c^2 h)^b,
$$
where $a > 0$ and $b$ are two parameters to estimate. I fit the model on 6000 individuals only, in order to go faster.

```{r}
model = cmdstan_model("./florence_univariate_heterosked.stan")

sam = sample(seq_len(nfi["Fagus sylvatica", .N]), size = 6e3, replace = FALSE)
nfi_sam = nfi["Fagus sylvatica"][sam]

stanData = list(
	N = 6e3, # nfi["Fagus sylvatica", .N],

	circumference_m = nfi_sam[, circumference_m],
	height = nfi_sam[, height],
	hdec = nfi_sam[, taper_height],

	bole_volume_m3 = nfi_sam[, bole_volume_m3]
)

n_chains = 4

if (!file.exists("florence-fagSyl_heterosked.rds"))
{
	fit_heterosked = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)
	fit_heterosked$save_output_files(dir = "./", basename = paste0("florence-fagSyl_heterosked"), random = FALSE)
	saveRDS(fit_heterosked, "florence-fagSyl_heterosked.rds")
} else {
	fit_heterosked = readRDS("florence-fagSyl_heterosked.rds")
}

fagSyl = rbindlist(list(fagSyl,
	data.table(
		model = "heterosked",
		alpha = mean(fit_heterosked$draws("alpha")),
		beta = mean(fit_heterosked$draws("beta_")),
		gamma = mean(fit_heterosked$draws("gamma")),
		delta = mean(fit_heterosked$draws("delta")),
		eta = mean(fit_heterosked$draws("eta")))
))
```

As shown in the following table, the results between Florence and I are quite different, despite being the same model. The training dataset might not be exactly the same, but I guess the major difference comes from the Bayesian framework. Adding heterosked did not change that much the values.

```{r}
fagSyl |>
	gt() |>
	cols_label(
		model = "Model",
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = model)
	) |>
	fmt_number(
		columns = ends_with("a"),
		decimals = 4
	)
```

```{r}
a = mean(fit_heterosked$draws("a"))
b = mean(fit_heterosked$draws("b"))

sigma_fct = function(x, a, b)
	return (a*x^b)

range(stanData$circumference_m^2*stanData$height)
curve(sigma_fct(x, a, b), to = 700)

genQ = cmdstan_model("./florence_univariate_heterosked_genQ.stan")
sim = genQ$generate_quantities(fit_heterosked, data = stanData_gen, seed = 123, parallel_chains = min(n_chains, 4))

mean_pred = apply(X = sim$draws("pred_bole"), MARGIN = 3, FUN = mean)
plot(mean_pred, inra_dec["Fagus sylvatica", bole_volume_m3], pch = 19, cex = 0.3,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
```

## Explore the crown

In this section, I look at the relation there can be between the crown and tree dimensions (circumference, height, and taper height).

```{r}
lim = quantile(inra_dec[, hdec], c(0.25, 0.5, 0.75))
inra_dec[, `:=` (colour = met.brewer("Egypt")[1], class = 1)]
inra_dec[(lim["25%"] < hdec) & (hdec <= lim["50%"]), `:=` (colour = met.brewer("Egypt")[2], class = 2)]
inra_dec[(lim["50%"] < hdec) & (hdec <= lim["75%"]), `:=` (colour = met.brewer("Egypt")[3], class = 3)]
inra_dec[lim["75%"] < hdec, `:=` (colour = met.brewer("Egypt")[4], class = 4)]

# fwrite(inra_dec[, .(circumference_m, bole_volume_m3, crown_volume_m3, class)],
# 	"./pgfplots/inra_dec.csv")

plot(inra_dec[, log(circumference_m)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.65, xlab = "Circumference", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height - hdec)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
```

Not that convincing... Let us try to use a form factor similar to the one used for bole volume:
$$
	\Fcrn = \frac{4\pi \Vcrn}{c^2 h} \left( 1 - \frac{1.3}{h} \right)^2
$$

```{r}
inra_dec[, Fcrn := 4*pi*crown_volume_m3/(circumference_m^2*height)*(1 - 1.3/height)^2]
inra_dec[, Fcrn_sphere := 6*pi^2*crown_volume_m3/circumference_m^3]

plot(inra_dec[, log(circumference_m)], inra_dec[, log(Fcrn)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Circumference", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(Fcrn)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height) - hdec], inra_dec[, Fcrn], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(circumference_m)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Circumference", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height - hdec)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
```

## Simple test of crown model

I will try a crown model with a hierarchy at the taper height level (try also with height and more values!). This model will use $\log(c)$ to predict $\log(\Vcrn)$.

```{r}
#### Prepare the data
## Compute the indices
# Reorder data
setorder(inra_dec, hdec)

# Indices
indices = inra_dec[, .(start = .I[1], end = .I[.N]), by = .(colour)]
indices[, class := c("small", "med", "tall", "very tall")]
```

And now, the test of the crown model...
```{r}
model = cmdstan_model("./crown.stan")

stanData = list(
	N = inra_dec[, .N],
	N_group = indices[, .N],
	start_ind = indices[, start],
	end_ind = indices[, end],
	circumference_m = inra_dec[, circumference_m],
	crown_volume_m3 = inra_dec[, crown_volume_m3]
)

n_chains = 4

if (!file.exists("crown.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)
	fit$save_output_files(dir = "./", basename = paste0("crown"), random = FALSE)
	saveRDS(fit, "crown.rds")
} else {
	fit = readRDS("crown.rds")
}
```

And here are few posterior stuff

```{r}
pred = apply(X = fit$draws("pred_crown"), FUN = mean, MARGIN = 3)
apply(X = fit$draws("sigmas"), FUN = mean, MARGIN = 3)

plot(pred, inra_dec[, crown_volume_m3], pch = 19, cex = 0.35, col = inra_dec[, colour],
	xlab = "Pred", ylab = "Obs", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")

n_sampling = fit$metadata()$iter_sampling

simResp = fit$draws("pred_crown")
dim(simResp)
n_chains = dim(simResp)[2] # Number of successful chains

# Reshape simResp as a matrix nobs x n_repetition
simResp_matrix = matrix(data = 0, nrow = inra_dec[, .N], ncol = n_sampling*n_chains)
for (obs in seq_len(inra_dec[, .N]))
	for (chain in 1:n_chains)
		simResp_matrix[obs, ] = simResp[, chain, obs] # One line of n_sampling*n_chains simulations per observation

sim_dharma = createDHARMa(simulatedResponse = simResp_matrix,
	observedResponse = inra_dec[, crown_volume_m3],
	fittedPredictedResponse = apply(simResp, MARGIN = 3, median),
	integerResponse = FALSE)

plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, inra_dec[, circumference_m], quantreg = TRUE)
```

## Simple test of trunk-crown model {#sec-mvn_trunk-crown}
```{r}
## Compile correlated and uncorrelated models
model = cmdstan_model("./trunk-crown.stan")
uncor = cmdstan_model("./crown-trunk_uncor.stan")

stanData = list(
	N = inra_dec[, .N],

	circumference_m = inra_dec[, circumference_m],

	bole_volume_m3 = inra_dec[, bole_volume_m3],
	crown_volume_m3 = inra_dec[, crown_volume_m3]
)

n_chains = 4

if (!file.exists("fagSyl_trunk-crown.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fagSyl_trunk-crown"), random = FALSE)
	saveRDS(fit, "./fagSyl_trunk-crown.rds")
} else {
	fit = readRDS("./fagSyl_trunk-crown.rds")
}

if (!file.exists("fagSyl_trunk-crown_uncor.rds"))
{
	fit_uncor = uncor$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)

	# Save results
	fit_uncor$save_output_files(dir = "./", basename = paste0("fagSyl_trunk-crown_uncor"), random = FALSE)
	saveRDS(fit_uncor, "./fagSyl_trunk-crown_uncor.rds")
} else {
	fit_uncor = readRDS("./fagSyl_trunk-crown_uncor.rds")
}
```

```{r}
#### Check results
## Posteriors
lazyTrace(fit$draws("rho"))
lazyPosterior(fit$draws("rho"))

## Predictions
pred_total_volume = apply(X = fit$draws("pred_total_volume"), MARGIN = 3, FUN = mean)
pred_Vb_Cr = apply(X = fit$draws("pred_Vb_Cr_joined"), MARGIN = 3, FUN = mean)

pred_bole_volume = exp(pred_Vb_Cr[seq(1, length(pred_Vb_Cr) - 1, by = 2)])
pred_crown_volume = exp(pred_Vb_Cr[seq(2, length(pred_Vb_Cr), by = 2)])

## Predictions uncorrelated model
pred_bole_volume_uncor = apply(X = fit_uncor$draws("pred_bole_volume"), MARGIN = 3, FUN = mean)
pred_crown_volume_uncor = apply(X = fit_uncor$draws("pred_crown_volume"), MARGIN = 3, FUN = mean)
pred_total_volume_uncor = apply(X = fit_uncor$draws("pred_total_volume"), MARGIN = 3, FUN = mean)

## Bole volume
plot(pred_bole_volume, inra_dec[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred bole", ylab = "Obs bole", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Bole volume
plot(pred_crown_volume, inra_dec[, crown_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred crown", ylab = "Obs crown", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Total volume
plot(pred_total_volume, inra_dec[, total_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred tot.", ylab = "Obs tot", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

# fwrite(data.table(pred = pred_total_volume, obs = inra_dec[, total_volume_m3], class = inra_dec[, class]),
# 	"./pgfplots/pred_tot.csv")

########
## Bole volume
plot(pred_bole_volume_uncor, inra_dec[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred bole", ylab = "Obs bole", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Bole volume
plot(pred_crown_volume_uncor, inra_dec[, crown_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred crown", ylab = "Obs crown", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Total volume
plot(pred_total_volume_uncor, inra_dec[, total_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred tot.", ylab = "Obs tot", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)
########

## Fit on the log scale
# Extract parameters
alpha_0 = apply(X = fit$draws("alpha_0"), FUN = mean, MARGIN = 3)
beta_0 = apply(X = fit$draws("beta_0"), FUN = mean, MARGIN = 3)
alpha_1 = apply(X = fit$draws("alpha_1"), FUN = mean, MARGIN = 3)
beta_1 = apply(X = fit$draws("beta_1"), FUN = mean, MARGIN = 3)
alpha_2 = apply(X = fit$draws("alpha_2"), FUN = mean, MARGIN = 3)
beta_2 = apply(X = fit$draws("beta_2"), FUN = mean, MARGIN = 3)
beta_3 = apply(X = fit$draws("beta_3"), FUN = mean, MARGIN = 3)
beta_4 = apply(X = fit$draws("beta_4"), FUN = mean, MARGIN = 3)

plot(log(stanData$circumference_m), log(stanData$bole_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(bole)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(powReg(x, alpha_0, alpha_1, alpha_2, min(log(stanData$circumference_m))), add = TRUE,
	lwd = 2, col = "#CD212A")

plot(log(stanData$circumference_m), log(stanData$crown_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(crown)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(linReg(x, beta_0, beta_1, beta_2, beta_3, beta_4), add = TRUE, lwd = 2, col = "#CD212A")
```

Ok, beautiful, but how are the residuals?

```{r}
n_sampling = fit$metadata()$iter_sampling
# pred_Vb_Cr = fit$draws("pred_Vb_Cr_joined")
# pred_bole_volume = exp(pred_Vb_Cr[, , seq(1, 2*inra_dec[, .N] - 1, by = 2)])
# pred_crown_volume = exp(pred_Vb_Cr[, , seq(2, 2*inra_dec[, .N], by = 2)])

## Predictions
pred_total_volume = fit$draws("pred_total_volume")
pred_total_volume_uncor = fit_uncor$draws("pred_total_volume")

dharma_helper = function(simResp, obs, ncol = n_sampling*n_chains)
{
	n_chains = dim(simResp)[2] # Number of successful chains

	# Reshape simResp as a matrix nobs x n_repetition
	simResp_matrix = matrix(data = 0, nrow = length(obs), ncol = ncol)
	for (i in seq_along(obs))
		for (chain in 1:n_chains)
			simResp_matrix[i, ] = simResp[, chain, i] # One line of n_sampling*n_chains simulations per observation

	sim_dharma = createDHARMa(simulatedResponse = simResp_matrix,
		observedResponse = obs,
		fittedPredictedResponse = apply(simResp, MARGIN = 3, median),
		integerResponse = FALSE)
	
	return (sim_dharma)
}

#### Residuals correlated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume, obs = inra_dec[, total_volume_m3])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, inra_dec[, circumference_m], quantreg = TRUE)

## Export for pgfplots
dharmaQuant = DHARMa::testQuantiles(simulationOutput = sim_dharma,
	predictor = inra_dec[, rankTransform(circumference_m)], plot = FALSE)

# Add the rank transformed predictor and the prediction + height class for colour
pgfplots = data.table(circumference_rt = inra_dec[, rankTransform(circumference_m)],
	residuals = sim_dharma$scaledResiduals, class = inra_dec[, class])
setorder(pgfplots, circumference_rt)

# Add the quantile regression lines
pgfplots[, q25 := dharmaQuant$predictions[, 2]]
pgfplots[, q50 := dharmaQuant$predictions[, 4]]
pgfplots[, q75 := dharmaQuant$predictions[, 6]]

# Add the errors on the quantiles
pgfplots[, err25 := dharmaQuant$predictions[, 3]]
pgfplots[, err50 := dharmaQuant$predictions[, 5]]
pgfplots[, err75 := dharmaQuant$predictions[, 7]]

fwrite(pgfplots, "./pgfplots/residuals.csv")

# Test of my data table, should give the same as plotResiduals(sim_dharma, inra_dec[, circumference_m])
plot(inra_dec[, rankTransform(circumference_m)], sim_dharma$scaledResiduals, pch = 19, cex = 0.75)
quantiles = c(0.25, 0.5, 0.75)
abline(h = 0.5, col = "red", lwd = 0.5, lty = 2)
polygon(c(pgfplots[, circumference_rt], rev(pgfplots[, circumference_rt])),
	c(pgfplots[, q50] - pgfplots[, err50],
		rev(pgfplots[, q50] + pgfplots[, err50])),
	col = "#00000020", border = FALSE)
lines(pgfplots[, circumference_rt], pgfplots[, q50], col = "red", lwd = 2)

#### Residuals uncorrelated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume_uncor, obs = inra_dec[, total_volume_m3])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, inra_dec[, circumference_m], quantreg = TRUE)
```

## Simulate data
I use what the model found in the previous section in order to simulate data and then fit a correlated and non-correlated model.

```{r}
#### Create data following our stan model for real case scenario
## Get the parameters
varCov_mat = matrix(data = apply(X = fit$draws("Sigma"), MARGIN = 3, FUN = mean), ncol = 2, nrow = 2)

avg = function(x, params_b, params_c)
	return (c(powReg(x, p1 = params_b[1], p2 = params_b[2], p3 = params_b[3], shift = params_b[4]),
		linReg(x, p1 = params_c[1], p2 = params_c[2], p3 = params_c[3], p4 = params_c[4], p5 = params_c[5])))

params_b = c(apply(X = fit$draws(c("alpha_0", "alpha_1", "alpha_2")), MARGIN = 3, FUN = mean),
	shift = min(log(stanData$circumference_m)))

params_c = apply(X = fit$draws(c("beta_0", "beta_1", "beta_2", "beta_3", "beta_4")), MARGIN = 3, FUN = mean)

## Create data
data = data.table(circumference_m = stanData$circumference_m, v_bft = 0, v_crown = 0)

set.seed(1969 - 08 - 18) # Woodstock seed
for (i in seq_len(data[, .N]))
	data[i, c("v_bft", "v_crown") := as.list(exp(MASS::mvrnorm(1, avg(log(circumference_m), params_b, params_c),
		varCov_mat)))]

stanData$bole_volume_m3 = data[, v_bft]
stanData$crown_volume_m3 = data[, v_crown]
```

```{r}
#### Fit models accouting for vs neglecting correlation
## Fit both models
if (!file.exists("fake_trunk-crown.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fake_trunk-crown"), random = FALSE)
	saveRDS(fit, "./fake_trunk-crown.rds")
} else {
	fit = readRDS("./fake_trunk-crown.rds")
}

if (!file.exists("fake_trunk-crown_uncor.rds"))
{
	fit_uncor = uncor$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)

	# Save results
	fit_uncor$save_output_files(dir = "./", basename = paste0("fake_trunk-crown_uncor"), random = FALSE)
	saveRDS(fit_uncor, "./fake_trunk-crown_uncor.rds")
} else {
	fit_uncor = readRDS("./fake_trunk-crown_uncor.rds")
}
```

```{r}
#### Check the residuals
lazyTrace(fit$draws("rho"), val1 = varCov_mat[2, 1]/(sqrt(varCov_mat[1, 1]) * sqrt(varCov_mat[2, 2])))
lazyPosterior(fit$draws("rho"), val1 = varCov_mat[2, 1]/(sqrt(varCov_mat[1, 1]) * sqrt(varCov_mat[2, 2])))

n_sampling = fit$metadata()$iter_sampling

## Predictions
pred_total_volume = fit$draws("pred_total_volume")
pred_total_volume_uncor = fit_uncor$draws("pred_total_volume")

#### Residuals correlated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume, obs = data[, v_bft + v_crown])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, data[, circumference_m], quantreg = TRUE)

#### Residuals uncorrelated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume_uncor, obs = data[, v_bft + v_crown])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, data[, circumference_m], quantreg = TRUE)
```

## Model that uses both datasets to fit the bole parameters
In this section, I adapt the correlated model developped in @sec-mvn_trunk-crown to two datasets (Inra and NFI) for the bole volume.

```{r}
model = cmdstan_model("./trunk-crown_2data.stan")

stanData = list(
	N = inra_dec[, .N],
	N_nfi = nfi_sam[, .N],

	circumference_m = inra_dec[, circumference_m],
	circumference_m_nfi = nfi_sam[, circumference_m],

	bole_volume_m3 = inra_dec[, bole_volume_m3],
	bole_volume_m3_nfi = nfi_sam[, bole_volume_m3],
	crown_volume_m3 = inra_dec[, crown_volume_m3]
)

n_chains = 4

if (!file.exists("fagSyl_trunk-crown_2data.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fagSyl_trunk-crown_2data"), random = FALSE)
	saveRDS(fit, "./fagSyl_trunk-crown_2data.rds")
} else {
	fit = readRDS("./fagSyl_trunk-crown_2data.rds")
}
```

And now, some pred (on Inra data).
```{r}
#### Check results
## Posteriors
lazyTrace(fit$draws("rho"))
lazyPosterior(fit$draws("rho"))

## Predictions
pred_total_volume = apply(X = fit$draws("pred_total_volume"), MARGIN = 3, FUN = mean)
pred_Vb_Cr = apply(X = fit$draws("pred_Vb_Cr_joined"), MARGIN = 3, FUN = mean)

pred_bole_volume = exp(pred_Vb_Cr[seq(1, length(pred_Vb_Cr) - 1, by = 2)])
pred_crown_volume = exp(pred_Vb_Cr[seq(2, length(pred_Vb_Cr), by = 2)])

## Bole volume
plot(pred_bole_volume, inra_dec[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred bole", ylab = "Obs bole", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Bole volume
plot(pred_crown_volume, inra_dec[, crown_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred crown", ylab = "Obs crown", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Total volume
plot(pred_total_volume, inra_dec[, total_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred tot.", ylab = "Obs tot", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Fit on the log scale
# Extract parameters
alpha_0 = apply(X = fit$draws("alpha_0"), FUN = mean, MARGIN = 3)
beta_0 = apply(X = fit$draws("beta_0"), FUN = mean, MARGIN = 3)
alpha_1 = apply(X = fit$draws("alpha_1"), FUN = mean, MARGIN = 3)
beta_1 = apply(X = fit$draws("beta_1"), FUN = mean, MARGIN = 3)
alpha_2 = apply(X = fit$draws("alpha_2"), FUN = mean, MARGIN = 3)
beta_2 = apply(X = fit$draws("beta_2"), FUN = mean, MARGIN = 3)
beta_3 = apply(X = fit$draws("beta_3"), FUN = mean, MARGIN = 3)
beta_4 = apply(X = fit$draws("beta_4"), FUN = mean, MARGIN = 3)

plot(log(stanData$circumference_m), log(stanData$bole_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(bole)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(powReg(x, alpha_0, alpha_1, alpha_2, min(log(stanData$circumference_m))), add = TRUE,
	lwd = 2, col = "#CD212A")

plot(log(stanData$circumference_m), log(stanData$crown_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(crown)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(linReg(x, beta_0, beta_1, beta_2, beta_3, beta_4), add = TRUE, lwd = 2, col = "#CD212A")
```

I believe there is no need for the residuals... Now a small discussion!

::: {.callout-important}

## Should I have only one set of parameters

Obviously, having only one set of parameters is a failure! It is not surprising, the trees are too different between the datasets (not the same type of forest, not the same period, not the same measurements), and the parameters should reflect the observed trees.

Therefore, despite it is the same species, one set of parameters per species might not makes sense. Now, I cannot have two sets, as I will later apply the model to the tree NFI!

:::

