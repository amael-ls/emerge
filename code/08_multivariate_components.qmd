---
title: "Hierachical models"
date: today
author: AmaÃ«l Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
  warning: false
  message: false
bibliography: ./centralised_bibliography/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\Fcrn}{F_{\text{CRN}}}

\newcommand{\Vcrn}{V_{\text{crown}}}

\newcommand{\Vtot}{V_{\text{tot}}}

\newcommand{\hdec}{h_{\text{tap}}}
\newcommand{\htot}{h_{\text{tot}}}
\newcommand{\ddec}{\phi_{\text{tap}}}

\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\E}{\mathds{E}}

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
library(DHARMa)
library(interp)
library(gt)

## Tool function
source("./toolFunctions.R")

linReg = function(x, p1, p2, p3, p4, p5)
	return(p1 + p2*x + p3*x^2 + p4*x^3 + p5*x^4)

powReg = function(x, p1, p2, p3, shift)
	return(p1 + p2*(x - shift)^p3)

florence_bft = function(c, h, hdec, params, bounds)
{
	fnew = params[1, alpha] + params[1, beta]*c + params[1, gamma]*sqrt(c)/hdec +
		params[1, delta]*sqrt(hdec)/(c^2*h) + params[1, eta]*(1 - hdec/h)

	fnew = max(fnew, bounds[1, bft_min])
	fnew = min(fnew, bounds[1, bft_max])

	# Remember that fnew_old is bounded by f_lim, and new = (1 - 1.3/h)^2 old
	return(c^2*h/(4*pi) * min(fnew/(1 - 1.3/h)^2, bounds[1, bft_lim]))
}

getVol = function(nfi_sp, k, fit)
{
	str = paste0("pred_formFactor[", k, "]")
	convert = nfi_sp[k, circumference_m^2]*nfi_sp[k, height]/(4*pi*(1 - 1.3/nfi_sp[k, height])^2)
	return (fit$draws(str)*convert)
}
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"
# opt = "_inra"

## Loading
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))

## Subset data
inra = forest_dt[origin_data == "inra"] 
nfi = forest_dt[origin_data == "nfi"]
nfi = nfi[, n_indiv := .N, by = speciesName_sci]
nfi = nfi[n_indiv > 10000]

setkey(inra, speciesName_sci)
setkey(nfi, speciesName_sci)

rm(forest_dt)

## Load profiles
profiles = readRDS(paste0(mnt_point, "data/profiles_oudin.rds"))
```

Estimation of $\hdec$ from the profiles.
```{r}
## Rk: A decrease of 10% of circumference (i.e., C_{n + 1} = 0.9 C_n) implies 19% in volume (0.9^2 = 0.81)
profiles[, decrease_10pct := {prev = data.table::shift(log_volume_m3, type = "lag")
	(log_volume_m3 / prev) <= 0.81}, by = unique_id]

## Rk It is almost sure that the circumference decreases by 10% between 0.5 and 1.5 m height, because of
#		butt swell (empattement). Moreover, measures starts from 1.3 m at the french NFI
profiles = profiles[at_height > 1.5]

# For each unique_id, keep only the first TRUE as TRUE, which will indicate taper height (hdec)
profiles[, first_true := FALSE]

profiles[decrease_10pct == TRUE, 
	first_true := .I == .I[1],  # mark only the first TRUE row within each group
	by = unique_id]

# plot(profiles[1:16, at_height], profiles[1:16, log_volume_m3], pch = 19, cex = 0.75, col = "#CD212A")

profiles = profiles[(first_true), .(unique_id, hdec = at_height + 0.5)] # +0.5 because measured every metre
```

Add estimated taper height to `inra`
```{r}
inra[unique_id %in% profiles$unique_id]

inra = merge.data.table(inra, profiles, by = "unique_id", all.x = TRUE)
inra[!is.na(hdec), .N, by = speciesName_sci]
setkey(inra, speciesName_sci)
```

## Intro

The ratio model is dangerous! Check how steep is the curve for small value of $\Vbft$... That means a hypersensitive model for small trees!

Therefore, I need to change the paradigm! In the @sec-univariate_BFT I recreate the model of Florence to estimate $\Vbft$ from three variables: $c$, $h$, and, $\hdec'$ (which is either $\hdec$ or $\htot$).

## Apply the model of Florence to Emerge data

In this section, I apply the model of FLorence to the Emerge data. The parameters' value can be found in `rapport_tarifs.pdf`, p. 33 (annexe 2).

```{r}
#### Coeff data table
coeffs_3 = data.table(
	speciesName_sci = c("Quercus robur", "Quercus petraea", "Fagus sylvatica", "Pinus pinaster",
		"Pinus sylvestris", "Abies alba", "Picea abies"),
	tarif = c("02", "03", "09", "51", "52", "61", "62"),
	alpha = c(0.4139968, 0.4439589, 0.3962135, 0.3625385, 0.3826291, 0.4333959, 0.4468885),
	beta = c(-0.0069499, -0.0203087, 0.0004032, 0.0172278, 0.0057494, 0.0043911, -0.0315384),
	gamma = c(-0.3001131, -0.2944278, -0.2723268, -0.1878927, -0.2250570, -0.2955610, -0.3736340),
	delta = c(-0.0348160, -0.0390426, -0.0353373, -0.0238314, -0.0247413, -0.0305603, -0.0321009),
	eta = c(-0.0075658, -0.0140190, -0.0166928, -0.0183863, -0.0026865, -0.0089731, 0.0188160),
	bft_min = c(0.15, 0.15, 0.13, 0.17, 0.17, 0.17, 0.20),
	bft_max = c(0.44, 0.43, 0.43, 0.40, 0.42, 0.48, 0.43),
	bft_lim = c(0.8, 0.8, 0.9, 0.9, 1.0, 0.9, 0.9),
	key = "speciesName_sci"
)
```

```{r}
#### Check estimated hdec of Emerge vs measured hdec from nfi for Fagus sylvatica
inra_dec = inra["Fagus sylvatica"][!is.na(hdec) & !(presence_NA)]

plot(nfi["Fagus sylvatica", circumference_m], nfi["Fagus sylvatica", taper_height], pch = 19,
	cex = 0.75, xlab = "Circumference", ylab = "Taper height", axes = FALSE, col = "#0F7BA2")
points(inra_dec[, circumference_m], inra_dec[, hdec], col = "#FAB255", pch = 19, cex = 0.75)
axis(1)
axis(2, las = 1)

#### Compute the taper volume for 7 species
inra_dec[, bole_volume_m3_gohon := florence_bft(circumference_m, height, hdec,
		params = coeffs_3["Fagus sylvatica", .(alpha, beta, gamma, delta, eta)],
		bounds = coeffs_3["Fagus sylvatica", .(bft_min, bft_max, bft_lim)])]

plot(inra_dec[, bole_volume_m3_gohon], inra_dec[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")

inra_dec[, bole_volume_m3_gohon := NULL]
```

### Fit model Florence{#sec-univariate_BFT}

The model is described by @eq-flo_univariate:
$$
	\Fbft = \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec'} + \delta_i \frac{\sqrt{\hdec'}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec'}{h} \right)
$${#eq-flo_univariate}

For the code and equation, see `rapport_tarifs.Rmd`, line 638. I now fit a Bayesian version of Florence's model for *Fagus sylvatica*.

```{r}
model = cmdstan_model("./florence_univariate.stan")

stanData = list(
	N = nfi["Fagus sylvatica", .N],

	circumference_m = nfi["Fagus sylvatica", circumference_m],
	height = nfi["Fagus sylvatica", height],
	hdec = nfi["Fagus sylvatica", taper_height],

	bole_volume_m3 = nfi["Fagus sylvatica", bole_volume_m3]
)

n_chains = 4

if (!file.exists("florence-fagSyl.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)
	fit$save_output_files(dir = "./", basename = paste0("florence-fagSyl"), random = FALSE)
	saveRDS(fit, "florence-fagSyl.rds")
} else {
	fit = readRDS("./florence-fagSyl.rds")
}

fagSyl = rbindlist(list(florence = coeffs_3["Fagus sylvatica", .(alpha, beta, gamma, delta, eta)],
	amael = data.table(
		alpha = mean(fit$draws("alpha")),
		beta = mean(fit$draws("beta_")),
		gamma = mean(fit$draws("gamma")),
		delta = mean(fit$draws("delta")),
		eta = mean(fit$draws("eta")))
), idcol = "model")

#### Pred on Inra data
genQ = cmdstan_model("./florence_univariate_genQ.stan")
stanData_gen = list(
	N = inra_dec["Fagus sylvatica", .N],

	circumference_m = inra_dec["Fagus sylvatica", circumference_m],
	height = inra_dec["Fagus sylvatica", height],
	hdec = inra_dec["Fagus sylvatica", hdec],

	bole_volume_m3 = inra_dec["Fagus sylvatica", bole_volume_m3]
)

sim = genQ$generate_quantities(fit, data = stanData_gen, seed = 123, parallel_chains = min(n_chains, 4))

mean_pred = apply(X = sim$draws("pred_bole"), MARGIN = 3, FUN = mean)
plot(mean_pred, inra_dec["Fagus sylvatica", bole_volume_m3], pch = 19, cex = 0.3,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
```

### Try with heteroskedasticity

Based on the previous section, I add heteroskedasticity by modelling the variance with a power-law:
$$
	\sigma = a (c^2 h)^b,
$$
where $a > 0$ and $b$ are two parameters to estimate. I fit the model on 6000 individuals only, in order to go faster.

```{r}
model = cmdstan_model("./florence_univariate_heterosked.stan")

sam = sample(seq_len(nfi["Fagus sylvatica", .N]), size = 6e3, replace = FALSE)
nfi_sam = nfi["Fagus sylvatica"][sam]

stanData = list(
	N = 6e3, # nfi["Fagus sylvatica", .N],

	circumference_m = nfi_sam[, circumference_m],
	height = nfi_sam[, height],
	hdec = nfi_sam[, taper_height],

	bole_volume_m3 = nfi_sam[, bole_volume_m3]
)

n_chains = 4

if (!file.exists("florence-fagSyl_heterosked.rds"))
{
	fit_heterosked = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)
	fit_heterosked$save_output_files(dir = "./", basename = paste0("florence-fagSyl_heterosked"), random = FALSE)
	saveRDS(fit_heterosked, "florence-fagSyl_heterosked.rds")
} else {
	fit_heterosked = readRDS("florence-fagSyl_heterosked.rds")
}

fagSyl = rbindlist(list(fagSyl,
	data.table(
		model = "heterosked",
		alpha = mean(fit_heterosked$draws("alpha")),
		beta = mean(fit_heterosked$draws("beta_")),
		gamma = mean(fit_heterosked$draws("gamma")),
		delta = mean(fit_heterosked$draws("delta")),
		eta = mean(fit_heterosked$draws("eta")))
))
```

As shown in the following table, the results between Florence and I are quite different, despite being the same model. The training dataset might not be exactly the same, but I guess the major difference comes from the Bayesian framework. Adding heterosked did not change that much the values.

```{r}
fagSyl |>
	gt() |>
	cols_label(
		model = "Model",
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = model)
	) |>
	fmt_number(
		columns = ends_with("a"),
		decimals = 4
	)
```

```{r}
a = mean(fit_heterosked$draws("a"))
b = mean(fit_heterosked$draws("b"))

sigma_fct = function(x, a, b)
	return (a*x^b)

range(stanData$circumference_m^2*stanData$height)
curve(sigma_fct(x, a, b), to = 700)

genQ = cmdstan_model("./florence_univariate_heterosked_genQ.stan")
sim = genQ$generate_quantities(fit_heterosked, data = stanData_gen, seed = 123, parallel_chains = min(n_chains, 4))

mean_pred = apply(X = sim$draws("pred_bole"), MARGIN = 3, FUN = mean)
plot(mean_pred, inra_dec["Fagus sylvatica", bole_volume_m3], pch = 19, cex = 0.3,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
```

## Explore the crown

In this section, I look at the relation there can be between the crown and tree dimensions (circumference, height, and taper height).

```{r}
lim = quantile(inra_dec[, hdec], c(0.25, 0.5, 0.75))
inra_dec[, colour := met.brewer("Egypt")[1]]
inra_dec[(lim["25%"] < hdec) & (hdec <= lim["50%"]), colour := met.brewer("Egypt")[2]]
inra_dec[(lim["50%"] < hdec) & (hdec <= lim["75%"]), colour := met.brewer("Egypt")[3]]
inra_dec[lim["75%"] < hdec, colour := met.brewer("Egypt")[4]]

plot(inra_dec[, log(circumference_m)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.65, xlab = "Circumference", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height - hdec)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
```

Not that convincing... Let us try to use a form factor similar to the one used for bole volume:
$$
	\Fcrn = \frac{4\pi \Vcrn}{c^2 h} \left( 1 - \frac{1.3}{h} \right)^2
$$

```{r}
inra_dec[, Fcrn := 4*pi*crown_volume_m3/(circumference_m^2*height)*(1 - 1.3/height)^2]
inra_dec[, Fcrn_sphere := 6*pi^2*crown_volume_m3/circumference_m^3]

plot(inra_dec[, log(circumference_m)], inra_dec[, log(Fcrn)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Circumference", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(Fcrn)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height) - hdec], inra_dec[, Fcrn], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(circumference_m)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Circumference", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height - hdec)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
```

## Simple test of crown model

I will try a crown model with a hierarchy at the taper height level (try also with height and more values!). This model will use $\log(c)$ to predict $\log(\Vcrn)$.

```{r}
#### Prepare the data
## Compute the indices
# Reorder data
setorder(inra_dec, hdec)

# Indices
indices = inra_dec[, .(start = .I[1], end = .I[.N]), by = .(colour)]
indices[, class := c("small", "med", "tall", "very tall")]
```

And now, the test of the crown model...
```{r}
model = cmdstan_model("./crown.stan")

stanData = list(
	N = inra_dec[, .N],
	N_group = indices[, .N],
	start_ind = indices[, start],
	end_ind = indices[, end],
	circumference_m = inra_dec[, circumference_m],
	crown_volume_m3 = inra_dec[, crown_volume_m3]
)

n_chains = 4

if (!file.exists("crown.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)
	fit$save_output_files(dir = "./", basename = paste0("crown"), random = FALSE)
	saveRDS(fit, "crown.rds")
} else {
	fit = readRDS("crown.rds")
}
```

And here are few posterior stuff

```{r}
pred = apply(X = fit$draws("pred_crown"), FUN = mean, MARGIN = 3)
apply(X = fit$draws("sigmas"), FUN = mean, MARGIN = 3)

plot(pred, inra_dec[, crown_volume_m3], pch = 19, cex = 0.35, col = inra_dec[, colour],
	xlab = "Pred", ylab = "Obs", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")

n_sampling = fit$metadata()$iter_sampling

simResp = fit$draws("pred_crown")
dim(simResp)
n_chains = dim(simResp)[2] # Number of successful chains

# Reshape simResp as a matrix nobs x n_repetition
simResp_matrix = matrix(data = 0, nrow = inra_dec[, .N], ncol = n_sampling*n_chains)
for (obs in seq_len(inra_dec[, .N]))
	for (chain in 1:n_chains)
		simResp_matrix[obs, ] = simResp[, chain, obs] # One line of n_sampling*n_chains simulations per observation

sim_dharma = createDHARMa(simulatedResponse = simResp_matrix,
	observedResponse = inra_dec[, crown_volume_m3],
	fittedPredictedResponse = apply(simResp, MARGIN = 3, median),
	integerResponse = FALSE)

plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, inra_dec[, circumference_m], quantreg = TRUE)
```

## Simple test of trunk-crown model
```{r}
## Compile correlated and uncorrelated models
model = cmdstan_model("./trunk-crown.stan")
uncor = cmdstan_model("./crown-trunk_uncor.stan")

stanData = list(
	N = inra_dec[, .N],

	circumference_m = inra_dec[, circumference_m],

	bole_volume_m3 = inra_dec[, bole_volume_m3],
	crown_volume_m3 = inra_dec[, crown_volume_m3]
)

n_chains = 4

if (!file.exists("fagSyl_trunk-crown.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fagSyl_trunk-crown"), random = FALSE)
	saveRDS(fit, "./fagSyl_trunk-crown.rds")
} else {
	fit = readRDS("./fagSyl_trunk-crown.rds")
}

if (!file.exists("fagSyl_trunk-crown_uncor.rds"))
{
	fit_uncor = uncor$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)

	# Save results
	fit_uncor$save_output_files(dir = "./", basename = paste0("fagSyl_trunk-crown_uncor"), random = FALSE)
	saveRDS(fit_uncor, "./fagSyl_trunk-crown_uncor.rds")
} else {
	fit_uncor = readRDS("./fagSyl_trunk-crown_uncor.rds")
}
```

```{r}
#### Check results
## Posteriors
lazyTrace(fit$draws("rho"))
lazyPosterior(fit$draws("rho"))

## Predictions
pred_total_volume = apply(X = fit$draws("pred_total_volume"), MARGIN = 3, FUN = mean)
pred_Vb_Cr = apply(X = fit$draws("pred_Vb_Cr_joined"), MARGIN = 3, FUN = mean)

pred_bole_volume = exp(pred_Vb_Cr[seq(1, length(pred_Vb_Cr) - 1, by = 2)])
pred_crown_volume = exp(pred_Vb_Cr[seq(2, length(pred_Vb_Cr), by = 2)])

## Predictions uncorrelated model
pred_bole_volume_uncor = apply(X = fit_uncor$draws("pred_bole_volume"), MARGIN = 3, FUN = mean)
pred_crown_volume_uncor = apply(X = fit_uncor$draws("pred_crown_volume"), MARGIN = 3, FUN = mean)
pred_total_volume_uncor = apply(X = fit_uncor$draws("pred_total_volume"), MARGIN = 3, FUN = mean)

## Bole volume
plot(pred_bole_volume, inra_dec[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred bole", ylab = "Obs bole", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Bole volume
plot(pred_crown_volume, inra_dec[, crown_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred crown", ylab = "Obs crown", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Total volume
plot(pred_total_volume, inra_dec[, total_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred tot.", ylab = "Obs tot", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

########
## Bole volume
plot(pred_bole_volume_uncor, inra_dec[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred bole", ylab = "Obs bole", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Bole volume
plot(pred_crown_volume_uncor, inra_dec[, crown_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred crown", ylab = "Obs crown", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Total volume
plot(pred_total_volume_uncor, inra_dec[, total_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred tot.", ylab = "Obs tot", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)
########

## Fit on the log scale
# Extract parameters
alpha_0 = apply(X = fit$draws("alpha_0"), FUN = mean, MARGIN = 3)
beta_0 = apply(X = fit$draws("beta_0"), FUN = mean, MARGIN = 3)
alpha_1 = apply(X = fit$draws("alpha_1"), FUN = mean, MARGIN = 3)
beta_1 = apply(X = fit$draws("beta_1"), FUN = mean, MARGIN = 3)
alpha_2 = apply(X = fit$draws("alpha_2"), FUN = mean, MARGIN = 3)
beta_2 = apply(X = fit$draws("beta_2"), FUN = mean, MARGIN = 3)
beta_3 = apply(X = fit$draws("beta_3"), FUN = mean, MARGIN = 3)
beta_4 = apply(X = fit$draws("beta_4"), FUN = mean, MARGIN = 3)

plot(log(stanData$circumference_m), log(stanData$bole_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(bole)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(powReg(x, alpha_0, alpha_1, alpha_2, min(log(stanData$circumference_m))), add = TRUE,
	lwd = 2, col = "#CD212A")

plot(log(stanData$circumference_m), log(stanData$crown_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(crown)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(linReg(x, beta_0, beta_1, beta_2, beta_3, beta_4), add = TRUE, lwd = 2, col = "#CD212A")
```

Ok, beautiful, but what are the residuals?

```{r}
n_sampling = fit$metadata()$iter_sampling
# pred_Vb_Cr = fit$draws("pred_Vb_Cr_joined")
# pred_bole_volume = exp(pred_Vb_Cr[, , seq(1, 2*inra_dec[, .N] - 1, by = 2)])
# pred_crown_volume = exp(pred_Vb_Cr[, , seq(2, 2*inra_dec[, .N], by = 2)])

## Predictions
pred_total_volume = fit$draws("pred_total_volume")
pred_total_volume_uncor = fit_uncor$draws("pred_total_volume")

dharma_helper = function(simResp, obs, ncol = n_sampling*n_chains)
{
	n_chains = dim(simResp)[2] # Number of successful chains

	# Reshape simResp as a matrix nobs x n_repetition
	simResp_matrix = matrix(data = 0, nrow = length(obs), ncol = ncol)
	for (i in seq_along(obs))
		for (chain in 1:n_chains)
			simResp_matrix[i, ] = simResp[, chain, i] # One line of n_sampling*n_chains simulations per observation

	sim_dharma = createDHARMa(simulatedResponse = simResp_matrix,
		observedResponse = obs,
		fittedPredictedResponse = apply(simResp, MARGIN = 3, median),
		integerResponse = FALSE)
	
	return (sim_dharma)
}

#### Residuals correlated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume, obs = inra_dec[, total_volume_m3])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, inra_dec[, circumference_m], quantreg = TRUE)

#### Residuals uncorrelated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume_uncor, obs = inra_dec[, total_volume_m3])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, inra_dec[, circumference_m], quantreg = TRUE)
```

## Simulate data
I use what the model found in the previous section in order to simulate data and then fit a correlated and non-correlated model.

```{r}
#### Create data following our stan model for real case scenario
## Get the parameters
varCov_mat = matrix(data = apply(X = fit$draws("Sigma"), MARGIN = 3, FUN = mean), ncol = 2, nrow = 2)

avg = function(x, params_b, params_c)
	return (c(powReg(x, p1 = params_b[1], p2 = params_b[2], p3 = params_b[3], shift = params_b[4]),
		linReg(x, p1 = params_c[1], p2 = params_c[2], p3 = params_c[3], p4 = params_c[4], p5 = params_c[5])))

params_b = c(apply(X = fit$draws(c("alpha_0", "alpha_1", "alpha_2")), MARGIN = 3, FUN = mean),
	shift = min(log(stanData$circumference_m)))

params_c = apply(X = fit$draws(c("beta_0", "beta_1", "beta_2", "beta_3", "beta_4")), MARGIN = 3, FUN = mean)

## Create data
data = data.table(circumference_m = stanData$circumference_m, v_bft = 0, v_crown = 0)

set.seed(1969 - 08 - 18) # Woodstock seed
for (i in seq_len(data[, .N]))
	data[i, c("v_bft", "v_crown") := as.list(exp(MASS::mvrnorm(1, avg(log(circumference_m), params_b, params_c),
		varCov_mat)))]

stanData$bole_volume_m3 = data[, v_bft]
stanData$crown_volume_m3 = data[, v_crown]
```

```{r}
#### Fit models accouting for vs neglecting correlation
## Fit both models
if (!file.exists("fake_trunk-crown.rds"))
{
	fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

	# Save results
	fit$save_output_files(dir = "./", basename = paste0("fake_trunk-crown"), random = FALSE)
	saveRDS(fit, "./fake_trunk-crown.rds")
} else {
	fit = readRDS("./fake_trunk-crown.rds")
}

if (!file.exists("fake_trunk-crown_uncor.rds"))
{
	fit_uncor = uncor$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
		max_treedepth = 12)

	# Save results
	fit_uncor$save_output_files(dir = "./", basename = paste0("fake_trunk-crown_uncor"), random = FALSE)
	saveRDS(fit_uncor, "./fake_trunk-crown_uncor.rds")
} else {
	fit_uncor = readRDS("./fake_trunk-crown_uncor.rds")
}
```

```{r}
#### Check the residuals
lazyTrace(fit$draws("rho"), val1 = varCov_mat[2, 1]/(sqrt(varCov_mat[1, 1]) * sqrt(varCov_mat[2, 2])))
lazyPosterior(fit$draws("rho"), val1 = varCov_mat[2, 1]/(sqrt(varCov_mat[1, 1]) * sqrt(varCov_mat[2, 2])))

n_sampling = fit$metadata()$iter_sampling

## Predictions
pred_total_volume = fit$draws("pred_total_volume")
pred_total_volume_uncor = fit_uncor$draws("pred_total_volume")

#### Residuals correlated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume, obs = data[, v_bft + v_crown])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, data[, circumference_m], quantreg = TRUE)

#### Residuals uncorrelated model
## Total volume
sim_dharma = dharma_helper(simResp = pred_total_volume_uncor, obs = data[, v_bft + v_crown])
plot(sim_dharma, quantreg = TRUE)
plotResiduals(sim_dharma, data[, circumference_m], quantreg = TRUE)
```

## Model that uses both datasets to fit the bole parameters

