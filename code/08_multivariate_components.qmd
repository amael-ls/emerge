---
title: "Hierachical models"
date: today
author: AmaÃ«l Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
  warning: false
  message: false
bibliography: ./centralised_bibliography/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}

\newcommand{\Vcro}{V_{\text{crown}}}

\newcommand{\Vtot}{V_{\text{tot}}}

\newcommand{\hdec}{h_{\text{tap}}}
\newcommand{\htot}{h_{\text{tot}}}
\newcommand{\ddec}{\phi_{\text{tap}}}

\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\E}{\mathds{E}}

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
library(DHARMa)
library(interp)
library(gt)

## Tool function
source("./toolFunctions.R")

linReg = function(x, p1, p2, p3, p4, p5)
	return(p1 + p2*x + p3*x^2 + p4*x^3 + p5*x^4)

powReg = function(x, p1, p2, p3, shift)
	return(p1 + p2*(x - shift)^p3)
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

# opt = "_full"
opt = "_inra"

## Loading
stanData = readRDS(paste0(path_data, "stanData_nfi-inra", opt, ".rds"))
# forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))
inra = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))

## Subset data
# nfi = forest_dt["nfi"]
# nfi = nfi[, n_indiv := .N, by = speciesName_sci]
# nfi = nfi[n_indiv > 5000]

setkey(inra, speciesName_sci)
```

## Intro

The ratio model is dangerous! Check how steep is the curve for small value of $\Vbft$... That means a hypersensitive model for small trees!

Therefore, I need to change the paradigm! In the @sec-univariate_BFT I recreate the model of Florence to estimate $\Vbft$ from three variables: $c$, $h$, and, $\hdec'$ (which is either $\hdec$ or $\htot$).

## Fit model Florence{#sec-univariate_BFT}

The model is described by @eq-flo_univariate:
$$
	\Fbft = \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec'} + \delta_i \frac{\sqrt{\hdec'}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec'}{h} \right)
$${#eq-flo_univariate}

For the code and equation, see `rapport_tarifs.Rmd`, line 638.

```{r}
# model = cmdstan_model("./florence_univariate.stan")

# stanData = list(
# 	N = nfi["Fagus sylvatica", .N],

# 	circumference_m = nfi["Fagus sylvatica", circumference_m],
# 	height = nfi["Fagus sylvatica", height],
# 	hdec = nfi["Fagus sylvatica", taper_height],

# 	bole_volume_m3 = nfi["Fagus sylvatica", bole_volume_m3]
# )

# fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)
```


## Simple test of trunk-crown model
```{r}
model = cmdstan_model("./trunk-crown.stan")

stanData = list(
	N = inra["Fagus sylvatica", .N],

	circumference_m = inra["Fagus sylvatica", circumference_m],

	bole_volume_m3 = inra["Fagus sylvatica", bole_volume_m3],
	crown_volume_m3 = inra["Fagus sylvatica", crown_volume_m3]
)

n_chains = 4

fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)
```

```{r}
#### Check results
## Posteriors
lazyTrace(fit$draws("rho"))
lazyPosterior(fit$draws("rho"))

## Predictions
pred_total_volume = apply(X = fit$draws("pred_total_volume"), MARGIN = 3, FUN = mean)
pred_Vb_Cr = apply(X = fit$draws("pred_Vb_Cr_joined"), MARGIN = 3, FUN = mean)

pred_bole_volume = exp(pred_Vb_Cr[seq(1, length(pred_Vb_Cr) - 1, by = 2)])
pred_crown_volume = exp(pred_Vb_Cr[seq(2, length(pred_Vb_Cr), by = 2)])

## Bole volume
plot(pred_bole_volume, inra["Fagus sylvatica", bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred bole", ylab = "Obs bole", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Bole volume
plot(pred_crown_volume, inra["Fagus sylvatica", crown_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred crown", ylab = "Obs crown", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Total volume
plot(pred_total_volume, inra["Fagus sylvatica", total_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred tot.", ylab = "Obs tot", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, col = "#CD212A", lwd = 2)

## Fit on the log scale
# Extract parameters
alpha_0 = apply(X = fit$draws("alpha_0"), FUN = mean, MARGIN = 3)
beta_0 = apply(X = fit$draws("beta_0"), FUN = mean, MARGIN = 3)
alpha_1 = apply(X = fit$draws("alpha_1"), FUN = mean, MARGIN = 3)
beta_1 = apply(X = fit$draws("beta_1"), FUN = mean, MARGIN = 3)
alpha_2 = apply(X = fit$draws("alpha_2"), FUN = mean, MARGIN = 3)
beta_2 = apply(X = fit$draws("beta_2"), FUN = mean, MARGIN = 3)
beta_3 = apply(X = fit$draws("beta_3"), FUN = mean, MARGIN = 3)
beta_4 = apply(X = fit$draws("beta_4"), FUN = mean, MARGIN = 3)

plot(log(stanData$circumference_m), log(stanData$bole_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(bole)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(powReg(x, alpha_0, alpha_1, alpha_2, min(log(stanData$circumference_m))), add = TRUE,
	lwd = 2, col = "#FAB255")

plot(log(stanData$circumference_m), log(stanData$crown_volume_m3), pch = 19, cex = 0.75,
	xlab = "log(circum)", ylab = "log(crown)", axes = FALSE)
axis(1)
axis(2, las = 1)
curve(linReg(x, beta_0, beta_1, beta_2, beta_3, beta_4), add = TRUE, lwd = 2, col = "#FAB255")

```