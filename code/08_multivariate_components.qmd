---
title: "Hierachical models"
date: today
author: AmaÃ«l Le Squin
date-format: iso
filters:
  - fontawesome
  - siunitx-quarto
  - imagify
imagify:
  header-includes: |
    \usepackage{pgfplots}
    \pgfplotsset{compat=1.18}
    \usepgfplotslibrary{fillbetween}
    \usetikzlibrary{positioning}
    \usetikzlibrary{calc}
  pdf-engine: lualatex
pdf-engine: lualatex
keep-tex: true
execute:
  error: true
  echo: false
  warning: false
  message: false
bibliography: ./centralised_bibliography/references.bib
lightbox:
  match: auto
css: style.css
knitr:
  opts_chunk: 
    dev: ragg_png
    crop: null
    out.width: "70%"
    fig.width: 6
    fig.asp: 0.618
    fig.align: "center"
format:
  html:
    toc: true
    include-in-header: mathjax.html
    code-fold: true
    df-print: paged
    number-sections: true
    theme:
      light: cerulean
      dark: darkly
    margin: 5% 0;
  pdf:
    mathspec: true
    include-in-header:
      - text: |
          \usepackage{unicode-math}
---

<!-- New command -->
\newcommand{\ie}{*i.e.,*}

<!-- Math commands -->
\newcommand{\Vbft}{V_{\text{BFT}}}
\newcommand{\Fbft}{F_{\text{BFT}}}
\newcommand{\Fcrn}{F_{\text{CRN}}}

\newcommand{\Vcrn}{V_{\text{crown}}}

\newcommand{\Vtot}{V_{\text{tot}}}

\newcommand{\hdec}{h_{\text{tap}}}
\newcommand{\htot}{h_{\text{tot}}}
\newcommand{\ddec}{\phi_{\text{tap}}}

\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\E}{\mathds{E}}

```{r}
#| output: false

#### Clear space and load packages
# rm(list = ls())
graphics.off()

options(max.print = 500)

library(data.table)
library(MetBrewer)
library(cmdstanr)
	register_knitr_engine(override = TRUE)
library(stringi)
library(DHARMa)
library(interp)
library(gt)

## Tool function
source("./toolFunctions.R")

linReg = function(x, p1, p2, p3, p4, p5)
	return(p1 + p2*x + p3*x^2 + p4*x^3 + p5*x^4)

powReg = function(x, p1, p2, p3, shift)
	return(p1 + p2*(x - shift)^p3)

florence_bft = function(c, h, hdec, params, bounds)
{
	fnew = params[1, alpha] + params[1, beta]*c + params[1, gamma]*sqrt(c)/hdec +
		params[1, delta]*sqrt(hdec)/(c^2*h) + params[1, eta]*(1 - hdec/h)

	fnew = max(fnew, bounds[1, bft_min])
	fnew = min(fnew, bounds[1, bft_max])

	# Remember that fnew_old is bounded by f_lim, and new = (1 - 1.3/h)^2 old
	return(c^2*h/(4*pi) * min(fnew/(1 - 1.3/h)^2, bounds[1, bft_lim]))
}

getVol = function(nfi_sp, k, fit)
{
	str = paste0("pred_formFactor[", k, "]")
	convert = nfi_sp[k, circumference_m^2]*nfi_sp[k, height]/(4*pi*(1 - 1.3/nfi_sp[k, height])^2)
	return (fit$draws(str)*convert)
}
```

```{r}
#| output: false

#### Load the data
## Path
os = Sys.info()[['sysname']]
mnt_point = "/mnt/local_share/"
if (os == "Linux" || os == "Darwin")
{
	if (!dir.exists(mnt_point))
		stop(paste0("The mounting point <", mnt_point, "> does not exist"))
} else if (os == "Windows") {
	stop("TO DO!!! No idea how that works on Windows!")
} else {
	stop(paste("Unknown Operating System:", os))
}

path_data = paste0(mnt_point, "/data/")
if (!dir.exists(path_data))
	stop(paste0("Folder <", path_data, "> does not exist! Did you run 01_prepare_data.qmd?"))

opt = "_full"
# opt = "_inra"

## Loading
forest_dt = readRDS(paste0(path_data, "nfi-inra_dt", opt, ".rds"))

## Subset data
inra = forest_dt[origin_data == "inra"] 
nfi = forest_dt[origin_data == "nfi"]
nfi = nfi[, n_indiv := .N, by = speciesName_sci]
nfi = nfi[n_indiv > 10000]

setkey(inra, speciesName_sci)
setkey(nfi, speciesName_sci)

rm(forest_dt)

## Load profiles
profiles = readRDS(paste0(mnt_point, "data/profiles_oudin.rds"))
```

Estimation of $\hdec$ from the profiles.
```{r}
## Rk: A decrease of 10% of circumference (i.e., C_{n + 1} = 0.9 C_n) implies 19% in volume (0.9^2 = 0.81)
profiles[, decrease_10pct := {prev = data.table::shift(log_volume_m3, type = "lag")
	(log_volume_m3 / prev) <= 0.81}, by = unique_id]

## Rk It is almost sure that the circumference decreases by 10% between 0.5 and 1.5 m height, because of
#		butt swell (empattement). Moreover, measures starts from 1.3 m at the french NFI
profiles = profiles[at_height > 1.5]

# For each unique_id, keep only the first TRUE as TRUE, which will indicate taper height (hdec)
profiles[, first_true := FALSE]

profiles[decrease_10pct == TRUE, 
	first_true := .I == .I[1],  # mark only the first TRUE row within each group
	by = unique_id]

# plot(profiles[1:16, at_height], profiles[1:16, log_volume_m3], pch = 19, cex = 0.75, col = "#CD212A")

profiles = profiles[(first_true), .(unique_id, hdec = at_height + 0.5)] # +0.5 because measured every metre
```

Add estimated taper height to `inra`
```{r}
inra[unique_id %in% profiles$unique_id]

inra = merge.data.table(inra, profiles, by = "unique_id", all.x = TRUE)
inra[!is.na(hdec), .N, by = speciesName_sci]
setkey(inra, speciesName_sci)
```

## Intro

The ratio model is dangerous! Check how steep is the curve for small value of $\Vbft$... That means a hypersensitive model for small trees!

Therefore, I need to change the paradigm! In the @sec-univariate_BFT I recreate the model of Florence to estimate $\Vbft$ from three variables: $c$, $h$, and, $\hdec'$ (which is either $\hdec$ or $\htot$).

## Apply the model of Florence to Emerge data

In this section, I apply the model of FLorence to the Emerge data. The parameters' value can be found in `rapport_tarifs.pdf`, p. 33 (annexe 2).

```{r}
#### Coeff data table
coeffs_3 = data.table(
	speciesName_sci = c("Quercus robur", "Quercus petraea", "Fagus sylvatica", "Pinus pinaster",
		"Pinus sylvestris", "Abies alba", "Picea abies"),
	tarif = c("02", "03", "09", "51", "52", "61", "62"),
	alpha = c(0.4139968, 0.4439589, 0.3962135, 0.3625385, 0.3826291, 0.4333959, 0.4468885),
	beta = c(-0.0069499, -0.0203087, 0.0004032, 0.0172278, 0.0057494, 0.0043911, -0.0315384),
	gamma = c(-0.3001131, -0.2944278, -0.2723268, -0.1878927, -0.2250570, -0.2955610, -0.3736340),
	delta = c(-0.0348160, -0.0390426, -0.0353373, -0.0238314, -0.0247413, -0.0305603, -0.0321009),
	eta = c(-0.0075658, -0.0140190, -0.0166928, -0.0183863, -0.0026865, -0.0089731, 0.0188160),
	bft_min = c(0.15, 0.15, 0.13, 0.17, 0.17, 0.17, 0.20),
	bft_max = c(0.44, 0.43, 0.43, 0.40, 0.42, 0.48, 0.43),
	bft_lim = c(0.8, 0.8, 0.9, 0.9, 1.0, 0.9, 0.9),
	key = "speciesName_sci"
)
```

```{r}
#### Check estimated hdec of Emerge vs measured hdec from nfi for Fagus sylvatica
hdec_dt = inra[speciesName_sci == "Fagus sylvatica" & !is.na(hdec)]

plot(nfi["Fagus sylvatica", circumference_m], nfi["Fagus sylvatica", taper_height], pch = 19,
	cex = 0.75, xlab = "Circumference", ylab = "Taper height", axes = FALSE, col = "#0F7BA2")
points(hdec_dt[, circumference_m], hdec_dt[, hdec], col = "#FAB255", pch = 19, cex = 0.75)
axis(1)
axis(2, las = 1)

#### Compute the taper volume for 7 species
inra[speciesName_sci == "Fagus sylvatica" & !is.na(hdec),
	bole_volume_m3_gohon := florence_bft(circumference_m, height, hdec,
		params = coeffs_3["Fagus sylvatica", .(alpha, beta, gamma, delta, eta)],
		bounds = coeffs_3["Fagus sylvatica", .(bft_min, bft_max, bft_lim)])]

plot(inra[, bole_volume_m3_gohon], inra[, bole_volume_m3], pch = 19, cex = 0.75,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")

inra[, bole_volume_m3_gohon := NULL]
```

### Fit model Florence{#sec-univariate_BFT}

The model is described by @eq-flo_univariate:
$$
	\Fbft = \alpha_i + \beta_i c + \gamma_i \frac{\sqrt{c}}{\hdec'} + \delta_i \frac{\sqrt{\hdec'}}{c^2 h} + \eta_i \left( 1 - \frac{\hdec'}{h} \right)
$${#eq-flo_univariate}

For the code and equation, see `rapport_tarifs.Rmd`, line 638. I now fit a Bayesian version of Florence's model for *Fagus sylvatica*.

```{r}
model = cmdstan_model("./florence_univariate.stan")

stanData = list(
	N = nfi["Fagus sylvatica", .N],

	circumference_m = nfi["Fagus sylvatica", circumference_m],
	height = nfi["Fagus sylvatica", height],
	hdec = nfi["Fagus sylvatica", taper_height],

	bole_volume_m3 = nfi["Fagus sylvatica", bole_volume_m3]
)

n_chains = 4
fit = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4), max_treedepth = 12)

if (!file.exists("florence-fagSyl.rds"))
{
	fit$save_output_files(dir = "./", basename = paste0("florence-fagSyl"), random = FALSE)
	saveRDS(fit, "florence-fagSyl.rds")
} else {
	fit = readRDS("./florence-fagSyl.rds")
}

#### Check posterior
lazyPosterior(fit$draws("alpha"), val1 = coeffs_3["Fagus sylvatica", alpha])
lazyPosterior(fit$draws("beta_"), val1 = coeffs_3["Fagus sylvatica", beta])
lazyPosterior(fit$draws("gamma"), val1 = coeffs_3["Fagus sylvatica", gamma])
lazyPosterior(fit$draws("delta"), val1 = coeffs_3["Fagus sylvatica", delta])
lazyPosterior(fit$draws("eta"), val1 = coeffs_3["Fagus sylvatica", eta])

lazyPosterior(fit$draws("sigma"), fun = dgamma, shape = 0.1, rate = 0.1)

fagSyl = rbindlist(list(florence = coeffs_3["Fagus sylvatica", .(alpha, beta, gamma, delta, eta)],
	amael = data.table(
		alpha = mean(fit$draws("alpha")),
		beta = mean(fit$draws("beta_")),
		gamma = mean(fit$draws("gamma")),
		delta = mean(fit$draws("delta")),
		eta = mean(fit$draws("eta")))
), idcol = "model")

#### Check posterior prediction
k = nfi["Fagus sylvatica", which.max(bole_volume_m3)]
draws = getVol(nfi["Fagus sylvatica"], k, fit)
lazyPosterior(draws, val1 = nfi["Fagus sylvatica"][k, bole_volume_m3])

k = nfi["Fagus sylvatica", which.min(bole_volume_m3)]
draws = getVol(nfi["Fagus sylvatica"], k, fit)
lazyPosterior(draws, val1 = nfi["Fagus sylvatica"][k, bole_volume_m3])

k = 68
draws = getVol(nfi["Fagus sylvatica"], k, fit)
lazyPosterior(draws, val1 = nfi["Fagus sylvatica"][k, bole_volume_m3])

#### Pred on Inra data
genQ = cmdstan_model("./florence_univariate_genQ.stan")
stanData_gen = list(
	N = inra_dec["Fagus sylvatica", .N],

	circumference_m = inra_dec["Fagus sylvatica", circumference_m],
	height = inra_dec["Fagus sylvatica", height],
	hdec = inra_dec["Fagus sylvatica", hdec],

	bole_volume_m3 = inra_dec["Fagus sylvatica", bole_volume_m3]
)

sim = genQ$generate_quantities(fit, data = stanData_gen, seed = 123, parallel_chains = min(n_chains, 4))

k = 12
str = paste0("pred_bole[", k, "]")
lazyPosterior(sim$draws(str), val1 = inra_dec["Fagus sylvatica"][k, bole_volume_m3])

mean_pred = apply(X = sim$draws("pred_bole"), MARGIN = 3, FUN = mean)
plot(mean_pred, inra_dec["Fagus sylvatica", bole_volume_m3], pch = 19, cex = 0.3,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
```

### Try with heteroskedasticity

Based on the previous section, I add heteroskedasticity by modelling the variance with a power-law:
$$
	\sigma = a (c^2 h)^b,
$$
where $a > 0$ and $b$ are two parameters to estimate. I fit the model on 6000 individuals only, in order to go faster.

```{r}
model = cmdstan_model("./florence_univariate_heterosked.stan")

sam = sample(seq_len(nfi["Fagus sylvatica", .N]), size = 6e3, replace = FALSE)
nfi_sam = nfi["Fagus sylvatica"][sam]

stanData = list(
	N = 6e3, # nfi["Fagus sylvatica", .N],

	circumference_m = nfi_sam[, circumference_m],
	height = nfi_sam[, height],
	hdec = nfi_sam[, taper_height],

	bole_volume_m3 = nfi_sam[, bole_volume_m3]
)

n_chains = 4

fit_heterosked = model$sample(data = stanData, chains = n_chains, parallel_chains = min(n_chains, 4),
	max_treedepth = 12)

if (!file.exists("florence-fagSyl_heterosked.rds"))
{
	fit_heterosked$save_output_files(dir = "./", basename = paste0("florence-fagSyl_heterosked"), random = FALSE)
	saveRDS(fit_heterosked, "florence-fagSyl_heterosked.rds")
} else {
	fit_heterosked = readRDS("florence-fagSyl_heterosked.rds")
}

fagSyl = rbindlist(list(fagSyl,
	data.table(
		model = "heterosked",
		alpha = mean(fit_heterosked$draws("alpha")),
		beta = mean(fit_heterosked$draws("beta_")),
		gamma = mean(fit_heterosked$draws("gamma")),
		delta = mean(fit_heterosked$draws("delta")),
		eta = mean(fit_heterosked$draws("eta")))
))
```

As shown in the following table, the results between Florence and I are quite different, despite being the same model. The training dataset might not be exactly the same, but I guess the major difference comes from the Bayesian framework. Adding heterosked did not change that much the values.

```{r}
fagSyl |>
	gt() |>
	cols_label(
		model = "Model",
	) |>
	tab_style(
		style = cell_borders(sides = "all", style = NULL),
		locations = cells_body()
	) |>
	tab_style(
		style = cell_text(weight = "bold", align = "right"),
		locations = list(cells_column_labels(), cells_column_spanners())
	) |>
	tab_style(
		style = list(cell_fill(color = "#FFFFFF"), cell_text(color = "#122112", weight = "bold",
			align = "right")),
		locations = cells_body(columns = model)
	) |>
	fmt_number(
		columns = ends_with("a"),
		decimals = 2
	)
```

```{r}
a = mean(fit_heterosked$draws("a"))
b = mean(fit_heterosked$draws("b"))

sigma_fct = function(x, a, b)
	return (a*x^b)

range(stanData$circumference_m^2*stanData$height)
curve(sigma_fct(x, a, b), to = 700)

genQ = cmdstan_model("./florence_univariate_heterosked_genQ.stan")
sim = genQ$generate_quantities(fit_heterosked, data = stanData_gen, seed = 123, parallel_chains = min(n_chains, 4))

k = 12
str = paste0("pred_bole[", k, "]")
lazyPosterior(sim$draws(str), val1 = inra_dec["Fagus sylvatica"][k, bole_volume_m3])

mean_pred = apply(X = sim$draws("pred_bole"), MARGIN = 3, FUN = mean)
plot(mean_pred, inra_dec["Fagus sylvatica", bole_volume_m3], pch = 19, cex = 0.3,
	xlab = "Pred", ylab = "Obs", axes = FALSE)
axis(1)
axis(2, las = 1)
abline(a = 0, b = 1, lwd = 2, col = "#CD212A")
```

## Explore the crown

In this section, I look at the relation there can be between the crown and tree dimensions (circumference, height, and taper height).

```{r}
inra_dec = inra["Fagus sylvatica"][!is.na(hdec) & !(presence_NA)]

lim = quantile(inra_dec[, hdec], c(0.25, 0.5, 0.75))
inra_dec[, colour := met.brewer("Egypt")[1]]
inra_dec[(lim["25%"] < hdec) & (hdec <= lim["50%"]), colour := met.brewer("Egypt")[2]]
inra_dec[(lim["50%"] < hdec) & (hdec <= lim["75%"]), colour := met.brewer("Egypt")[3]]
inra_dec[lim["75%"] < hdec, colour := met.brewer("Egypt")[4]]

plot(inra_dec[, log(circumference_m)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.65, xlab = "Circumference", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height - hdec)], inra_dec[, log(crown_volume_m3)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Crown volume", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
```

Not that convincing... Let us try to use a form factor similar to the one used for bole volume:
$$
	\Fcrn = \frac{4\pi \Vcrn}{c^2 h} \left( 1 - \frac{1.3}{h} \right)^2
$$

```{r}
inra_dec[, Fcrn := 4*pi*crown_volume_m3/(circumference_m^2*height)*(1 - 1.3/height)^2]
inra_dec[, Fcrn_sphere := 6*pi^2*crown_volume_m3/circumference_m^3]

plot(inra_dec[, log(circumference_m)], inra_dec[, log(Fcrn)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Circumference", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(Fcrn)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height) - hdec], inra_dec[, Fcrn], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Form factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(circumference_m)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Circumference", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(hdec)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Taper height", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)

plot(inra_dec[, log(height - hdec)], inra_dec[, log(Fcrn_sphere)], pch = 19, col = inra_dec[, colour],
	cex = 0.35, xlab = "Crown height", ylab = "Sphere factor", axes = FALSE)
legend(x = "topleft", legend = c("small", "med", "tall", "very tall"), fill = met.brewer("Egypt")[1:4])
axis(1)
axis(2, las = 1)
```

## Simple test of crown model

I will try a crown model with a hierarchy at the taper height level (try also with height and more values!). This model will use $\log(c)$ to predict $\log(\Vcrn)$.
